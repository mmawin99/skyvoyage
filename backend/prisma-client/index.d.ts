
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model admin
 * 
 */
export type admin = $Result.DefaultSelection<Prisma.$adminPayload>
/**
 * Model airline
 * 
 */
export type airline = $Result.DefaultSelection<Prisma.$airlinePayload>
/**
 * Model aircraft
 * 
 */
export type aircraft = $Result.DefaultSelection<Prisma.$aircraftPayload>
/**
 * Model aircraftCost
 * 
 */
export type aircraftCost = $Result.DefaultSelection<Prisma.$aircraftCostPayload>
/**
 * Model airport
 * 
 */
export type airport = $Result.DefaultSelection<Prisma.$airportPayload>
/**
 * Model booking
 * 
 */
export type booking = $Result.DefaultSelection<Prisma.$bookingPayload>
/**
 * Model booking_flight
 * 
 */
export type booking_flight = $Result.DefaultSelection<Prisma.$booking_flightPayload>
/**
 * Model flight
 * 
 */
export type flight = $Result.DefaultSelection<Prisma.$flightPayload>
/**
 * Model flightOperate
 * 
 */
export type flightOperate = $Result.DefaultSelection<Prisma.$flightOperatePayload>
/**
 * Model passenger
 * 
 */
export type passenger = $Result.DefaultSelection<Prisma.$passengerPayload>
/**
 * Model passenger_booking
 * 
 */
export type passenger_booking = $Result.DefaultSelection<Prisma.$passenger_bookingPayload>
/**
 * Model payment
 * 
 */
export type payment = $Result.DefaultSelection<Prisma.$paymentPayload>
/**
 * Model aircraft_seatmap
 * 
 */
export type aircraft_seatmap = $Result.DefaultSelection<Prisma.$aircraft_seatmapPayload>
/**
 * Model seatmap_info
 * 
 */
export type seatmap_info = $Result.DefaultSelection<Prisma.$seatmap_infoPayload>
/**
 * Model seat
 * 
 */
export type seat = $Result.DefaultSelection<Prisma.$seatPayload>
/**
 * Model ticket
 * 
 */
export type ticket = $Result.DefaultSelection<Prisma.$ticketPayload>
/**
 * Model transit
 * 
 */
export type transit = $Result.DefaultSelection<Prisma.$transitPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Permission: {
  SUPER: 'SUPER',
  DATA_ENTRY: 'DATA_ENTRY'
};

export type Permission = (typeof Permission)[keyof typeof Permission]


export const BookingStatus: {
  PAID: 'PAID',
  UNPAID: 'UNPAID',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const AgeRange: {
  Adult: 'Adult',
  Children: 'Children',
  Infant: 'Infant'
};

export type AgeRange = (typeof AgeRange)[keyof typeof AgeRange]


export const SeatClass: {
  F: 'F',
  C: 'C',
  Y: 'Y',
  W: 'W'
};

export type SeatClass = (typeof SeatClass)[keyof typeof SeatClass]


export const FarePackage: {
  SUPER_SAVER: 'SUPER_SAVER',
  SAVER: 'SAVER',
  STANDARD: 'STANDARD',
  FLEXI: 'FLEXI',
  FULL_FLEX: 'FULL_FLEX'
};

export type FarePackage = (typeof FarePackage)[keyof typeof FarePackage]

}

export type Permission = $Enums.Permission

export const Permission: typeof $Enums.Permission

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type AgeRange = $Enums.AgeRange

export const AgeRange: typeof $Enums.AgeRange

export type SeatClass = $Enums.SeatClass

export const SeatClass: typeof $Enums.SeatClass

export type FarePackage = $Enums.FarePackage

export const FarePackage: typeof $Enums.FarePackage

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.airline`: Exposes CRUD operations for the **airline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Airlines
    * const airlines = await prisma.airline.findMany()
    * ```
    */
  get airline(): Prisma.airlineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aircraft`: Exposes CRUD operations for the **aircraft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Aircraft
    * const aircraft = await prisma.aircraft.findMany()
    * ```
    */
  get aircraft(): Prisma.aircraftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aircraftCost`: Exposes CRUD operations for the **aircraftCost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AircraftCosts
    * const aircraftCosts = await prisma.aircraftCost.findMany()
    * ```
    */
  get aircraftCost(): Prisma.aircraftCostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.airport`: Exposes CRUD operations for the **airport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Airports
    * const airports = await prisma.airport.findMany()
    * ```
    */
  get airport(): Prisma.airportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.bookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking_flight`: Exposes CRUD operations for the **booking_flight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Booking_flights
    * const booking_flights = await prisma.booking_flight.findMany()
    * ```
    */
  get booking_flight(): Prisma.booking_flightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flight`: Exposes CRUD operations for the **flight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flights
    * const flights = await prisma.flight.findMany()
    * ```
    */
  get flight(): Prisma.flightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flightOperate`: Exposes CRUD operations for the **flightOperate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlightOperates
    * const flightOperates = await prisma.flightOperate.findMany()
    * ```
    */
  get flightOperate(): Prisma.flightOperateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passenger`: Exposes CRUD operations for the **passenger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passengers
    * const passengers = await prisma.passenger.findMany()
    * ```
    */
  get passenger(): Prisma.passengerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passenger_booking`: Exposes CRUD operations for the **passenger_booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passenger_bookings
    * const passenger_bookings = await prisma.passenger_booking.findMany()
    * ```
    */
  get passenger_booking(): Prisma.passenger_bookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aircraft_seatmap`: Exposes CRUD operations for the **aircraft_seatmap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Aircraft_seatmaps
    * const aircraft_seatmaps = await prisma.aircraft_seatmap.findMany()
    * ```
    */
  get aircraft_seatmap(): Prisma.aircraft_seatmapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seatmap_info`: Exposes CRUD operations for the **seatmap_info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seatmap_infos
    * const seatmap_infos = await prisma.seatmap_info.findMany()
    * ```
    */
  get seatmap_info(): Prisma.seatmap_infoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seat`: Exposes CRUD operations for the **seat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seats
    * const seats = await prisma.seat.findMany()
    * ```
    */
  get seat(): Prisma.seatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.ticketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transit`: Exposes CRUD operations for the **transit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transits
    * const transits = await prisma.transit.findMany()
    * ```
    */
  get transit(): Prisma.transitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    admin: 'admin',
    airline: 'airline',
    aircraft: 'aircraft',
    aircraftCost: 'aircraftCost',
    airport: 'airport',
    booking: 'booking',
    booking_flight: 'booking_flight',
    flight: 'flight',
    flightOperate: 'flightOperate',
    passenger: 'passenger',
    passenger_booking: 'passenger_booking',
    payment: 'payment',
    aircraft_seatmap: 'aircraft_seatmap',
    seatmap_info: 'seatmap_info',
    seat: 'seat',
    ticket: 'ticket',
    transit: 'transit',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin" | "airline" | "aircraft" | "aircraftCost" | "airport" | "booking" | "booking_flight" | "flight" | "flightOperate" | "passenger" | "passenger_booking" | "payment" | "aircraft_seatmap" | "seatmap_info" | "seat" | "ticket" | "transit" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      admin: {
        payload: Prisma.$adminPayload<ExtArgs>
        fields: Prisma.adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findFirst: {
            args: Prisma.adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findMany: {
            args: Prisma.adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          create: {
            args: Prisma.adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          createMany: {
            args: Prisma.adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          update: {
            args: Prisma.adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          deleteMany: {
            args: Prisma.adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      airline: {
        payload: Prisma.$airlinePayload<ExtArgs>
        fields: Prisma.airlineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.airlineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airlinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.airlineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airlinePayload>
          }
          findFirst: {
            args: Prisma.airlineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airlinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.airlineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airlinePayload>
          }
          findMany: {
            args: Prisma.airlineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airlinePayload>[]
          }
          create: {
            args: Prisma.airlineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airlinePayload>
          }
          createMany: {
            args: Prisma.airlineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.airlineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airlinePayload>
          }
          update: {
            args: Prisma.airlineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airlinePayload>
          }
          deleteMany: {
            args: Prisma.airlineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.airlineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.airlineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airlinePayload>
          }
          aggregate: {
            args: Prisma.AirlineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAirline>
          }
          groupBy: {
            args: Prisma.airlineGroupByArgs<ExtArgs>
            result: $Utils.Optional<AirlineGroupByOutputType>[]
          }
          count: {
            args: Prisma.airlineCountArgs<ExtArgs>
            result: $Utils.Optional<AirlineCountAggregateOutputType> | number
          }
        }
      }
      aircraft: {
        payload: Prisma.$aircraftPayload<ExtArgs>
        fields: Prisma.aircraftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.aircraftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aircraftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftPayload>
          }
          findFirst: {
            args: Prisma.aircraftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aircraftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftPayload>
          }
          findMany: {
            args: Prisma.aircraftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftPayload>[]
          }
          create: {
            args: Prisma.aircraftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftPayload>
          }
          createMany: {
            args: Prisma.aircraftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.aircraftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftPayload>
          }
          update: {
            args: Prisma.aircraftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftPayload>
          }
          deleteMany: {
            args: Prisma.aircraftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.aircraftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.aircraftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftPayload>
          }
          aggregate: {
            args: Prisma.AircraftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAircraft>
          }
          groupBy: {
            args: Prisma.aircraftGroupByArgs<ExtArgs>
            result: $Utils.Optional<AircraftGroupByOutputType>[]
          }
          count: {
            args: Prisma.aircraftCountArgs<ExtArgs>
            result: $Utils.Optional<AircraftCountAggregateOutputType> | number
          }
        }
      }
      aircraftCost: {
        payload: Prisma.$aircraftCostPayload<ExtArgs>
        fields: Prisma.aircraftCostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.aircraftCostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftCostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aircraftCostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftCostPayload>
          }
          findFirst: {
            args: Prisma.aircraftCostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftCostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aircraftCostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftCostPayload>
          }
          findMany: {
            args: Prisma.aircraftCostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftCostPayload>[]
          }
          create: {
            args: Prisma.aircraftCostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftCostPayload>
          }
          createMany: {
            args: Prisma.aircraftCostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.aircraftCostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftCostPayload>
          }
          update: {
            args: Prisma.aircraftCostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftCostPayload>
          }
          deleteMany: {
            args: Prisma.aircraftCostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.aircraftCostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.aircraftCostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraftCostPayload>
          }
          aggregate: {
            args: Prisma.AircraftCostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAircraftCost>
          }
          groupBy: {
            args: Prisma.aircraftCostGroupByArgs<ExtArgs>
            result: $Utils.Optional<AircraftCostGroupByOutputType>[]
          }
          count: {
            args: Prisma.aircraftCostCountArgs<ExtArgs>
            result: $Utils.Optional<AircraftCostCountAggregateOutputType> | number
          }
        }
      }
      airport: {
        payload: Prisma.$airportPayload<ExtArgs>
        fields: Prisma.airportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.airportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.airportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>
          }
          findFirst: {
            args: Prisma.airportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.airportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>
          }
          findMany: {
            args: Prisma.airportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>[]
          }
          create: {
            args: Prisma.airportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>
          }
          createMany: {
            args: Prisma.airportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.airportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>
          }
          update: {
            args: Prisma.airportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>
          }
          deleteMany: {
            args: Prisma.airportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.airportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.airportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$airportPayload>
          }
          aggregate: {
            args: Prisma.AirportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAirport>
          }
          groupBy: {
            args: Prisma.airportGroupByArgs<ExtArgs>
            result: $Utils.Optional<AirportGroupByOutputType>[]
          }
          count: {
            args: Prisma.airportCountArgs<ExtArgs>
            result: $Utils.Optional<AirportCountAggregateOutputType> | number
          }
        }
      }
      booking: {
        payload: Prisma.$bookingPayload<ExtArgs>
        fields: Prisma.bookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingPayload>
          }
          findFirst: {
            args: Prisma.bookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingPayload>
          }
          findMany: {
            args: Prisma.bookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingPayload>[]
          }
          create: {
            args: Prisma.bookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingPayload>
          }
          createMany: {
            args: Prisma.bookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingPayload>
          }
          update: {
            args: Prisma.bookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingPayload>
          }
          deleteMany: {
            args: Prisma.bookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.bookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.bookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      booking_flight: {
        payload: Prisma.$booking_flightPayload<ExtArgs>
        fields: Prisma.booking_flightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.booking_flightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_flightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.booking_flightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_flightPayload>
          }
          findFirst: {
            args: Prisma.booking_flightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_flightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.booking_flightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_flightPayload>
          }
          findMany: {
            args: Prisma.booking_flightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_flightPayload>[]
          }
          create: {
            args: Prisma.booking_flightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_flightPayload>
          }
          createMany: {
            args: Prisma.booking_flightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.booking_flightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_flightPayload>
          }
          update: {
            args: Prisma.booking_flightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_flightPayload>
          }
          deleteMany: {
            args: Prisma.booking_flightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.booking_flightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.booking_flightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_flightPayload>
          }
          aggregate: {
            args: Prisma.Booking_flightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking_flight>
          }
          groupBy: {
            args: Prisma.booking_flightGroupByArgs<ExtArgs>
            result: $Utils.Optional<Booking_flightGroupByOutputType>[]
          }
          count: {
            args: Prisma.booking_flightCountArgs<ExtArgs>
            result: $Utils.Optional<Booking_flightCountAggregateOutputType> | number
          }
        }
      }
      flight: {
        payload: Prisma.$flightPayload<ExtArgs>
        fields: Prisma.flightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.flightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.flightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>
          }
          findFirst: {
            args: Prisma.flightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.flightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>
          }
          findMany: {
            args: Prisma.flightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>[]
          }
          create: {
            args: Prisma.flightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>
          }
          createMany: {
            args: Prisma.flightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.flightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>
          }
          update: {
            args: Prisma.flightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>
          }
          deleteMany: {
            args: Prisma.flightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.flightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.flightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightPayload>
          }
          aggregate: {
            args: Prisma.FlightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlight>
          }
          groupBy: {
            args: Prisma.flightGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlightGroupByOutputType>[]
          }
          count: {
            args: Prisma.flightCountArgs<ExtArgs>
            result: $Utils.Optional<FlightCountAggregateOutputType> | number
          }
        }
      }
      flightOperate: {
        payload: Prisma.$flightOperatePayload<ExtArgs>
        fields: Prisma.flightOperateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.flightOperateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightOperatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.flightOperateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightOperatePayload>
          }
          findFirst: {
            args: Prisma.flightOperateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightOperatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.flightOperateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightOperatePayload>
          }
          findMany: {
            args: Prisma.flightOperateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightOperatePayload>[]
          }
          create: {
            args: Prisma.flightOperateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightOperatePayload>
          }
          createMany: {
            args: Prisma.flightOperateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.flightOperateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightOperatePayload>
          }
          update: {
            args: Prisma.flightOperateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightOperatePayload>
          }
          deleteMany: {
            args: Prisma.flightOperateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.flightOperateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.flightOperateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$flightOperatePayload>
          }
          aggregate: {
            args: Prisma.FlightOperateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlightOperate>
          }
          groupBy: {
            args: Prisma.flightOperateGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlightOperateGroupByOutputType>[]
          }
          count: {
            args: Prisma.flightOperateCountArgs<ExtArgs>
            result: $Utils.Optional<FlightOperateCountAggregateOutputType> | number
          }
        }
      }
      passenger: {
        payload: Prisma.$passengerPayload<ExtArgs>
        fields: Prisma.passengerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.passengerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passengerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.passengerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passengerPayload>
          }
          findFirst: {
            args: Prisma.passengerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passengerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.passengerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passengerPayload>
          }
          findMany: {
            args: Prisma.passengerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passengerPayload>[]
          }
          create: {
            args: Prisma.passengerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passengerPayload>
          }
          createMany: {
            args: Prisma.passengerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.passengerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passengerPayload>
          }
          update: {
            args: Prisma.passengerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passengerPayload>
          }
          deleteMany: {
            args: Prisma.passengerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.passengerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.passengerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passengerPayload>
          }
          aggregate: {
            args: Prisma.PassengerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassenger>
          }
          groupBy: {
            args: Prisma.passengerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PassengerGroupByOutputType>[]
          }
          count: {
            args: Prisma.passengerCountArgs<ExtArgs>
            result: $Utils.Optional<PassengerCountAggregateOutputType> | number
          }
        }
      }
      passenger_booking: {
        payload: Prisma.$passenger_bookingPayload<ExtArgs>
        fields: Prisma.passenger_bookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.passenger_bookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passenger_bookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.passenger_bookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passenger_bookingPayload>
          }
          findFirst: {
            args: Prisma.passenger_bookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passenger_bookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.passenger_bookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passenger_bookingPayload>
          }
          findMany: {
            args: Prisma.passenger_bookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passenger_bookingPayload>[]
          }
          create: {
            args: Prisma.passenger_bookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passenger_bookingPayload>
          }
          createMany: {
            args: Prisma.passenger_bookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.passenger_bookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passenger_bookingPayload>
          }
          update: {
            args: Prisma.passenger_bookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passenger_bookingPayload>
          }
          deleteMany: {
            args: Prisma.passenger_bookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.passenger_bookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.passenger_bookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passenger_bookingPayload>
          }
          aggregate: {
            args: Prisma.Passenger_bookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassenger_booking>
          }
          groupBy: {
            args: Prisma.passenger_bookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<Passenger_bookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.passenger_bookingCountArgs<ExtArgs>
            result: $Utils.Optional<Passenger_bookingCountAggregateOutputType> | number
          }
        }
      }
      payment: {
        payload: Prisma.$paymentPayload<ExtArgs>
        fields: Prisma.paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findFirst: {
            args: Prisma.paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findMany: {
            args: Prisma.paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          create: {
            args: Prisma.paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          createMany: {
            args: Prisma.paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          update: {
            args: Prisma.paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          deleteMany: {
            args: Prisma.paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      aircraft_seatmap: {
        payload: Prisma.$aircraft_seatmapPayload<ExtArgs>
        fields: Prisma.aircraft_seatmapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.aircraft_seatmapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraft_seatmapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aircraft_seatmapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraft_seatmapPayload>
          }
          findFirst: {
            args: Prisma.aircraft_seatmapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraft_seatmapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aircraft_seatmapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraft_seatmapPayload>
          }
          findMany: {
            args: Prisma.aircraft_seatmapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraft_seatmapPayload>[]
          }
          create: {
            args: Prisma.aircraft_seatmapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraft_seatmapPayload>
          }
          createMany: {
            args: Prisma.aircraft_seatmapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.aircraft_seatmapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraft_seatmapPayload>
          }
          update: {
            args: Prisma.aircraft_seatmapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraft_seatmapPayload>
          }
          deleteMany: {
            args: Prisma.aircraft_seatmapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.aircraft_seatmapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.aircraft_seatmapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aircraft_seatmapPayload>
          }
          aggregate: {
            args: Prisma.Aircraft_seatmapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAircraft_seatmap>
          }
          groupBy: {
            args: Prisma.aircraft_seatmapGroupByArgs<ExtArgs>
            result: $Utils.Optional<Aircraft_seatmapGroupByOutputType>[]
          }
          count: {
            args: Prisma.aircraft_seatmapCountArgs<ExtArgs>
            result: $Utils.Optional<Aircraft_seatmapCountAggregateOutputType> | number
          }
        }
      }
      seatmap_info: {
        payload: Prisma.$seatmap_infoPayload<ExtArgs>
        fields: Prisma.seatmap_infoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.seatmap_infoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatmap_infoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.seatmap_infoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatmap_infoPayload>
          }
          findFirst: {
            args: Prisma.seatmap_infoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatmap_infoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.seatmap_infoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatmap_infoPayload>
          }
          findMany: {
            args: Prisma.seatmap_infoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatmap_infoPayload>[]
          }
          create: {
            args: Prisma.seatmap_infoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatmap_infoPayload>
          }
          createMany: {
            args: Prisma.seatmap_infoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.seatmap_infoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatmap_infoPayload>
          }
          update: {
            args: Prisma.seatmap_infoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatmap_infoPayload>
          }
          deleteMany: {
            args: Prisma.seatmap_infoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.seatmap_infoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.seatmap_infoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatmap_infoPayload>
          }
          aggregate: {
            args: Prisma.Seatmap_infoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeatmap_info>
          }
          groupBy: {
            args: Prisma.seatmap_infoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Seatmap_infoGroupByOutputType>[]
          }
          count: {
            args: Prisma.seatmap_infoCountArgs<ExtArgs>
            result: $Utils.Optional<Seatmap_infoCountAggregateOutputType> | number
          }
        }
      }
      seat: {
        payload: Prisma.$seatPayload<ExtArgs>
        fields: Prisma.seatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.seatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.seatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>
          }
          findFirst: {
            args: Prisma.seatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.seatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>
          }
          findMany: {
            args: Prisma.seatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>[]
          }
          create: {
            args: Prisma.seatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>
          }
          createMany: {
            args: Prisma.seatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.seatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>
          }
          update: {
            args: Prisma.seatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>
          }
          deleteMany: {
            args: Prisma.seatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.seatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.seatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seatPayload>
          }
          aggregate: {
            args: Prisma.SeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeat>
          }
          groupBy: {
            args: Prisma.seatGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.seatCountArgs<ExtArgs>
            result: $Utils.Optional<SeatCountAggregateOutputType> | number
          }
        }
      }
      ticket: {
        payload: Prisma.$ticketPayload<ExtArgs>
        fields: Prisma.ticketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ticketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ticketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketPayload>
          }
          findFirst: {
            args: Prisma.ticketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ticketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketPayload>
          }
          findMany: {
            args: Prisma.ticketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketPayload>[]
          }
          create: {
            args: Prisma.ticketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketPayload>
          }
          createMany: {
            args: Prisma.ticketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ticketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketPayload>
          }
          update: {
            args: Prisma.ticketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketPayload>
          }
          deleteMany: {
            args: Prisma.ticketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ticketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ticketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ticketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.ticketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.ticketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      transit: {
        payload: Prisma.$transitPayload<ExtArgs>
        fields: Prisma.transitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transitPayload>
          }
          findFirst: {
            args: Prisma.transitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transitPayload>
          }
          findMany: {
            args: Prisma.transitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transitPayload>[]
          }
          create: {
            args: Prisma.transitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transitPayload>
          }
          createMany: {
            args: Prisma.transitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transitPayload>
          }
          update: {
            args: Prisma.transitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transitPayload>
          }
          deleteMany: {
            args: Prisma.transitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transitPayload>
          }
          aggregate: {
            args: Prisma.TransitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransit>
          }
          groupBy: {
            args: Prisma.transitGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransitGroupByOutputType>[]
          }
          count: {
            args: Prisma.transitCountArgs<ExtArgs>
            result: $Utils.Optional<TransitCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin?: adminOmit
    airline?: airlineOmit
    aircraft?: aircraftOmit
    aircraftCost?: aircraftCostOmit
    airport?: airportOmit
    booking?: bookingOmit
    booking_flight?: booking_flightOmit
    flight?: flightOmit
    flightOperate?: flightOperateOmit
    passenger?: passengerOmit
    passenger_booking?: passenger_bookingOmit
    payment?: paymentOmit
    aircraft_seatmap?: aircraft_seatmapOmit
    seatmap_info?: seatmap_infoOmit
    seat?: seatOmit
    ticket?: ticketOmit
    transit?: transitOmit
    user?: userOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AirlineCountOutputType
   */

  export type AirlineCountOutputType = {
    aircraft: number
    aircraftCost: number
    flight: number
  }

  export type AirlineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraft?: boolean | AirlineCountOutputTypeCountAircraftArgs
    aircraftCost?: boolean | AirlineCountOutputTypeCountAircraftCostArgs
    flight?: boolean | AirlineCountOutputTypeCountFlightArgs
  }

  // Custom InputTypes
  /**
   * AirlineCountOutputType without action
   */
  export type AirlineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirlineCountOutputType
     */
    select?: AirlineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AirlineCountOutputType without action
   */
  export type AirlineCountOutputTypeCountAircraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aircraftWhereInput
  }

  /**
   * AirlineCountOutputType without action
   */
  export type AirlineCountOutputTypeCountAircraftCostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aircraftCostWhereInput
  }

  /**
   * AirlineCountOutputType without action
   */
  export type AirlineCountOutputTypeCountFlightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flightWhereInput
  }


  /**
   * Count Type AircraftCountOutputType
   */

  export type AircraftCountOutputType = {
    flightOperate: number
    aircraftSeatmap: number
  }

  export type AircraftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flightOperate?: boolean | AircraftCountOutputTypeCountFlightOperateArgs
    aircraftSeatmap?: boolean | AircraftCountOutputTypeCountAircraftSeatmapArgs
  }

  // Custom InputTypes
  /**
   * AircraftCountOutputType without action
   */
  export type AircraftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AircraftCountOutputType
     */
    select?: AircraftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AircraftCountOutputType without action
   */
  export type AircraftCountOutputTypeCountFlightOperateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flightOperateWhereInput
  }

  /**
   * AircraftCountOutputType without action
   */
  export type AircraftCountOutputTypeCountAircraftSeatmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aircraft_seatmapWhereInput
  }


  /**
   * Count Type AirportCountOutputType
   */

  export type AirportCountOutputType = {
    departFlights: number
    arriveFlights: number
  }

  export type AirportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departFlights?: boolean | AirportCountOutputTypeCountDepartFlightsArgs
    arriveFlights?: boolean | AirportCountOutputTypeCountArriveFlightsArgs
  }

  // Custom InputTypes
  /**
   * AirportCountOutputType without action
   */
  export type AirportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirportCountOutputType
     */
    select?: AirportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AirportCountOutputType without action
   */
  export type AirportCountOutputTypeCountDepartFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flightWhereInput
  }

  /**
   * AirportCountOutputType without action
   */
  export type AirportCountOutputTypeCountArriveFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flightWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    bookingFlights: number
    passengerBookings: number
    tickets: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingFlights?: boolean | BookingCountOutputTypeCountBookingFlightsArgs
    passengerBookings?: boolean | BookingCountOutputTypeCountPassengerBookingsArgs
    tickets?: boolean | BookingCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountBookingFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booking_flightWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPassengerBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: passenger_bookingWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ticketWhereInput
  }


  /**
   * Count Type FlightCountOutputType
   */

  export type FlightCountOutputType = {
    flightOperates: number
    transitFrom: number
    transitTo: number
  }

  export type FlightCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flightOperates?: boolean | FlightCountOutputTypeCountFlightOperatesArgs
    transitFrom?: boolean | FlightCountOutputTypeCountTransitFromArgs
    transitTo?: boolean | FlightCountOutputTypeCountTransitToArgs
  }

  // Custom InputTypes
  /**
   * FlightCountOutputType without action
   */
  export type FlightCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightCountOutputType
     */
    select?: FlightCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlightCountOutputType without action
   */
  export type FlightCountOutputTypeCountFlightOperatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flightOperateWhereInput
  }

  /**
   * FlightCountOutputType without action
   */
  export type FlightCountOutputTypeCountTransitFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transitWhereInput
  }

  /**
   * FlightCountOutputType without action
   */
  export type FlightCountOutputTypeCountTransitToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transitWhereInput
  }


  /**
   * Count Type FlightOperateCountOutputType
   */

  export type FlightOperateCountOutputType = {
    bookingFlights: number
    tickets: number
  }

  export type FlightOperateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingFlights?: boolean | FlightOperateCountOutputTypeCountBookingFlightsArgs
    tickets?: boolean | FlightOperateCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * FlightOperateCountOutputType without action
   */
  export type FlightOperateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightOperateCountOutputType
     */
    select?: FlightOperateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlightOperateCountOutputType without action
   */
  export type FlightOperateCountOutputTypeCountBookingFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booking_flightWhereInput
  }

  /**
   * FlightOperateCountOutputType without action
   */
  export type FlightOperateCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ticketWhereInput
  }


  /**
   * Count Type PassengerCountOutputType
   */

  export type PassengerCountOutputType = {
    passengerBookings: number
    tickets: number
  }

  export type PassengerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passengerBookings?: boolean | PassengerCountOutputTypeCountPassengerBookingsArgs
    tickets?: boolean | PassengerCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * PassengerCountOutputType without action
   */
  export type PassengerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerCountOutputType
     */
    select?: PassengerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PassengerCountOutputType without action
   */
  export type PassengerCountOutputTypeCountPassengerBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: passenger_bookingWhereInput
  }

  /**
   * PassengerCountOutputType without action
   */
  export type PassengerCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ticketWhereInput
  }


  /**
   * Count Type Seatmap_infoCountOutputType
   */

  export type Seatmap_infoCountOutputType = {
    seat: number
    aircraft: number
  }

  export type Seatmap_infoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seat?: boolean | Seatmap_infoCountOutputTypeCountSeatArgs
    aircraft?: boolean | Seatmap_infoCountOutputTypeCountAircraftArgs
  }

  // Custom InputTypes
  /**
   * Seatmap_infoCountOutputType without action
   */
  export type Seatmap_infoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seatmap_infoCountOutputType
     */
    select?: Seatmap_infoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Seatmap_infoCountOutputType without action
   */
  export type Seatmap_infoCountOutputTypeCountSeatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seatWhereInput
  }

  /**
   * Seatmap_infoCountOutputType without action
   */
  export type Seatmap_infoCountOutputTypeCountAircraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aircraft_seatmapWhereInput
  }


  /**
   * Count Type SeatCountOutputType
   */

  export type SeatCountOutputType = {
    tickets: number
  }

  export type SeatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | SeatCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * SeatCountOutputType without action
   */
  export type SeatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatCountOutputType
     */
    select?: SeatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeatCountOutputType without action
   */
  export type SeatCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ticketWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bookings: number
    passengers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    passengers?: boolean | UserCountOutputTypeCountPassengersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPassengersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: passengerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    fullname: string | null
    permission: $Enums.Permission | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    fullname: string | null
    permission: $Enums.Permission | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    username: number
    password: number
    fullname: number
    permission: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    fullname?: true
    permission?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    fullname?: true
    permission?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    fullname?: true
    permission?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
    orderBy?: adminOrderByWithAggregationInput | adminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    username: string
    password: string
    fullname: string | null
    permission: $Enums.Permission
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    fullname?: boolean
    permission?: boolean
  }, ExtArgs["result"]["admin"]>



  export type adminSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    fullname?: boolean
    permission?: boolean
  }

  export type adminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "fullname" | "permission", ExtArgs["result"]["admin"]>

  export type $adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      fullname: string | null
      permission: $Enums.Permission
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type adminGetPayload<S extends boolean | null | undefined | adminDefaultArgs> = $Result.GetResult<Prisma.$adminPayload, S>

  type adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<adminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin'], meta: { name: 'admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminFindUniqueArgs>(args: SelectSubset<T, adminFindUniqueArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs>(args: SelectSubset<T, adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminFindFirstArgs>(args?: SelectSubset<T, adminFindFirstArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs>(args?: SelectSubset<T, adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends adminFindManyArgs>(args?: SelectSubset<T, adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends adminCreateArgs>(args: SelectSubset<T, adminCreateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {adminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminCreateManyArgs>(args?: SelectSubset<T, adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends adminDeleteArgs>(args: SelectSubset<T, adminDeleteArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminUpdateArgs>(args: SelectSubset<T, adminUpdateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminDeleteManyArgs>(args?: SelectSubset<T, adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminUpdateManyArgs>(args: SelectSubset<T, adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends adminUpsertArgs>(args: SelectSubset<T, adminUpsertArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminGroupByArgs['orderBy'] }
        : { orderBy?: adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin model
   */
  readonly fields: adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin model
   */
  interface adminFieldRefs {
    readonly id: FieldRef<"admin", 'Int'>
    readonly username: FieldRef<"admin", 'String'>
    readonly password: FieldRef<"admin", 'String'>
    readonly fullname: FieldRef<"admin", 'String'>
    readonly permission: FieldRef<"admin", 'Permission'>
  }
    

  // Custom InputTypes
  /**
   * admin findUnique
   */
  export type adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findFirst
   */
  export type adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findMany
   */
  export type adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin create
   */
  export type adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The data needed to create a admin.
     */
    data: XOR<adminCreateInput, adminUncheckedCreateInput>
  }

  /**
   * admin createMany
   */
  export type adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin update
   */
  export type adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admin upsert
   */
  export type adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }

  /**
   * admin delete
   */
  export type adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to delete.
     */
    limit?: number
  }

  /**
   * admin without action
   */
  export type adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
  }


  /**
   * Model airline
   */

  export type AggregateAirline = {
    _count: AirlineCountAggregateOutputType | null
    _min: AirlineMinAggregateOutputType | null
    _max: AirlineMaxAggregateOutputType | null
  }

  export type AirlineMinAggregateOutputType = {
    airlineCode: string | null
    airlineName: string | null
  }

  export type AirlineMaxAggregateOutputType = {
    airlineCode: string | null
    airlineName: string | null
  }

  export type AirlineCountAggregateOutputType = {
    airlineCode: number
    airlineName: number
    _all: number
  }


  export type AirlineMinAggregateInputType = {
    airlineCode?: true
    airlineName?: true
  }

  export type AirlineMaxAggregateInputType = {
    airlineCode?: true
    airlineName?: true
  }

  export type AirlineCountAggregateInputType = {
    airlineCode?: true
    airlineName?: true
    _all?: true
  }

  export type AirlineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which airline to aggregate.
     */
    where?: airlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airlines to fetch.
     */
    orderBy?: airlineOrderByWithRelationInput | airlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: airlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned airlines
    **/
    _count?: true | AirlineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AirlineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AirlineMaxAggregateInputType
  }

  export type GetAirlineAggregateType<T extends AirlineAggregateArgs> = {
        [P in keyof T & keyof AggregateAirline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAirline[P]>
      : GetScalarType<T[P], AggregateAirline[P]>
  }




  export type airlineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: airlineWhereInput
    orderBy?: airlineOrderByWithAggregationInput | airlineOrderByWithAggregationInput[]
    by: AirlineScalarFieldEnum[] | AirlineScalarFieldEnum
    having?: airlineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AirlineCountAggregateInputType | true
    _min?: AirlineMinAggregateInputType
    _max?: AirlineMaxAggregateInputType
  }

  export type AirlineGroupByOutputType = {
    airlineCode: string
    airlineName: string
    _count: AirlineCountAggregateOutputType | null
    _min: AirlineMinAggregateOutputType | null
    _max: AirlineMaxAggregateOutputType | null
  }

  type GetAirlineGroupByPayload<T extends airlineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AirlineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AirlineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AirlineGroupByOutputType[P]>
            : GetScalarType<T[P], AirlineGroupByOutputType[P]>
        }
      >
    >


  export type airlineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    airlineCode?: boolean
    airlineName?: boolean
    aircraft?: boolean | airline$aircraftArgs<ExtArgs>
    aircraftCost?: boolean | airline$aircraftCostArgs<ExtArgs>
    flight?: boolean | airline$flightArgs<ExtArgs>
    _count?: boolean | AirlineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airline"]>



  export type airlineSelectScalar = {
    airlineCode?: boolean
    airlineName?: boolean
  }

  export type airlineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"airlineCode" | "airlineName", ExtArgs["result"]["airline"]>
  export type airlineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraft?: boolean | airline$aircraftArgs<ExtArgs>
    aircraftCost?: boolean | airline$aircraftCostArgs<ExtArgs>
    flight?: boolean | airline$flightArgs<ExtArgs>
    _count?: boolean | AirlineCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $airlinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "airline"
    objects: {
      aircraft: Prisma.$aircraftPayload<ExtArgs>[]
      aircraftCost: Prisma.$aircraftCostPayload<ExtArgs>[]
      flight: Prisma.$flightPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      airlineCode: string
      airlineName: string
    }, ExtArgs["result"]["airline"]>
    composites: {}
  }

  type airlineGetPayload<S extends boolean | null | undefined | airlineDefaultArgs> = $Result.GetResult<Prisma.$airlinePayload, S>

  type airlineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<airlineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AirlineCountAggregateInputType | true
    }

  export interface airlineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['airline'], meta: { name: 'airline' } }
    /**
     * Find zero or one Airline that matches the filter.
     * @param {airlineFindUniqueArgs} args - Arguments to find a Airline
     * @example
     * // Get one Airline
     * const airline = await prisma.airline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends airlineFindUniqueArgs>(args: SelectSubset<T, airlineFindUniqueArgs<ExtArgs>>): Prisma__airlineClient<$Result.GetResult<Prisma.$airlinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Airline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {airlineFindUniqueOrThrowArgs} args - Arguments to find a Airline
     * @example
     * // Get one Airline
     * const airline = await prisma.airline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends airlineFindUniqueOrThrowArgs>(args: SelectSubset<T, airlineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__airlineClient<$Result.GetResult<Prisma.$airlinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Airline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airlineFindFirstArgs} args - Arguments to find a Airline
     * @example
     * // Get one Airline
     * const airline = await prisma.airline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends airlineFindFirstArgs>(args?: SelectSubset<T, airlineFindFirstArgs<ExtArgs>>): Prisma__airlineClient<$Result.GetResult<Prisma.$airlinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Airline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airlineFindFirstOrThrowArgs} args - Arguments to find a Airline
     * @example
     * // Get one Airline
     * const airline = await prisma.airline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends airlineFindFirstOrThrowArgs>(args?: SelectSubset<T, airlineFindFirstOrThrowArgs<ExtArgs>>): Prisma__airlineClient<$Result.GetResult<Prisma.$airlinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Airlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airlineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Airlines
     * const airlines = await prisma.airline.findMany()
     * 
     * // Get first 10 Airlines
     * const airlines = await prisma.airline.findMany({ take: 10 })
     * 
     * // Only select the `airlineCode`
     * const airlineWithAirlineCodeOnly = await prisma.airline.findMany({ select: { airlineCode: true } })
     * 
     */
    findMany<T extends airlineFindManyArgs>(args?: SelectSubset<T, airlineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$airlinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Airline.
     * @param {airlineCreateArgs} args - Arguments to create a Airline.
     * @example
     * // Create one Airline
     * const Airline = await prisma.airline.create({
     *   data: {
     *     // ... data to create a Airline
     *   }
     * })
     * 
     */
    create<T extends airlineCreateArgs>(args: SelectSubset<T, airlineCreateArgs<ExtArgs>>): Prisma__airlineClient<$Result.GetResult<Prisma.$airlinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Airlines.
     * @param {airlineCreateManyArgs} args - Arguments to create many Airlines.
     * @example
     * // Create many Airlines
     * const airline = await prisma.airline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends airlineCreateManyArgs>(args?: SelectSubset<T, airlineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Airline.
     * @param {airlineDeleteArgs} args - Arguments to delete one Airline.
     * @example
     * // Delete one Airline
     * const Airline = await prisma.airline.delete({
     *   where: {
     *     // ... filter to delete one Airline
     *   }
     * })
     * 
     */
    delete<T extends airlineDeleteArgs>(args: SelectSubset<T, airlineDeleteArgs<ExtArgs>>): Prisma__airlineClient<$Result.GetResult<Prisma.$airlinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Airline.
     * @param {airlineUpdateArgs} args - Arguments to update one Airline.
     * @example
     * // Update one Airline
     * const airline = await prisma.airline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends airlineUpdateArgs>(args: SelectSubset<T, airlineUpdateArgs<ExtArgs>>): Prisma__airlineClient<$Result.GetResult<Prisma.$airlinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Airlines.
     * @param {airlineDeleteManyArgs} args - Arguments to filter Airlines to delete.
     * @example
     * // Delete a few Airlines
     * const { count } = await prisma.airline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends airlineDeleteManyArgs>(args?: SelectSubset<T, airlineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Airlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airlineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Airlines
     * const airline = await prisma.airline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends airlineUpdateManyArgs>(args: SelectSubset<T, airlineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Airline.
     * @param {airlineUpsertArgs} args - Arguments to update or create a Airline.
     * @example
     * // Update or create a Airline
     * const airline = await prisma.airline.upsert({
     *   create: {
     *     // ... data to create a Airline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Airline we want to update
     *   }
     * })
     */
    upsert<T extends airlineUpsertArgs>(args: SelectSubset<T, airlineUpsertArgs<ExtArgs>>): Prisma__airlineClient<$Result.GetResult<Prisma.$airlinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Airlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airlineCountArgs} args - Arguments to filter Airlines to count.
     * @example
     * // Count the number of Airlines
     * const count = await prisma.airline.count({
     *   where: {
     *     // ... the filter for the Airlines we want to count
     *   }
     * })
    **/
    count<T extends airlineCountArgs>(
      args?: Subset<T, airlineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AirlineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Airline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirlineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AirlineAggregateArgs>(args: Subset<T, AirlineAggregateArgs>): Prisma.PrismaPromise<GetAirlineAggregateType<T>>

    /**
     * Group by Airline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airlineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends airlineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: airlineGroupByArgs['orderBy'] }
        : { orderBy?: airlineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, airlineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAirlineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the airline model
   */
  readonly fields: airlineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for airline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__airlineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aircraft<T extends airline$aircraftArgs<ExtArgs> = {}>(args?: Subset<T, airline$aircraftArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aircraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aircraftCost<T extends airline$aircraftCostArgs<ExtArgs> = {}>(args?: Subset<T, airline$aircraftCostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aircraftCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flight<T extends airline$flightArgs<ExtArgs> = {}>(args?: Subset<T, airline$flightArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the airline model
   */
  interface airlineFieldRefs {
    readonly airlineCode: FieldRef<"airline", 'String'>
    readonly airlineName: FieldRef<"airline", 'String'>
  }
    

  // Custom InputTypes
  /**
   * airline findUnique
   */
  export type airlineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airline
     */
    select?: airlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airline
     */
    omit?: airlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airlineInclude<ExtArgs> | null
    /**
     * Filter, which airline to fetch.
     */
    where: airlineWhereUniqueInput
  }

  /**
   * airline findUniqueOrThrow
   */
  export type airlineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airline
     */
    select?: airlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airline
     */
    omit?: airlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airlineInclude<ExtArgs> | null
    /**
     * Filter, which airline to fetch.
     */
    where: airlineWhereUniqueInput
  }

  /**
   * airline findFirst
   */
  export type airlineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airline
     */
    select?: airlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airline
     */
    omit?: airlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airlineInclude<ExtArgs> | null
    /**
     * Filter, which airline to fetch.
     */
    where?: airlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airlines to fetch.
     */
    orderBy?: airlineOrderByWithRelationInput | airlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airlines.
     */
    cursor?: airlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airlines.
     */
    distinct?: AirlineScalarFieldEnum | AirlineScalarFieldEnum[]
  }

  /**
   * airline findFirstOrThrow
   */
  export type airlineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airline
     */
    select?: airlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airline
     */
    omit?: airlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airlineInclude<ExtArgs> | null
    /**
     * Filter, which airline to fetch.
     */
    where?: airlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airlines to fetch.
     */
    orderBy?: airlineOrderByWithRelationInput | airlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airlines.
     */
    cursor?: airlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airlines.
     */
    distinct?: AirlineScalarFieldEnum | AirlineScalarFieldEnum[]
  }

  /**
   * airline findMany
   */
  export type airlineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airline
     */
    select?: airlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airline
     */
    omit?: airlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airlineInclude<ExtArgs> | null
    /**
     * Filter, which airlines to fetch.
     */
    where?: airlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airlines to fetch.
     */
    orderBy?: airlineOrderByWithRelationInput | airlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing airlines.
     */
    cursor?: airlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airlines.
     */
    skip?: number
    distinct?: AirlineScalarFieldEnum | AirlineScalarFieldEnum[]
  }

  /**
   * airline create
   */
  export type airlineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airline
     */
    select?: airlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airline
     */
    omit?: airlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airlineInclude<ExtArgs> | null
    /**
     * The data needed to create a airline.
     */
    data: XOR<airlineCreateInput, airlineUncheckedCreateInput>
  }

  /**
   * airline createMany
   */
  export type airlineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many airlines.
     */
    data: airlineCreateManyInput | airlineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * airline update
   */
  export type airlineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airline
     */
    select?: airlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airline
     */
    omit?: airlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airlineInclude<ExtArgs> | null
    /**
     * The data needed to update a airline.
     */
    data: XOR<airlineUpdateInput, airlineUncheckedUpdateInput>
    /**
     * Choose, which airline to update.
     */
    where: airlineWhereUniqueInput
  }

  /**
   * airline updateMany
   */
  export type airlineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update airlines.
     */
    data: XOR<airlineUpdateManyMutationInput, airlineUncheckedUpdateManyInput>
    /**
     * Filter which airlines to update
     */
    where?: airlineWhereInput
    /**
     * Limit how many airlines to update.
     */
    limit?: number
  }

  /**
   * airline upsert
   */
  export type airlineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airline
     */
    select?: airlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airline
     */
    omit?: airlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airlineInclude<ExtArgs> | null
    /**
     * The filter to search for the airline to update in case it exists.
     */
    where: airlineWhereUniqueInput
    /**
     * In case the airline found by the `where` argument doesn't exist, create a new airline with this data.
     */
    create: XOR<airlineCreateInput, airlineUncheckedCreateInput>
    /**
     * In case the airline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<airlineUpdateInput, airlineUncheckedUpdateInput>
  }

  /**
   * airline delete
   */
  export type airlineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airline
     */
    select?: airlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airline
     */
    omit?: airlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airlineInclude<ExtArgs> | null
    /**
     * Filter which airline to delete.
     */
    where: airlineWhereUniqueInput
  }

  /**
   * airline deleteMany
   */
  export type airlineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which airlines to delete
     */
    where?: airlineWhereInput
    /**
     * Limit how many airlines to delete.
     */
    limit?: number
  }

  /**
   * airline.aircraft
   */
  export type airline$aircraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft
     */
    select?: aircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft
     */
    omit?: aircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftInclude<ExtArgs> | null
    where?: aircraftWhereInput
    orderBy?: aircraftOrderByWithRelationInput | aircraftOrderByWithRelationInput[]
    cursor?: aircraftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AircraftScalarFieldEnum | AircraftScalarFieldEnum[]
  }

  /**
   * airline.aircraftCost
   */
  export type airline$aircraftCostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraftCost
     */
    select?: aircraftCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraftCost
     */
    omit?: aircraftCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftCostInclude<ExtArgs> | null
    where?: aircraftCostWhereInput
    orderBy?: aircraftCostOrderByWithRelationInput | aircraftCostOrderByWithRelationInput[]
    cursor?: aircraftCostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AircraftCostScalarFieldEnum | AircraftCostScalarFieldEnum[]
  }

  /**
   * airline.flight
   */
  export type airline$flightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    where?: flightWhereInput
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    cursor?: flightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * airline without action
   */
  export type airlineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airline
     */
    select?: airlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airline
     */
    omit?: airlineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airlineInclude<ExtArgs> | null
  }


  /**
   * Model aircraft
   */

  export type AggregateAircraft = {
    _count: AircraftCountAggregateOutputType | null
    _min: AircraftMinAggregateOutputType | null
    _max: AircraftMaxAggregateOutputType | null
  }

  export type AircraftMinAggregateOutputType = {
    aircraftId: string | null
    ownerAirlineCode: string | null
    model: string | null
  }

  export type AircraftMaxAggregateOutputType = {
    aircraftId: string | null
    ownerAirlineCode: string | null
    model: string | null
  }

  export type AircraftCountAggregateOutputType = {
    aircraftId: number
    ownerAirlineCode: number
    model: number
    _all: number
  }


  export type AircraftMinAggregateInputType = {
    aircraftId?: true
    ownerAirlineCode?: true
    model?: true
  }

  export type AircraftMaxAggregateInputType = {
    aircraftId?: true
    ownerAirlineCode?: true
    model?: true
  }

  export type AircraftCountAggregateInputType = {
    aircraftId?: true
    ownerAirlineCode?: true
    model?: true
    _all?: true
  }

  export type AircraftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aircraft to aggregate.
     */
    where?: aircraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aircraft to fetch.
     */
    orderBy?: aircraftOrderByWithRelationInput | aircraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aircraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aircraft from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aircraft.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aircraft
    **/
    _count?: true | AircraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AircraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AircraftMaxAggregateInputType
  }

  export type GetAircraftAggregateType<T extends AircraftAggregateArgs> = {
        [P in keyof T & keyof AggregateAircraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAircraft[P]>
      : GetScalarType<T[P], AggregateAircraft[P]>
  }




  export type aircraftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aircraftWhereInput
    orderBy?: aircraftOrderByWithAggregationInput | aircraftOrderByWithAggregationInput[]
    by: AircraftScalarFieldEnum[] | AircraftScalarFieldEnum
    having?: aircraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AircraftCountAggregateInputType | true
    _min?: AircraftMinAggregateInputType
    _max?: AircraftMaxAggregateInputType
  }

  export type AircraftGroupByOutputType = {
    aircraftId: string
    ownerAirlineCode: string
    model: string
    _count: AircraftCountAggregateOutputType | null
    _min: AircraftMinAggregateOutputType | null
    _max: AircraftMaxAggregateOutputType | null
  }

  type GetAircraftGroupByPayload<T extends aircraftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AircraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AircraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AircraftGroupByOutputType[P]>
            : GetScalarType<T[P], AircraftGroupByOutputType[P]>
        }
      >
    >


  export type aircraftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    aircraftId?: boolean
    ownerAirlineCode?: boolean
    model?: boolean
    airline?: boolean | airlineDefaultArgs<ExtArgs>
    flightOperate?: boolean | aircraft$flightOperateArgs<ExtArgs>
    aircraftSeatmap?: boolean | aircraft$aircraftSeatmapArgs<ExtArgs>
    _count?: boolean | AircraftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aircraft"]>



  export type aircraftSelectScalar = {
    aircraftId?: boolean
    ownerAirlineCode?: boolean
    model?: boolean
  }

  export type aircraftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"aircraftId" | "ownerAirlineCode" | "model", ExtArgs["result"]["aircraft"]>
  export type aircraftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airline?: boolean | airlineDefaultArgs<ExtArgs>
    flightOperate?: boolean | aircraft$flightOperateArgs<ExtArgs>
    aircraftSeatmap?: boolean | aircraft$aircraftSeatmapArgs<ExtArgs>
    _count?: boolean | AircraftCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $aircraftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "aircraft"
    objects: {
      airline: Prisma.$airlinePayload<ExtArgs>
      flightOperate: Prisma.$flightOperatePayload<ExtArgs>[]
      aircraftSeatmap: Prisma.$aircraft_seatmapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      aircraftId: string
      ownerAirlineCode: string
      model: string
    }, ExtArgs["result"]["aircraft"]>
    composites: {}
  }

  type aircraftGetPayload<S extends boolean | null | undefined | aircraftDefaultArgs> = $Result.GetResult<Prisma.$aircraftPayload, S>

  type aircraftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<aircraftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AircraftCountAggregateInputType | true
    }

  export interface aircraftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['aircraft'], meta: { name: 'aircraft' } }
    /**
     * Find zero or one Aircraft that matches the filter.
     * @param {aircraftFindUniqueArgs} args - Arguments to find a Aircraft
     * @example
     * // Get one Aircraft
     * const aircraft = await prisma.aircraft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends aircraftFindUniqueArgs>(args: SelectSubset<T, aircraftFindUniqueArgs<ExtArgs>>): Prisma__aircraftClient<$Result.GetResult<Prisma.$aircraftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Aircraft that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {aircraftFindUniqueOrThrowArgs} args - Arguments to find a Aircraft
     * @example
     * // Get one Aircraft
     * const aircraft = await prisma.aircraft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends aircraftFindUniqueOrThrowArgs>(args: SelectSubset<T, aircraftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__aircraftClient<$Result.GetResult<Prisma.$aircraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aircraft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraftFindFirstArgs} args - Arguments to find a Aircraft
     * @example
     * // Get one Aircraft
     * const aircraft = await prisma.aircraft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends aircraftFindFirstArgs>(args?: SelectSubset<T, aircraftFindFirstArgs<ExtArgs>>): Prisma__aircraftClient<$Result.GetResult<Prisma.$aircraftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aircraft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraftFindFirstOrThrowArgs} args - Arguments to find a Aircraft
     * @example
     * // Get one Aircraft
     * const aircraft = await prisma.aircraft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends aircraftFindFirstOrThrowArgs>(args?: SelectSubset<T, aircraftFindFirstOrThrowArgs<ExtArgs>>): Prisma__aircraftClient<$Result.GetResult<Prisma.$aircraftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Aircraft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Aircraft
     * const aircraft = await prisma.aircraft.findMany()
     * 
     * // Get first 10 Aircraft
     * const aircraft = await prisma.aircraft.findMany({ take: 10 })
     * 
     * // Only select the `aircraftId`
     * const aircraftWithAircraftIdOnly = await prisma.aircraft.findMany({ select: { aircraftId: true } })
     * 
     */
    findMany<T extends aircraftFindManyArgs>(args?: SelectSubset<T, aircraftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aircraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Aircraft.
     * @param {aircraftCreateArgs} args - Arguments to create a Aircraft.
     * @example
     * // Create one Aircraft
     * const Aircraft = await prisma.aircraft.create({
     *   data: {
     *     // ... data to create a Aircraft
     *   }
     * })
     * 
     */
    create<T extends aircraftCreateArgs>(args: SelectSubset<T, aircraftCreateArgs<ExtArgs>>): Prisma__aircraftClient<$Result.GetResult<Prisma.$aircraftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Aircraft.
     * @param {aircraftCreateManyArgs} args - Arguments to create many Aircraft.
     * @example
     * // Create many Aircraft
     * const aircraft = await prisma.aircraft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends aircraftCreateManyArgs>(args?: SelectSubset<T, aircraftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Aircraft.
     * @param {aircraftDeleteArgs} args - Arguments to delete one Aircraft.
     * @example
     * // Delete one Aircraft
     * const Aircraft = await prisma.aircraft.delete({
     *   where: {
     *     // ... filter to delete one Aircraft
     *   }
     * })
     * 
     */
    delete<T extends aircraftDeleteArgs>(args: SelectSubset<T, aircraftDeleteArgs<ExtArgs>>): Prisma__aircraftClient<$Result.GetResult<Prisma.$aircraftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Aircraft.
     * @param {aircraftUpdateArgs} args - Arguments to update one Aircraft.
     * @example
     * // Update one Aircraft
     * const aircraft = await prisma.aircraft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends aircraftUpdateArgs>(args: SelectSubset<T, aircraftUpdateArgs<ExtArgs>>): Prisma__aircraftClient<$Result.GetResult<Prisma.$aircraftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Aircraft.
     * @param {aircraftDeleteManyArgs} args - Arguments to filter Aircraft to delete.
     * @example
     * // Delete a few Aircraft
     * const { count } = await prisma.aircraft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends aircraftDeleteManyArgs>(args?: SelectSubset<T, aircraftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aircraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Aircraft
     * const aircraft = await prisma.aircraft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends aircraftUpdateManyArgs>(args: SelectSubset<T, aircraftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Aircraft.
     * @param {aircraftUpsertArgs} args - Arguments to update or create a Aircraft.
     * @example
     * // Update or create a Aircraft
     * const aircraft = await prisma.aircraft.upsert({
     *   create: {
     *     // ... data to create a Aircraft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aircraft we want to update
     *   }
     * })
     */
    upsert<T extends aircraftUpsertArgs>(args: SelectSubset<T, aircraftUpsertArgs<ExtArgs>>): Prisma__aircraftClient<$Result.GetResult<Prisma.$aircraftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Aircraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraftCountArgs} args - Arguments to filter Aircraft to count.
     * @example
     * // Count the number of Aircraft
     * const count = await prisma.aircraft.count({
     *   where: {
     *     // ... the filter for the Aircraft we want to count
     *   }
     * })
    **/
    count<T extends aircraftCountArgs>(
      args?: Subset<T, aircraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AircraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aircraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AircraftAggregateArgs>(args: Subset<T, AircraftAggregateArgs>): Prisma.PrismaPromise<GetAircraftAggregateType<T>>

    /**
     * Group by Aircraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aircraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aircraftGroupByArgs['orderBy'] }
        : { orderBy?: aircraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aircraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAircraftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the aircraft model
   */
  readonly fields: aircraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for aircraft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__aircraftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    airline<T extends airlineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, airlineDefaultArgs<ExtArgs>>): Prisma__airlineClient<$Result.GetResult<Prisma.$airlinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    flightOperate<T extends aircraft$flightOperateArgs<ExtArgs> = {}>(args?: Subset<T, aircraft$flightOperateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aircraftSeatmap<T extends aircraft$aircraftSeatmapArgs<ExtArgs> = {}>(args?: Subset<T, aircraft$aircraftSeatmapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aircraft_seatmapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the aircraft model
   */
  interface aircraftFieldRefs {
    readonly aircraftId: FieldRef<"aircraft", 'String'>
    readonly ownerAirlineCode: FieldRef<"aircraft", 'String'>
    readonly model: FieldRef<"aircraft", 'String'>
  }
    

  // Custom InputTypes
  /**
   * aircraft findUnique
   */
  export type aircraftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft
     */
    select?: aircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft
     */
    omit?: aircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftInclude<ExtArgs> | null
    /**
     * Filter, which aircraft to fetch.
     */
    where: aircraftWhereUniqueInput
  }

  /**
   * aircraft findUniqueOrThrow
   */
  export type aircraftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft
     */
    select?: aircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft
     */
    omit?: aircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftInclude<ExtArgs> | null
    /**
     * Filter, which aircraft to fetch.
     */
    where: aircraftWhereUniqueInput
  }

  /**
   * aircraft findFirst
   */
  export type aircraftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft
     */
    select?: aircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft
     */
    omit?: aircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftInclude<ExtArgs> | null
    /**
     * Filter, which aircraft to fetch.
     */
    where?: aircraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aircraft to fetch.
     */
    orderBy?: aircraftOrderByWithRelationInput | aircraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aircraft.
     */
    cursor?: aircraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aircraft from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aircraft.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aircraft.
     */
    distinct?: AircraftScalarFieldEnum | AircraftScalarFieldEnum[]
  }

  /**
   * aircraft findFirstOrThrow
   */
  export type aircraftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft
     */
    select?: aircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft
     */
    omit?: aircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftInclude<ExtArgs> | null
    /**
     * Filter, which aircraft to fetch.
     */
    where?: aircraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aircraft to fetch.
     */
    orderBy?: aircraftOrderByWithRelationInput | aircraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aircraft.
     */
    cursor?: aircraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aircraft from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aircraft.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aircraft.
     */
    distinct?: AircraftScalarFieldEnum | AircraftScalarFieldEnum[]
  }

  /**
   * aircraft findMany
   */
  export type aircraftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft
     */
    select?: aircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft
     */
    omit?: aircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftInclude<ExtArgs> | null
    /**
     * Filter, which aircraft to fetch.
     */
    where?: aircraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aircraft to fetch.
     */
    orderBy?: aircraftOrderByWithRelationInput | aircraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aircraft.
     */
    cursor?: aircraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aircraft from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aircraft.
     */
    skip?: number
    distinct?: AircraftScalarFieldEnum | AircraftScalarFieldEnum[]
  }

  /**
   * aircraft create
   */
  export type aircraftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft
     */
    select?: aircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft
     */
    omit?: aircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftInclude<ExtArgs> | null
    /**
     * The data needed to create a aircraft.
     */
    data: XOR<aircraftCreateInput, aircraftUncheckedCreateInput>
  }

  /**
   * aircraft createMany
   */
  export type aircraftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many aircraft.
     */
    data: aircraftCreateManyInput | aircraftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aircraft update
   */
  export type aircraftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft
     */
    select?: aircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft
     */
    omit?: aircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftInclude<ExtArgs> | null
    /**
     * The data needed to update a aircraft.
     */
    data: XOR<aircraftUpdateInput, aircraftUncheckedUpdateInput>
    /**
     * Choose, which aircraft to update.
     */
    where: aircraftWhereUniqueInput
  }

  /**
   * aircraft updateMany
   */
  export type aircraftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update aircraft.
     */
    data: XOR<aircraftUpdateManyMutationInput, aircraftUncheckedUpdateManyInput>
    /**
     * Filter which aircraft to update
     */
    where?: aircraftWhereInput
    /**
     * Limit how many aircraft to update.
     */
    limit?: number
  }

  /**
   * aircraft upsert
   */
  export type aircraftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft
     */
    select?: aircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft
     */
    omit?: aircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftInclude<ExtArgs> | null
    /**
     * The filter to search for the aircraft to update in case it exists.
     */
    where: aircraftWhereUniqueInput
    /**
     * In case the aircraft found by the `where` argument doesn't exist, create a new aircraft with this data.
     */
    create: XOR<aircraftCreateInput, aircraftUncheckedCreateInput>
    /**
     * In case the aircraft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aircraftUpdateInput, aircraftUncheckedUpdateInput>
  }

  /**
   * aircraft delete
   */
  export type aircraftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft
     */
    select?: aircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft
     */
    omit?: aircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftInclude<ExtArgs> | null
    /**
     * Filter which aircraft to delete.
     */
    where: aircraftWhereUniqueInput
  }

  /**
   * aircraft deleteMany
   */
  export type aircraftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aircraft to delete
     */
    where?: aircraftWhereInput
    /**
     * Limit how many aircraft to delete.
     */
    limit?: number
  }

  /**
   * aircraft.flightOperate
   */
  export type aircraft$flightOperateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flightOperate
     */
    select?: flightOperateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flightOperate
     */
    omit?: flightOperateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightOperateInclude<ExtArgs> | null
    where?: flightOperateWhereInput
    orderBy?: flightOperateOrderByWithRelationInput | flightOperateOrderByWithRelationInput[]
    cursor?: flightOperateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightOperateScalarFieldEnum | FlightOperateScalarFieldEnum[]
  }

  /**
   * aircraft.aircraftSeatmap
   */
  export type aircraft$aircraftSeatmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft_seatmap
     */
    select?: aircraft_seatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft_seatmap
     */
    omit?: aircraft_seatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraft_seatmapInclude<ExtArgs> | null
    where?: aircraft_seatmapWhereInput
    orderBy?: aircraft_seatmapOrderByWithRelationInput | aircraft_seatmapOrderByWithRelationInput[]
    cursor?: aircraft_seatmapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Aircraft_seatmapScalarFieldEnum | Aircraft_seatmapScalarFieldEnum[]
  }

  /**
   * aircraft without action
   */
  export type aircraftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft
     */
    select?: aircraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft
     */
    omit?: aircraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftInclude<ExtArgs> | null
  }


  /**
   * Model aircraftCost
   */

  export type AggregateAircraftCost = {
    _count: AircraftCostCountAggregateOutputType | null
    _avg: AircraftCostAvgAggregateOutputType | null
    _sum: AircraftCostSumAggregateOutputType | null
    _min: AircraftCostMinAggregateOutputType | null
    _max: AircraftCostMaxAggregateOutputType | null
  }

  export type AircraftCostAvgAggregateOutputType = {
    costPerMile: number | null
  }

  export type AircraftCostSumAggregateOutputType = {
    costPerMile: number | null
  }

  export type AircraftCostMinAggregateOutputType = {
    model: string | null
    ownerAirlineCode: string | null
    costPerMile: number | null
  }

  export type AircraftCostMaxAggregateOutputType = {
    model: string | null
    ownerAirlineCode: string | null
    costPerMile: number | null
  }

  export type AircraftCostCountAggregateOutputType = {
    model: number
    ownerAirlineCode: number
    costPerMile: number
    _all: number
  }


  export type AircraftCostAvgAggregateInputType = {
    costPerMile?: true
  }

  export type AircraftCostSumAggregateInputType = {
    costPerMile?: true
  }

  export type AircraftCostMinAggregateInputType = {
    model?: true
    ownerAirlineCode?: true
    costPerMile?: true
  }

  export type AircraftCostMaxAggregateInputType = {
    model?: true
    ownerAirlineCode?: true
    costPerMile?: true
  }

  export type AircraftCostCountAggregateInputType = {
    model?: true
    ownerAirlineCode?: true
    costPerMile?: true
    _all?: true
  }

  export type AircraftCostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aircraftCost to aggregate.
     */
    where?: aircraftCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aircraftCosts to fetch.
     */
    orderBy?: aircraftCostOrderByWithRelationInput | aircraftCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aircraftCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aircraftCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aircraftCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aircraftCosts
    **/
    _count?: true | AircraftCostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AircraftCostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AircraftCostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AircraftCostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AircraftCostMaxAggregateInputType
  }

  export type GetAircraftCostAggregateType<T extends AircraftCostAggregateArgs> = {
        [P in keyof T & keyof AggregateAircraftCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAircraftCost[P]>
      : GetScalarType<T[P], AggregateAircraftCost[P]>
  }




  export type aircraftCostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aircraftCostWhereInput
    orderBy?: aircraftCostOrderByWithAggregationInput | aircraftCostOrderByWithAggregationInput[]
    by: AircraftCostScalarFieldEnum[] | AircraftCostScalarFieldEnum
    having?: aircraftCostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AircraftCostCountAggregateInputType | true
    _avg?: AircraftCostAvgAggregateInputType
    _sum?: AircraftCostSumAggregateInputType
    _min?: AircraftCostMinAggregateInputType
    _max?: AircraftCostMaxAggregateInputType
  }

  export type AircraftCostGroupByOutputType = {
    model: string
    ownerAirlineCode: string
    costPerMile: number
    _count: AircraftCostCountAggregateOutputType | null
    _avg: AircraftCostAvgAggregateOutputType | null
    _sum: AircraftCostSumAggregateOutputType | null
    _min: AircraftCostMinAggregateOutputType | null
    _max: AircraftCostMaxAggregateOutputType | null
  }

  type GetAircraftCostGroupByPayload<T extends aircraftCostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AircraftCostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AircraftCostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AircraftCostGroupByOutputType[P]>
            : GetScalarType<T[P], AircraftCostGroupByOutputType[P]>
        }
      >
    >


  export type aircraftCostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    model?: boolean
    ownerAirlineCode?: boolean
    costPerMile?: boolean
    airline?: boolean | airlineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aircraftCost"]>



  export type aircraftCostSelectScalar = {
    model?: boolean
    ownerAirlineCode?: boolean
    costPerMile?: boolean
  }

  export type aircraftCostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"model" | "ownerAirlineCode" | "costPerMile", ExtArgs["result"]["aircraftCost"]>
  export type aircraftCostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airline?: boolean | airlineDefaultArgs<ExtArgs>
  }

  export type $aircraftCostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "aircraftCost"
    objects: {
      airline: Prisma.$airlinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      model: string
      ownerAirlineCode: string
      costPerMile: number
    }, ExtArgs["result"]["aircraftCost"]>
    composites: {}
  }

  type aircraftCostGetPayload<S extends boolean | null | undefined | aircraftCostDefaultArgs> = $Result.GetResult<Prisma.$aircraftCostPayload, S>

  type aircraftCostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<aircraftCostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AircraftCostCountAggregateInputType | true
    }

  export interface aircraftCostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['aircraftCost'], meta: { name: 'aircraftCost' } }
    /**
     * Find zero or one AircraftCost that matches the filter.
     * @param {aircraftCostFindUniqueArgs} args - Arguments to find a AircraftCost
     * @example
     * // Get one AircraftCost
     * const aircraftCost = await prisma.aircraftCost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends aircraftCostFindUniqueArgs>(args: SelectSubset<T, aircraftCostFindUniqueArgs<ExtArgs>>): Prisma__aircraftCostClient<$Result.GetResult<Prisma.$aircraftCostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AircraftCost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {aircraftCostFindUniqueOrThrowArgs} args - Arguments to find a AircraftCost
     * @example
     * // Get one AircraftCost
     * const aircraftCost = await prisma.aircraftCost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends aircraftCostFindUniqueOrThrowArgs>(args: SelectSubset<T, aircraftCostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__aircraftCostClient<$Result.GetResult<Prisma.$aircraftCostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AircraftCost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraftCostFindFirstArgs} args - Arguments to find a AircraftCost
     * @example
     * // Get one AircraftCost
     * const aircraftCost = await prisma.aircraftCost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends aircraftCostFindFirstArgs>(args?: SelectSubset<T, aircraftCostFindFirstArgs<ExtArgs>>): Prisma__aircraftCostClient<$Result.GetResult<Prisma.$aircraftCostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AircraftCost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraftCostFindFirstOrThrowArgs} args - Arguments to find a AircraftCost
     * @example
     * // Get one AircraftCost
     * const aircraftCost = await prisma.aircraftCost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends aircraftCostFindFirstOrThrowArgs>(args?: SelectSubset<T, aircraftCostFindFirstOrThrowArgs<ExtArgs>>): Prisma__aircraftCostClient<$Result.GetResult<Prisma.$aircraftCostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AircraftCosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraftCostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AircraftCosts
     * const aircraftCosts = await prisma.aircraftCost.findMany()
     * 
     * // Get first 10 AircraftCosts
     * const aircraftCosts = await prisma.aircraftCost.findMany({ take: 10 })
     * 
     * // Only select the `model`
     * const aircraftCostWithModelOnly = await prisma.aircraftCost.findMany({ select: { model: true } })
     * 
     */
    findMany<T extends aircraftCostFindManyArgs>(args?: SelectSubset<T, aircraftCostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aircraftCostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AircraftCost.
     * @param {aircraftCostCreateArgs} args - Arguments to create a AircraftCost.
     * @example
     * // Create one AircraftCost
     * const AircraftCost = await prisma.aircraftCost.create({
     *   data: {
     *     // ... data to create a AircraftCost
     *   }
     * })
     * 
     */
    create<T extends aircraftCostCreateArgs>(args: SelectSubset<T, aircraftCostCreateArgs<ExtArgs>>): Prisma__aircraftCostClient<$Result.GetResult<Prisma.$aircraftCostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AircraftCosts.
     * @param {aircraftCostCreateManyArgs} args - Arguments to create many AircraftCosts.
     * @example
     * // Create many AircraftCosts
     * const aircraftCost = await prisma.aircraftCost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends aircraftCostCreateManyArgs>(args?: SelectSubset<T, aircraftCostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AircraftCost.
     * @param {aircraftCostDeleteArgs} args - Arguments to delete one AircraftCost.
     * @example
     * // Delete one AircraftCost
     * const AircraftCost = await prisma.aircraftCost.delete({
     *   where: {
     *     // ... filter to delete one AircraftCost
     *   }
     * })
     * 
     */
    delete<T extends aircraftCostDeleteArgs>(args: SelectSubset<T, aircraftCostDeleteArgs<ExtArgs>>): Prisma__aircraftCostClient<$Result.GetResult<Prisma.$aircraftCostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AircraftCost.
     * @param {aircraftCostUpdateArgs} args - Arguments to update one AircraftCost.
     * @example
     * // Update one AircraftCost
     * const aircraftCost = await prisma.aircraftCost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends aircraftCostUpdateArgs>(args: SelectSubset<T, aircraftCostUpdateArgs<ExtArgs>>): Prisma__aircraftCostClient<$Result.GetResult<Prisma.$aircraftCostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AircraftCosts.
     * @param {aircraftCostDeleteManyArgs} args - Arguments to filter AircraftCosts to delete.
     * @example
     * // Delete a few AircraftCosts
     * const { count } = await prisma.aircraftCost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends aircraftCostDeleteManyArgs>(args?: SelectSubset<T, aircraftCostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AircraftCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraftCostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AircraftCosts
     * const aircraftCost = await prisma.aircraftCost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends aircraftCostUpdateManyArgs>(args: SelectSubset<T, aircraftCostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AircraftCost.
     * @param {aircraftCostUpsertArgs} args - Arguments to update or create a AircraftCost.
     * @example
     * // Update or create a AircraftCost
     * const aircraftCost = await prisma.aircraftCost.upsert({
     *   create: {
     *     // ... data to create a AircraftCost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AircraftCost we want to update
     *   }
     * })
     */
    upsert<T extends aircraftCostUpsertArgs>(args: SelectSubset<T, aircraftCostUpsertArgs<ExtArgs>>): Prisma__aircraftCostClient<$Result.GetResult<Prisma.$aircraftCostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AircraftCosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraftCostCountArgs} args - Arguments to filter AircraftCosts to count.
     * @example
     * // Count the number of AircraftCosts
     * const count = await prisma.aircraftCost.count({
     *   where: {
     *     // ... the filter for the AircraftCosts we want to count
     *   }
     * })
    **/
    count<T extends aircraftCostCountArgs>(
      args?: Subset<T, aircraftCostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AircraftCostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AircraftCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AircraftCostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AircraftCostAggregateArgs>(args: Subset<T, AircraftCostAggregateArgs>): Prisma.PrismaPromise<GetAircraftCostAggregateType<T>>

    /**
     * Group by AircraftCost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraftCostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aircraftCostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aircraftCostGroupByArgs['orderBy'] }
        : { orderBy?: aircraftCostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aircraftCostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAircraftCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the aircraftCost model
   */
  readonly fields: aircraftCostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for aircraftCost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__aircraftCostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    airline<T extends airlineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, airlineDefaultArgs<ExtArgs>>): Prisma__airlineClient<$Result.GetResult<Prisma.$airlinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the aircraftCost model
   */
  interface aircraftCostFieldRefs {
    readonly model: FieldRef<"aircraftCost", 'String'>
    readonly ownerAirlineCode: FieldRef<"aircraftCost", 'String'>
    readonly costPerMile: FieldRef<"aircraftCost", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * aircraftCost findUnique
   */
  export type aircraftCostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraftCost
     */
    select?: aircraftCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraftCost
     */
    omit?: aircraftCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftCostInclude<ExtArgs> | null
    /**
     * Filter, which aircraftCost to fetch.
     */
    where: aircraftCostWhereUniqueInput
  }

  /**
   * aircraftCost findUniqueOrThrow
   */
  export type aircraftCostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraftCost
     */
    select?: aircraftCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraftCost
     */
    omit?: aircraftCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftCostInclude<ExtArgs> | null
    /**
     * Filter, which aircraftCost to fetch.
     */
    where: aircraftCostWhereUniqueInput
  }

  /**
   * aircraftCost findFirst
   */
  export type aircraftCostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraftCost
     */
    select?: aircraftCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraftCost
     */
    omit?: aircraftCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftCostInclude<ExtArgs> | null
    /**
     * Filter, which aircraftCost to fetch.
     */
    where?: aircraftCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aircraftCosts to fetch.
     */
    orderBy?: aircraftCostOrderByWithRelationInput | aircraftCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aircraftCosts.
     */
    cursor?: aircraftCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aircraftCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aircraftCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aircraftCosts.
     */
    distinct?: AircraftCostScalarFieldEnum | AircraftCostScalarFieldEnum[]
  }

  /**
   * aircraftCost findFirstOrThrow
   */
  export type aircraftCostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraftCost
     */
    select?: aircraftCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraftCost
     */
    omit?: aircraftCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftCostInclude<ExtArgs> | null
    /**
     * Filter, which aircraftCost to fetch.
     */
    where?: aircraftCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aircraftCosts to fetch.
     */
    orderBy?: aircraftCostOrderByWithRelationInput | aircraftCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aircraftCosts.
     */
    cursor?: aircraftCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aircraftCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aircraftCosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aircraftCosts.
     */
    distinct?: AircraftCostScalarFieldEnum | AircraftCostScalarFieldEnum[]
  }

  /**
   * aircraftCost findMany
   */
  export type aircraftCostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraftCost
     */
    select?: aircraftCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraftCost
     */
    omit?: aircraftCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftCostInclude<ExtArgs> | null
    /**
     * Filter, which aircraftCosts to fetch.
     */
    where?: aircraftCostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aircraftCosts to fetch.
     */
    orderBy?: aircraftCostOrderByWithRelationInput | aircraftCostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aircraftCosts.
     */
    cursor?: aircraftCostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aircraftCosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aircraftCosts.
     */
    skip?: number
    distinct?: AircraftCostScalarFieldEnum | AircraftCostScalarFieldEnum[]
  }

  /**
   * aircraftCost create
   */
  export type aircraftCostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraftCost
     */
    select?: aircraftCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraftCost
     */
    omit?: aircraftCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftCostInclude<ExtArgs> | null
    /**
     * The data needed to create a aircraftCost.
     */
    data: XOR<aircraftCostCreateInput, aircraftCostUncheckedCreateInput>
  }

  /**
   * aircraftCost createMany
   */
  export type aircraftCostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many aircraftCosts.
     */
    data: aircraftCostCreateManyInput | aircraftCostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aircraftCost update
   */
  export type aircraftCostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraftCost
     */
    select?: aircraftCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraftCost
     */
    omit?: aircraftCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftCostInclude<ExtArgs> | null
    /**
     * The data needed to update a aircraftCost.
     */
    data: XOR<aircraftCostUpdateInput, aircraftCostUncheckedUpdateInput>
    /**
     * Choose, which aircraftCost to update.
     */
    where: aircraftCostWhereUniqueInput
  }

  /**
   * aircraftCost updateMany
   */
  export type aircraftCostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update aircraftCosts.
     */
    data: XOR<aircraftCostUpdateManyMutationInput, aircraftCostUncheckedUpdateManyInput>
    /**
     * Filter which aircraftCosts to update
     */
    where?: aircraftCostWhereInput
    /**
     * Limit how many aircraftCosts to update.
     */
    limit?: number
  }

  /**
   * aircraftCost upsert
   */
  export type aircraftCostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraftCost
     */
    select?: aircraftCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraftCost
     */
    omit?: aircraftCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftCostInclude<ExtArgs> | null
    /**
     * The filter to search for the aircraftCost to update in case it exists.
     */
    where: aircraftCostWhereUniqueInput
    /**
     * In case the aircraftCost found by the `where` argument doesn't exist, create a new aircraftCost with this data.
     */
    create: XOR<aircraftCostCreateInput, aircraftCostUncheckedCreateInput>
    /**
     * In case the aircraftCost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aircraftCostUpdateInput, aircraftCostUncheckedUpdateInput>
  }

  /**
   * aircraftCost delete
   */
  export type aircraftCostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraftCost
     */
    select?: aircraftCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraftCost
     */
    omit?: aircraftCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftCostInclude<ExtArgs> | null
    /**
     * Filter which aircraftCost to delete.
     */
    where: aircraftCostWhereUniqueInput
  }

  /**
   * aircraftCost deleteMany
   */
  export type aircraftCostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aircraftCosts to delete
     */
    where?: aircraftCostWhereInput
    /**
     * Limit how many aircraftCosts to delete.
     */
    limit?: number
  }

  /**
   * aircraftCost without action
   */
  export type aircraftCostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraftCost
     */
    select?: aircraftCostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraftCost
     */
    omit?: aircraftCostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraftCostInclude<ExtArgs> | null
  }


  /**
   * Model airport
   */

  export type AggregateAirport = {
    _count: AirportCountAggregateOutputType | null
    _avg: AirportAvgAggregateOutputType | null
    _sum: AirportSumAggregateOutputType | null
    _min: AirportMinAggregateOutputType | null
    _max: AirportMaxAggregateOutputType | null
  }

  export type AirportAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    altitude: number | null
  }

  export type AirportSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    altitude: number | null
  }

  export type AirportMinAggregateOutputType = {
    airportCode: string | null
    name: string | null
    country: string | null
    city: string | null
    timezone: string | null
    latitude: number | null
    longitude: number | null
    altitude: number | null
  }

  export type AirportMaxAggregateOutputType = {
    airportCode: string | null
    name: string | null
    country: string | null
    city: string | null
    timezone: string | null
    latitude: number | null
    longitude: number | null
    altitude: number | null
  }

  export type AirportCountAggregateOutputType = {
    airportCode: number
    name: number
    country: number
    city: number
    timezone: number
    latitude: number
    longitude: number
    altitude: number
    _all: number
  }


  export type AirportAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    altitude?: true
  }

  export type AirportSumAggregateInputType = {
    latitude?: true
    longitude?: true
    altitude?: true
  }

  export type AirportMinAggregateInputType = {
    airportCode?: true
    name?: true
    country?: true
    city?: true
    timezone?: true
    latitude?: true
    longitude?: true
    altitude?: true
  }

  export type AirportMaxAggregateInputType = {
    airportCode?: true
    name?: true
    country?: true
    city?: true
    timezone?: true
    latitude?: true
    longitude?: true
    altitude?: true
  }

  export type AirportCountAggregateInputType = {
    airportCode?: true
    name?: true
    country?: true
    city?: true
    timezone?: true
    latitude?: true
    longitude?: true
    altitude?: true
    _all?: true
  }

  export type AirportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which airport to aggregate.
     */
    where?: airportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     */
    orderBy?: airportOrderByWithRelationInput | airportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: airportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned airports
    **/
    _count?: true | AirportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AirportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AirportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AirportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AirportMaxAggregateInputType
  }

  export type GetAirportAggregateType<T extends AirportAggregateArgs> = {
        [P in keyof T & keyof AggregateAirport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAirport[P]>
      : GetScalarType<T[P], AggregateAirport[P]>
  }




  export type airportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: airportWhereInput
    orderBy?: airportOrderByWithAggregationInput | airportOrderByWithAggregationInput[]
    by: AirportScalarFieldEnum[] | AirportScalarFieldEnum
    having?: airportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AirportCountAggregateInputType | true
    _avg?: AirportAvgAggregateInputType
    _sum?: AirportSumAggregateInputType
    _min?: AirportMinAggregateInputType
    _max?: AirportMaxAggregateInputType
  }

  export type AirportGroupByOutputType = {
    airportCode: string
    name: string
    country: string
    city: string
    timezone: string
    latitude: number | null
    longitude: number | null
    altitude: number | null
    _count: AirportCountAggregateOutputType | null
    _avg: AirportAvgAggregateOutputType | null
    _sum: AirportSumAggregateOutputType | null
    _min: AirportMinAggregateOutputType | null
    _max: AirportMaxAggregateOutputType | null
  }

  type GetAirportGroupByPayload<T extends airportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AirportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AirportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AirportGroupByOutputType[P]>
            : GetScalarType<T[P], AirportGroupByOutputType[P]>
        }
      >
    >


  export type airportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    airportCode?: boolean
    name?: boolean
    country?: boolean
    city?: boolean
    timezone?: boolean
    latitude?: boolean
    longitude?: boolean
    altitude?: boolean
    departFlights?: boolean | airport$departFlightsArgs<ExtArgs>
    arriveFlights?: boolean | airport$arriveFlightsArgs<ExtArgs>
    _count?: boolean | AirportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airport"]>



  export type airportSelectScalar = {
    airportCode?: boolean
    name?: boolean
    country?: boolean
    city?: boolean
    timezone?: boolean
    latitude?: boolean
    longitude?: boolean
    altitude?: boolean
  }

  export type airportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"airportCode" | "name" | "country" | "city" | "timezone" | "latitude" | "longitude" | "altitude", ExtArgs["result"]["airport"]>
  export type airportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departFlights?: boolean | airport$departFlightsArgs<ExtArgs>
    arriveFlights?: boolean | airport$arriveFlightsArgs<ExtArgs>
    _count?: boolean | AirportCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $airportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "airport"
    objects: {
      departFlights: Prisma.$flightPayload<ExtArgs>[]
      arriveFlights: Prisma.$flightPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      airportCode: string
      name: string
      country: string
      city: string
      timezone: string
      latitude: number | null
      longitude: number | null
      altitude: number | null
    }, ExtArgs["result"]["airport"]>
    composites: {}
  }

  type airportGetPayload<S extends boolean | null | undefined | airportDefaultArgs> = $Result.GetResult<Prisma.$airportPayload, S>

  type airportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<airportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AirportCountAggregateInputType | true
    }

  export interface airportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['airport'], meta: { name: 'airport' } }
    /**
     * Find zero or one Airport that matches the filter.
     * @param {airportFindUniqueArgs} args - Arguments to find a Airport
     * @example
     * // Get one Airport
     * const airport = await prisma.airport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends airportFindUniqueArgs>(args: SelectSubset<T, airportFindUniqueArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Airport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {airportFindUniqueOrThrowArgs} args - Arguments to find a Airport
     * @example
     * // Get one Airport
     * const airport = await prisma.airport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends airportFindUniqueOrThrowArgs>(args: SelectSubset<T, airportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Airport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportFindFirstArgs} args - Arguments to find a Airport
     * @example
     * // Get one Airport
     * const airport = await prisma.airport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends airportFindFirstArgs>(args?: SelectSubset<T, airportFindFirstArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Airport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportFindFirstOrThrowArgs} args - Arguments to find a Airport
     * @example
     * // Get one Airport
     * const airport = await prisma.airport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends airportFindFirstOrThrowArgs>(args?: SelectSubset<T, airportFindFirstOrThrowArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Airports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Airports
     * const airports = await prisma.airport.findMany()
     * 
     * // Get first 10 Airports
     * const airports = await prisma.airport.findMany({ take: 10 })
     * 
     * // Only select the `airportCode`
     * const airportWithAirportCodeOnly = await prisma.airport.findMany({ select: { airportCode: true } })
     * 
     */
    findMany<T extends airportFindManyArgs>(args?: SelectSubset<T, airportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Airport.
     * @param {airportCreateArgs} args - Arguments to create a Airport.
     * @example
     * // Create one Airport
     * const Airport = await prisma.airport.create({
     *   data: {
     *     // ... data to create a Airport
     *   }
     * })
     * 
     */
    create<T extends airportCreateArgs>(args: SelectSubset<T, airportCreateArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Airports.
     * @param {airportCreateManyArgs} args - Arguments to create many Airports.
     * @example
     * // Create many Airports
     * const airport = await prisma.airport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends airportCreateManyArgs>(args?: SelectSubset<T, airportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Airport.
     * @param {airportDeleteArgs} args - Arguments to delete one Airport.
     * @example
     * // Delete one Airport
     * const Airport = await prisma.airport.delete({
     *   where: {
     *     // ... filter to delete one Airport
     *   }
     * })
     * 
     */
    delete<T extends airportDeleteArgs>(args: SelectSubset<T, airportDeleteArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Airport.
     * @param {airportUpdateArgs} args - Arguments to update one Airport.
     * @example
     * // Update one Airport
     * const airport = await prisma.airport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends airportUpdateArgs>(args: SelectSubset<T, airportUpdateArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Airports.
     * @param {airportDeleteManyArgs} args - Arguments to filter Airports to delete.
     * @example
     * // Delete a few Airports
     * const { count } = await prisma.airport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends airportDeleteManyArgs>(args?: SelectSubset<T, airportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Airports
     * const airport = await prisma.airport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends airportUpdateManyArgs>(args: SelectSubset<T, airportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Airport.
     * @param {airportUpsertArgs} args - Arguments to update or create a Airport.
     * @example
     * // Update or create a Airport
     * const airport = await prisma.airport.upsert({
     *   create: {
     *     // ... data to create a Airport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Airport we want to update
     *   }
     * })
     */
    upsert<T extends airportUpsertArgs>(args: SelectSubset<T, airportUpsertArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportCountArgs} args - Arguments to filter Airports to count.
     * @example
     * // Count the number of Airports
     * const count = await prisma.airport.count({
     *   where: {
     *     // ... the filter for the Airports we want to count
     *   }
     * })
    **/
    count<T extends airportCountArgs>(
      args?: Subset<T, airportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AirportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Airport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AirportAggregateArgs>(args: Subset<T, AirportAggregateArgs>): Prisma.PrismaPromise<GetAirportAggregateType<T>>

    /**
     * Group by Airport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends airportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: airportGroupByArgs['orderBy'] }
        : { orderBy?: airportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, airportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAirportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the airport model
   */
  readonly fields: airportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for airport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__airportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departFlights<T extends airport$departFlightsArgs<ExtArgs> = {}>(args?: Subset<T, airport$departFlightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    arriveFlights<T extends airport$arriveFlightsArgs<ExtArgs> = {}>(args?: Subset<T, airport$arriveFlightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the airport model
   */
  interface airportFieldRefs {
    readonly airportCode: FieldRef<"airport", 'String'>
    readonly name: FieldRef<"airport", 'String'>
    readonly country: FieldRef<"airport", 'String'>
    readonly city: FieldRef<"airport", 'String'>
    readonly timezone: FieldRef<"airport", 'String'>
    readonly latitude: FieldRef<"airport", 'Float'>
    readonly longitude: FieldRef<"airport", 'Float'>
    readonly altitude: FieldRef<"airport", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * airport findUnique
   */
  export type airportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * Filter, which airport to fetch.
     */
    where: airportWhereUniqueInput
  }

  /**
   * airport findUniqueOrThrow
   */
  export type airportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * Filter, which airport to fetch.
     */
    where: airportWhereUniqueInput
  }

  /**
   * airport findFirst
   */
  export type airportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * Filter, which airport to fetch.
     */
    where?: airportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     */
    orderBy?: airportOrderByWithRelationInput | airportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airports.
     */
    cursor?: airportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airports.
     */
    distinct?: AirportScalarFieldEnum | AirportScalarFieldEnum[]
  }

  /**
   * airport findFirstOrThrow
   */
  export type airportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * Filter, which airport to fetch.
     */
    where?: airportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     */
    orderBy?: airportOrderByWithRelationInput | airportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airports.
     */
    cursor?: airportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airports.
     */
    distinct?: AirportScalarFieldEnum | AirportScalarFieldEnum[]
  }

  /**
   * airport findMany
   */
  export type airportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * Filter, which airports to fetch.
     */
    where?: airportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     */
    orderBy?: airportOrderByWithRelationInput | airportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing airports.
     */
    cursor?: airportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     */
    skip?: number
    distinct?: AirportScalarFieldEnum | AirportScalarFieldEnum[]
  }

  /**
   * airport create
   */
  export type airportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * The data needed to create a airport.
     */
    data: XOR<airportCreateInput, airportUncheckedCreateInput>
  }

  /**
   * airport createMany
   */
  export type airportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many airports.
     */
    data: airportCreateManyInput | airportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * airport update
   */
  export type airportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * The data needed to update a airport.
     */
    data: XOR<airportUpdateInput, airportUncheckedUpdateInput>
    /**
     * Choose, which airport to update.
     */
    where: airportWhereUniqueInput
  }

  /**
   * airport updateMany
   */
  export type airportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update airports.
     */
    data: XOR<airportUpdateManyMutationInput, airportUncheckedUpdateManyInput>
    /**
     * Filter which airports to update
     */
    where?: airportWhereInput
    /**
     * Limit how many airports to update.
     */
    limit?: number
  }

  /**
   * airport upsert
   */
  export type airportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * The filter to search for the airport to update in case it exists.
     */
    where: airportWhereUniqueInput
    /**
     * In case the airport found by the `where` argument doesn't exist, create a new airport with this data.
     */
    create: XOR<airportCreateInput, airportUncheckedCreateInput>
    /**
     * In case the airport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<airportUpdateInput, airportUncheckedUpdateInput>
  }

  /**
   * airport delete
   */
  export type airportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
    /**
     * Filter which airport to delete.
     */
    where: airportWhereUniqueInput
  }

  /**
   * airport deleteMany
   */
  export type airportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which airports to delete
     */
    where?: airportWhereInput
    /**
     * Limit how many airports to delete.
     */
    limit?: number
  }

  /**
   * airport.departFlights
   */
  export type airport$departFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    where?: flightWhereInput
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    cursor?: flightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * airport.arriveFlights
   */
  export type airport$arriveFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    where?: flightWhereInput
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    cursor?: flightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * airport without action
   */
  export type airportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the airport
     */
    select?: airportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the airport
     */
    omit?: airportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: airportInclude<ExtArgs> | null
  }


  /**
   * Model booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingMinAggregateOutputType = {
    bookingId: string | null
    bookingDate: Date | null
    status: $Enums.BookingStatus | null
    userId: string | null
  }

  export type BookingMaxAggregateOutputType = {
    bookingId: string | null
    bookingDate: Date | null
    status: $Enums.BookingStatus | null
    userId: string | null
  }

  export type BookingCountAggregateOutputType = {
    bookingId: number
    bookingDate: number
    status: number
    userId: number
    _all: number
  }


  export type BookingMinAggregateInputType = {
    bookingId?: true
    bookingDate?: true
    status?: true
    userId?: true
  }

  export type BookingMaxAggregateInputType = {
    bookingId?: true
    bookingDate?: true
    status?: true
    userId?: true
  }

  export type BookingCountAggregateInputType = {
    bookingId?: true
    bookingDate?: true
    status?: true
    userId?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which booking to aggregate.
     */
    where?: bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingOrderByWithRelationInput | bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type bookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingWhereInput
    orderBy?: bookingOrderByWithAggregationInput | bookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: bookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    bookingId: string
    bookingDate: Date
    status: $Enums.BookingStatus
    userId: string
    _count: BookingCountAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends bookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type bookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bookingId?: boolean
    bookingDate?: boolean
    status?: boolean
    userId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    bookingFlights?: boolean | booking$bookingFlightsArgs<ExtArgs>
    passengerBookings?: boolean | booking$passengerBookingsArgs<ExtArgs>
    tickets?: boolean | booking$ticketsArgs<ExtArgs>
    payment?: boolean | booking$paymentArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>



  export type bookingSelectScalar = {
    bookingId?: boolean
    bookingDate?: boolean
    status?: boolean
    userId?: boolean
  }

  export type bookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"bookingId" | "bookingDate" | "status" | "userId", ExtArgs["result"]["booking"]>
  export type bookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    bookingFlights?: boolean | booking$bookingFlightsArgs<ExtArgs>
    passengerBookings?: boolean | booking$passengerBookingsArgs<ExtArgs>
    tickets?: boolean | booking$ticketsArgs<ExtArgs>
    payment?: boolean | booking$paymentArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $bookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "booking"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      bookingFlights: Prisma.$booking_flightPayload<ExtArgs>[]
      passengerBookings: Prisma.$passenger_bookingPayload<ExtArgs>[]
      tickets: Prisma.$ticketPayload<ExtArgs>[]
      payment: Prisma.$paymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      bookingId: string
      bookingDate: Date
      status: $Enums.BookingStatus
      userId: string
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type bookingGetPayload<S extends boolean | null | undefined | bookingDefaultArgs> = $Result.GetResult<Prisma.$bookingPayload, S>

  type bookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface bookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['booking'], meta: { name: 'booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {bookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bookingFindUniqueArgs>(args: SelectSubset<T, bookingFindUniqueArgs<ExtArgs>>): Prisma__bookingClient<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bookingFindUniqueOrThrowArgs>(args: SelectSubset<T, bookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bookingClient<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bookingFindFirstArgs>(args?: SelectSubset<T, bookingFindFirstArgs<ExtArgs>>): Prisma__bookingClient<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bookingFindFirstOrThrowArgs>(args?: SelectSubset<T, bookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__bookingClient<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `bookingId`
     * const bookingWithBookingIdOnly = await prisma.booking.findMany({ select: { bookingId: true } })
     * 
     */
    findMany<T extends bookingFindManyArgs>(args?: SelectSubset<T, bookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {bookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends bookingCreateArgs>(args: SelectSubset<T, bookingCreateArgs<ExtArgs>>): Prisma__bookingClient<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {bookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bookingCreateManyArgs>(args?: SelectSubset<T, bookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Booking.
     * @param {bookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends bookingDeleteArgs>(args: SelectSubset<T, bookingDeleteArgs<ExtArgs>>): Prisma__bookingClient<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {bookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bookingUpdateArgs>(args: SelectSubset<T, bookingUpdateArgs<ExtArgs>>): Prisma__bookingClient<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {bookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bookingDeleteManyArgs>(args?: SelectSubset<T, bookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bookingUpdateManyArgs>(args: SelectSubset<T, bookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {bookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends bookingUpsertArgs>(args: SelectSubset<T, bookingUpsertArgs<ExtArgs>>): Prisma__bookingClient<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends bookingCountArgs>(
      args?: Subset<T, bookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bookingGroupByArgs['orderBy'] }
        : { orderBy?: bookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the booking model
   */
  readonly fields: bookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookingFlights<T extends booking$bookingFlightsArgs<ExtArgs> = {}>(args?: Subset<T, booking$bookingFlightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_flightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passengerBookings<T extends booking$passengerBookingsArgs<ExtArgs> = {}>(args?: Subset<T, booking$passengerBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passenger_bookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends booking$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, booking$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment<T extends booking$paymentArgs<ExtArgs> = {}>(args?: Subset<T, booking$paymentArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the booking model
   */
  interface bookingFieldRefs {
    readonly bookingId: FieldRef<"booking", 'String'>
    readonly bookingDate: FieldRef<"booking", 'DateTime'>
    readonly status: FieldRef<"booking", 'BookingStatus'>
    readonly userId: FieldRef<"booking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * booking findUnique
   */
  export type bookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking
     */
    select?: bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking
     */
    omit?: bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingInclude<ExtArgs> | null
    /**
     * Filter, which booking to fetch.
     */
    where: bookingWhereUniqueInput
  }

  /**
   * booking findUniqueOrThrow
   */
  export type bookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking
     */
    select?: bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking
     */
    omit?: bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingInclude<ExtArgs> | null
    /**
     * Filter, which booking to fetch.
     */
    where: bookingWhereUniqueInput
  }

  /**
   * booking findFirst
   */
  export type bookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking
     */
    select?: bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking
     */
    omit?: bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingInclude<ExtArgs> | null
    /**
     * Filter, which booking to fetch.
     */
    where?: bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingOrderByWithRelationInput | bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookings.
     */
    cursor?: bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * booking findFirstOrThrow
   */
  export type bookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking
     */
    select?: bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking
     */
    omit?: bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingInclude<ExtArgs> | null
    /**
     * Filter, which booking to fetch.
     */
    where?: bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingOrderByWithRelationInput | bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookings.
     */
    cursor?: bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * booking findMany
   */
  export type bookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking
     */
    select?: bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking
     */
    omit?: bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where?: bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingOrderByWithRelationInput | bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bookings.
     */
    cursor?: bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * booking create
   */
  export type bookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking
     */
    select?: bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking
     */
    omit?: bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingInclude<ExtArgs> | null
    /**
     * The data needed to create a booking.
     */
    data: XOR<bookingCreateInput, bookingUncheckedCreateInput>
  }

  /**
   * booking createMany
   */
  export type bookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bookings.
     */
    data: bookingCreateManyInput | bookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * booking update
   */
  export type bookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking
     */
    select?: bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking
     */
    omit?: bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingInclude<ExtArgs> | null
    /**
     * The data needed to update a booking.
     */
    data: XOR<bookingUpdateInput, bookingUncheckedUpdateInput>
    /**
     * Choose, which booking to update.
     */
    where: bookingWhereUniqueInput
  }

  /**
   * booking updateMany
   */
  export type bookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bookings.
     */
    data: XOR<bookingUpdateManyMutationInput, bookingUncheckedUpdateManyInput>
    /**
     * Filter which bookings to update
     */
    where?: bookingWhereInput
    /**
     * Limit how many bookings to update.
     */
    limit?: number
  }

  /**
   * booking upsert
   */
  export type bookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking
     */
    select?: bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking
     */
    omit?: bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingInclude<ExtArgs> | null
    /**
     * The filter to search for the booking to update in case it exists.
     */
    where: bookingWhereUniqueInput
    /**
     * In case the booking found by the `where` argument doesn't exist, create a new booking with this data.
     */
    create: XOR<bookingCreateInput, bookingUncheckedCreateInput>
    /**
     * In case the booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bookingUpdateInput, bookingUncheckedUpdateInput>
  }

  /**
   * booking delete
   */
  export type bookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking
     */
    select?: bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking
     */
    omit?: bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingInclude<ExtArgs> | null
    /**
     * Filter which booking to delete.
     */
    where: bookingWhereUniqueInput
  }

  /**
   * booking deleteMany
   */
  export type bookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookings to delete
     */
    where?: bookingWhereInput
    /**
     * Limit how many bookings to delete.
     */
    limit?: number
  }

  /**
   * booking.bookingFlights
   */
  export type booking$bookingFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_flight
     */
    select?: booking_flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_flight
     */
    omit?: booking_flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_flightInclude<ExtArgs> | null
    where?: booking_flightWhereInput
    orderBy?: booking_flightOrderByWithRelationInput | booking_flightOrderByWithRelationInput[]
    cursor?: booking_flightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Booking_flightScalarFieldEnum | Booking_flightScalarFieldEnum[]
  }

  /**
   * booking.passengerBookings
   */
  export type booking$passengerBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger_booking
     */
    select?: passenger_bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger_booking
     */
    omit?: passenger_bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passenger_bookingInclude<ExtArgs> | null
    where?: passenger_bookingWhereInput
    orderBy?: passenger_bookingOrderByWithRelationInput | passenger_bookingOrderByWithRelationInput[]
    cursor?: passenger_bookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Passenger_bookingScalarFieldEnum | Passenger_bookingScalarFieldEnum[]
  }

  /**
   * booking.tickets
   */
  export type booking$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    where?: ticketWhereInput
    orderBy?: ticketOrderByWithRelationInput | ticketOrderByWithRelationInput[]
    cursor?: ticketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * booking.payment
   */
  export type booking$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
  }

  /**
   * booking without action
   */
  export type bookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking
     */
    select?: bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking
     */
    omit?: bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingInclude<ExtArgs> | null
  }


  /**
   * Model booking_flight
   */

  export type AggregateBooking_flight = {
    _count: Booking_flightCountAggregateOutputType | null
    _min: Booking_flightMinAggregateOutputType | null
    _max: Booking_flightMaxAggregateOutputType | null
  }

  export type Booking_flightMinAggregateOutputType = {
    bookingId: string | null
    flightId: string | null
  }

  export type Booking_flightMaxAggregateOutputType = {
    bookingId: string | null
    flightId: string | null
  }

  export type Booking_flightCountAggregateOutputType = {
    bookingId: number
    flightId: number
    _all: number
  }


  export type Booking_flightMinAggregateInputType = {
    bookingId?: true
    flightId?: true
  }

  export type Booking_flightMaxAggregateInputType = {
    bookingId?: true
    flightId?: true
  }

  export type Booking_flightCountAggregateInputType = {
    bookingId?: true
    flightId?: true
    _all?: true
  }

  export type Booking_flightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which booking_flight to aggregate.
     */
    where?: booking_flightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_flights to fetch.
     */
    orderBy?: booking_flightOrderByWithRelationInput | booking_flightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: booking_flightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned booking_flights
    **/
    _count?: true | Booking_flightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Booking_flightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Booking_flightMaxAggregateInputType
  }

  export type GetBooking_flightAggregateType<T extends Booking_flightAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking_flight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking_flight[P]>
      : GetScalarType<T[P], AggregateBooking_flight[P]>
  }




  export type booking_flightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booking_flightWhereInput
    orderBy?: booking_flightOrderByWithAggregationInput | booking_flightOrderByWithAggregationInput[]
    by: Booking_flightScalarFieldEnum[] | Booking_flightScalarFieldEnum
    having?: booking_flightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Booking_flightCountAggregateInputType | true
    _min?: Booking_flightMinAggregateInputType
    _max?: Booking_flightMaxAggregateInputType
  }

  export type Booking_flightGroupByOutputType = {
    bookingId: string
    flightId: string
    _count: Booking_flightCountAggregateOutputType | null
    _min: Booking_flightMinAggregateOutputType | null
    _max: Booking_flightMaxAggregateOutputType | null
  }

  type GetBooking_flightGroupByPayload<T extends booking_flightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Booking_flightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Booking_flightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Booking_flightGroupByOutputType[P]>
            : GetScalarType<T[P], Booking_flightGroupByOutputType[P]>
        }
      >
    >


  export type booking_flightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bookingId?: boolean
    flightId?: boolean
    booking?: boolean | bookingDefaultArgs<ExtArgs>
    flight?: boolean | flightOperateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking_flight"]>



  export type booking_flightSelectScalar = {
    bookingId?: boolean
    flightId?: boolean
  }

  export type booking_flightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"bookingId" | "flightId", ExtArgs["result"]["booking_flight"]>
  export type booking_flightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingDefaultArgs<ExtArgs>
    flight?: boolean | flightOperateDefaultArgs<ExtArgs>
  }

  export type $booking_flightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "booking_flight"
    objects: {
      booking: Prisma.$bookingPayload<ExtArgs>
      flight: Prisma.$flightOperatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bookingId: string
      flightId: string
    }, ExtArgs["result"]["booking_flight"]>
    composites: {}
  }

  type booking_flightGetPayload<S extends boolean | null | undefined | booking_flightDefaultArgs> = $Result.GetResult<Prisma.$booking_flightPayload, S>

  type booking_flightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<booking_flightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Booking_flightCountAggregateInputType | true
    }

  export interface booking_flightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['booking_flight'], meta: { name: 'booking_flight' } }
    /**
     * Find zero or one Booking_flight that matches the filter.
     * @param {booking_flightFindUniqueArgs} args - Arguments to find a Booking_flight
     * @example
     * // Get one Booking_flight
     * const booking_flight = await prisma.booking_flight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends booking_flightFindUniqueArgs>(args: SelectSubset<T, booking_flightFindUniqueArgs<ExtArgs>>): Prisma__booking_flightClient<$Result.GetResult<Prisma.$booking_flightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking_flight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {booking_flightFindUniqueOrThrowArgs} args - Arguments to find a Booking_flight
     * @example
     * // Get one Booking_flight
     * const booking_flight = await prisma.booking_flight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends booking_flightFindUniqueOrThrowArgs>(args: SelectSubset<T, booking_flightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__booking_flightClient<$Result.GetResult<Prisma.$booking_flightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking_flight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_flightFindFirstArgs} args - Arguments to find a Booking_flight
     * @example
     * // Get one Booking_flight
     * const booking_flight = await prisma.booking_flight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends booking_flightFindFirstArgs>(args?: SelectSubset<T, booking_flightFindFirstArgs<ExtArgs>>): Prisma__booking_flightClient<$Result.GetResult<Prisma.$booking_flightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking_flight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_flightFindFirstOrThrowArgs} args - Arguments to find a Booking_flight
     * @example
     * // Get one Booking_flight
     * const booking_flight = await prisma.booking_flight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends booking_flightFindFirstOrThrowArgs>(args?: SelectSubset<T, booking_flightFindFirstOrThrowArgs<ExtArgs>>): Prisma__booking_flightClient<$Result.GetResult<Prisma.$booking_flightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Booking_flights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_flightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Booking_flights
     * const booking_flights = await prisma.booking_flight.findMany()
     * 
     * // Get first 10 Booking_flights
     * const booking_flights = await prisma.booking_flight.findMany({ take: 10 })
     * 
     * // Only select the `bookingId`
     * const booking_flightWithBookingIdOnly = await prisma.booking_flight.findMany({ select: { bookingId: true } })
     * 
     */
    findMany<T extends booking_flightFindManyArgs>(args?: SelectSubset<T, booking_flightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_flightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking_flight.
     * @param {booking_flightCreateArgs} args - Arguments to create a Booking_flight.
     * @example
     * // Create one Booking_flight
     * const Booking_flight = await prisma.booking_flight.create({
     *   data: {
     *     // ... data to create a Booking_flight
     *   }
     * })
     * 
     */
    create<T extends booking_flightCreateArgs>(args: SelectSubset<T, booking_flightCreateArgs<ExtArgs>>): Prisma__booking_flightClient<$Result.GetResult<Prisma.$booking_flightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Booking_flights.
     * @param {booking_flightCreateManyArgs} args - Arguments to create many Booking_flights.
     * @example
     * // Create many Booking_flights
     * const booking_flight = await prisma.booking_flight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends booking_flightCreateManyArgs>(args?: SelectSubset<T, booking_flightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Booking_flight.
     * @param {booking_flightDeleteArgs} args - Arguments to delete one Booking_flight.
     * @example
     * // Delete one Booking_flight
     * const Booking_flight = await prisma.booking_flight.delete({
     *   where: {
     *     // ... filter to delete one Booking_flight
     *   }
     * })
     * 
     */
    delete<T extends booking_flightDeleteArgs>(args: SelectSubset<T, booking_flightDeleteArgs<ExtArgs>>): Prisma__booking_flightClient<$Result.GetResult<Prisma.$booking_flightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking_flight.
     * @param {booking_flightUpdateArgs} args - Arguments to update one Booking_flight.
     * @example
     * // Update one Booking_flight
     * const booking_flight = await prisma.booking_flight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends booking_flightUpdateArgs>(args: SelectSubset<T, booking_flightUpdateArgs<ExtArgs>>): Prisma__booking_flightClient<$Result.GetResult<Prisma.$booking_flightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Booking_flights.
     * @param {booking_flightDeleteManyArgs} args - Arguments to filter Booking_flights to delete.
     * @example
     * // Delete a few Booking_flights
     * const { count } = await prisma.booking_flight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends booking_flightDeleteManyArgs>(args?: SelectSubset<T, booking_flightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Booking_flights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_flightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Booking_flights
     * const booking_flight = await prisma.booking_flight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends booking_flightUpdateManyArgs>(args: SelectSubset<T, booking_flightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking_flight.
     * @param {booking_flightUpsertArgs} args - Arguments to update or create a Booking_flight.
     * @example
     * // Update or create a Booking_flight
     * const booking_flight = await prisma.booking_flight.upsert({
     *   create: {
     *     // ... data to create a Booking_flight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking_flight we want to update
     *   }
     * })
     */
    upsert<T extends booking_flightUpsertArgs>(args: SelectSubset<T, booking_flightUpsertArgs<ExtArgs>>): Prisma__booking_flightClient<$Result.GetResult<Prisma.$booking_flightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Booking_flights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_flightCountArgs} args - Arguments to filter Booking_flights to count.
     * @example
     * // Count the number of Booking_flights
     * const count = await prisma.booking_flight.count({
     *   where: {
     *     // ... the filter for the Booking_flights we want to count
     *   }
     * })
    **/
    count<T extends booking_flightCountArgs>(
      args?: Subset<T, booking_flightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Booking_flightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking_flight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Booking_flightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Booking_flightAggregateArgs>(args: Subset<T, Booking_flightAggregateArgs>): Prisma.PrismaPromise<GetBooking_flightAggregateType<T>>

    /**
     * Group by Booking_flight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_flightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends booking_flightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: booking_flightGroupByArgs['orderBy'] }
        : { orderBy?: booking_flightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, booking_flightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBooking_flightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the booking_flight model
   */
  readonly fields: booking_flightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for booking_flight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__booking_flightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends bookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingDefaultArgs<ExtArgs>>): Prisma__bookingClient<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    flight<T extends flightOperateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, flightOperateDefaultArgs<ExtArgs>>): Prisma__flightOperateClient<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the booking_flight model
   */
  interface booking_flightFieldRefs {
    readonly bookingId: FieldRef<"booking_flight", 'String'>
    readonly flightId: FieldRef<"booking_flight", 'String'>
  }
    

  // Custom InputTypes
  /**
   * booking_flight findUnique
   */
  export type booking_flightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_flight
     */
    select?: booking_flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_flight
     */
    omit?: booking_flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_flightInclude<ExtArgs> | null
    /**
     * Filter, which booking_flight to fetch.
     */
    where: booking_flightWhereUniqueInput
  }

  /**
   * booking_flight findUniqueOrThrow
   */
  export type booking_flightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_flight
     */
    select?: booking_flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_flight
     */
    omit?: booking_flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_flightInclude<ExtArgs> | null
    /**
     * Filter, which booking_flight to fetch.
     */
    where: booking_flightWhereUniqueInput
  }

  /**
   * booking_flight findFirst
   */
  export type booking_flightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_flight
     */
    select?: booking_flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_flight
     */
    omit?: booking_flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_flightInclude<ExtArgs> | null
    /**
     * Filter, which booking_flight to fetch.
     */
    where?: booking_flightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_flights to fetch.
     */
    orderBy?: booking_flightOrderByWithRelationInput | booking_flightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for booking_flights.
     */
    cursor?: booking_flightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of booking_flights.
     */
    distinct?: Booking_flightScalarFieldEnum | Booking_flightScalarFieldEnum[]
  }

  /**
   * booking_flight findFirstOrThrow
   */
  export type booking_flightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_flight
     */
    select?: booking_flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_flight
     */
    omit?: booking_flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_flightInclude<ExtArgs> | null
    /**
     * Filter, which booking_flight to fetch.
     */
    where?: booking_flightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_flights to fetch.
     */
    orderBy?: booking_flightOrderByWithRelationInput | booking_flightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for booking_flights.
     */
    cursor?: booking_flightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of booking_flights.
     */
    distinct?: Booking_flightScalarFieldEnum | Booking_flightScalarFieldEnum[]
  }

  /**
   * booking_flight findMany
   */
  export type booking_flightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_flight
     */
    select?: booking_flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_flight
     */
    omit?: booking_flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_flightInclude<ExtArgs> | null
    /**
     * Filter, which booking_flights to fetch.
     */
    where?: booking_flightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_flights to fetch.
     */
    orderBy?: booking_flightOrderByWithRelationInput | booking_flightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing booking_flights.
     */
    cursor?: booking_flightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_flights.
     */
    skip?: number
    distinct?: Booking_flightScalarFieldEnum | Booking_flightScalarFieldEnum[]
  }

  /**
   * booking_flight create
   */
  export type booking_flightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_flight
     */
    select?: booking_flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_flight
     */
    omit?: booking_flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_flightInclude<ExtArgs> | null
    /**
     * The data needed to create a booking_flight.
     */
    data: XOR<booking_flightCreateInput, booking_flightUncheckedCreateInput>
  }

  /**
   * booking_flight createMany
   */
  export type booking_flightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many booking_flights.
     */
    data: booking_flightCreateManyInput | booking_flightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * booking_flight update
   */
  export type booking_flightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_flight
     */
    select?: booking_flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_flight
     */
    omit?: booking_flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_flightInclude<ExtArgs> | null
    /**
     * The data needed to update a booking_flight.
     */
    data: XOR<booking_flightUpdateInput, booking_flightUncheckedUpdateInput>
    /**
     * Choose, which booking_flight to update.
     */
    where: booking_flightWhereUniqueInput
  }

  /**
   * booking_flight updateMany
   */
  export type booking_flightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update booking_flights.
     */
    data: XOR<booking_flightUpdateManyMutationInput, booking_flightUncheckedUpdateManyInput>
    /**
     * Filter which booking_flights to update
     */
    where?: booking_flightWhereInput
    /**
     * Limit how many booking_flights to update.
     */
    limit?: number
  }

  /**
   * booking_flight upsert
   */
  export type booking_flightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_flight
     */
    select?: booking_flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_flight
     */
    omit?: booking_flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_flightInclude<ExtArgs> | null
    /**
     * The filter to search for the booking_flight to update in case it exists.
     */
    where: booking_flightWhereUniqueInput
    /**
     * In case the booking_flight found by the `where` argument doesn't exist, create a new booking_flight with this data.
     */
    create: XOR<booking_flightCreateInput, booking_flightUncheckedCreateInput>
    /**
     * In case the booking_flight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<booking_flightUpdateInput, booking_flightUncheckedUpdateInput>
  }

  /**
   * booking_flight delete
   */
  export type booking_flightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_flight
     */
    select?: booking_flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_flight
     */
    omit?: booking_flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_flightInclude<ExtArgs> | null
    /**
     * Filter which booking_flight to delete.
     */
    where: booking_flightWhereUniqueInput
  }

  /**
   * booking_flight deleteMany
   */
  export type booking_flightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which booking_flights to delete
     */
    where?: booking_flightWhereInput
    /**
     * Limit how many booking_flights to delete.
     */
    limit?: number
  }

  /**
   * booking_flight without action
   */
  export type booking_flightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_flight
     */
    select?: booking_flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_flight
     */
    omit?: booking_flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_flightInclude<ExtArgs> | null
  }


  /**
   * Model flight
   */

  export type AggregateFlight = {
    _count: FlightCountAggregateOutputType | null
    _min: FlightMinAggregateOutputType | null
    _max: FlightMaxAggregateOutputType | null
  }

  export type FlightMinAggregateOutputType = {
    flightNum: string | null
    airlineCode: string | null
    departAirportId: string | null
    arriveAirportId: string | null
  }

  export type FlightMaxAggregateOutputType = {
    flightNum: string | null
    airlineCode: string | null
    departAirportId: string | null
    arriveAirportId: string | null
  }

  export type FlightCountAggregateOutputType = {
    flightNum: number
    airlineCode: number
    departAirportId: number
    arriveAirportId: number
    _all: number
  }


  export type FlightMinAggregateInputType = {
    flightNum?: true
    airlineCode?: true
    departAirportId?: true
    arriveAirportId?: true
  }

  export type FlightMaxAggregateInputType = {
    flightNum?: true
    airlineCode?: true
    departAirportId?: true
    arriveAirportId?: true
  }

  export type FlightCountAggregateInputType = {
    flightNum?: true
    airlineCode?: true
    departAirportId?: true
    arriveAirportId?: true
    _all?: true
  }

  export type FlightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flight to aggregate.
     */
    where?: flightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flights to fetch.
     */
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: flightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned flights
    **/
    _count?: true | FlightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlightMaxAggregateInputType
  }

  export type GetFlightAggregateType<T extends FlightAggregateArgs> = {
        [P in keyof T & keyof AggregateFlight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlight[P]>
      : GetScalarType<T[P], AggregateFlight[P]>
  }




  export type flightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flightWhereInput
    orderBy?: flightOrderByWithAggregationInput | flightOrderByWithAggregationInput[]
    by: FlightScalarFieldEnum[] | FlightScalarFieldEnum
    having?: flightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlightCountAggregateInputType | true
    _min?: FlightMinAggregateInputType
    _max?: FlightMaxAggregateInputType
  }

  export type FlightGroupByOutputType = {
    flightNum: string
    airlineCode: string
    departAirportId: string
    arriveAirportId: string
    _count: FlightCountAggregateOutputType | null
    _min: FlightMinAggregateOutputType | null
    _max: FlightMaxAggregateOutputType | null
  }

  type GetFlightGroupByPayload<T extends flightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlightGroupByOutputType[P]>
            : GetScalarType<T[P], FlightGroupByOutputType[P]>
        }
      >
    >


  export type flightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    flightNum?: boolean
    airlineCode?: boolean
    departAirportId?: boolean
    arriveAirportId?: boolean
    airline?: boolean | airlineDefaultArgs<ExtArgs>
    departAirport?: boolean | airportDefaultArgs<ExtArgs>
    arriveAirport?: boolean | airportDefaultArgs<ExtArgs>
    flightOperates?: boolean | flight$flightOperatesArgs<ExtArgs>
    transitFrom?: boolean | flight$transitFromArgs<ExtArgs>
    transitTo?: boolean | flight$transitToArgs<ExtArgs>
    _count?: boolean | FlightCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flight"]>



  export type flightSelectScalar = {
    flightNum?: boolean
    airlineCode?: boolean
    departAirportId?: boolean
    arriveAirportId?: boolean
  }

  export type flightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"flightNum" | "airlineCode" | "departAirportId" | "arriveAirportId", ExtArgs["result"]["flight"]>
  export type flightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    airline?: boolean | airlineDefaultArgs<ExtArgs>
    departAirport?: boolean | airportDefaultArgs<ExtArgs>
    arriveAirport?: boolean | airportDefaultArgs<ExtArgs>
    flightOperates?: boolean | flight$flightOperatesArgs<ExtArgs>
    transitFrom?: boolean | flight$transitFromArgs<ExtArgs>
    transitTo?: boolean | flight$transitToArgs<ExtArgs>
    _count?: boolean | FlightCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $flightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "flight"
    objects: {
      airline: Prisma.$airlinePayload<ExtArgs>
      departAirport: Prisma.$airportPayload<ExtArgs>
      arriveAirport: Prisma.$airportPayload<ExtArgs>
      flightOperates: Prisma.$flightOperatePayload<ExtArgs>[]
      transitFrom: Prisma.$transitPayload<ExtArgs>[]
      transitTo: Prisma.$transitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      flightNum: string
      airlineCode: string
      departAirportId: string
      arriveAirportId: string
    }, ExtArgs["result"]["flight"]>
    composites: {}
  }

  type flightGetPayload<S extends boolean | null | undefined | flightDefaultArgs> = $Result.GetResult<Prisma.$flightPayload, S>

  type flightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<flightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlightCountAggregateInputType | true
    }

  export interface flightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['flight'], meta: { name: 'flight' } }
    /**
     * Find zero or one Flight that matches the filter.
     * @param {flightFindUniqueArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends flightFindUniqueArgs>(args: SelectSubset<T, flightFindUniqueArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Flight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {flightFindUniqueOrThrowArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends flightFindUniqueOrThrowArgs>(args: SelectSubset<T, flightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightFindFirstArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends flightFindFirstArgs>(args?: SelectSubset<T, flightFindFirstArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightFindFirstOrThrowArgs} args - Arguments to find a Flight
     * @example
     * // Get one Flight
     * const flight = await prisma.flight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends flightFindFirstOrThrowArgs>(args?: SelectSubset<T, flightFindFirstOrThrowArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Flights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flights
     * const flights = await prisma.flight.findMany()
     * 
     * // Get first 10 Flights
     * const flights = await prisma.flight.findMany({ take: 10 })
     * 
     * // Only select the `flightNum`
     * const flightWithFlightNumOnly = await prisma.flight.findMany({ select: { flightNum: true } })
     * 
     */
    findMany<T extends flightFindManyArgs>(args?: SelectSubset<T, flightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Flight.
     * @param {flightCreateArgs} args - Arguments to create a Flight.
     * @example
     * // Create one Flight
     * const Flight = await prisma.flight.create({
     *   data: {
     *     // ... data to create a Flight
     *   }
     * })
     * 
     */
    create<T extends flightCreateArgs>(args: SelectSubset<T, flightCreateArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Flights.
     * @param {flightCreateManyArgs} args - Arguments to create many Flights.
     * @example
     * // Create many Flights
     * const flight = await prisma.flight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends flightCreateManyArgs>(args?: SelectSubset<T, flightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Flight.
     * @param {flightDeleteArgs} args - Arguments to delete one Flight.
     * @example
     * // Delete one Flight
     * const Flight = await prisma.flight.delete({
     *   where: {
     *     // ... filter to delete one Flight
     *   }
     * })
     * 
     */
    delete<T extends flightDeleteArgs>(args: SelectSubset<T, flightDeleteArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Flight.
     * @param {flightUpdateArgs} args - Arguments to update one Flight.
     * @example
     * // Update one Flight
     * const flight = await prisma.flight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends flightUpdateArgs>(args: SelectSubset<T, flightUpdateArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Flights.
     * @param {flightDeleteManyArgs} args - Arguments to filter Flights to delete.
     * @example
     * // Delete a few Flights
     * const { count } = await prisma.flight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends flightDeleteManyArgs>(args?: SelectSubset<T, flightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flights
     * const flight = await prisma.flight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends flightUpdateManyArgs>(args: SelectSubset<T, flightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Flight.
     * @param {flightUpsertArgs} args - Arguments to update or create a Flight.
     * @example
     * // Update or create a Flight
     * const flight = await prisma.flight.upsert({
     *   create: {
     *     // ... data to create a Flight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flight we want to update
     *   }
     * })
     */
    upsert<T extends flightUpsertArgs>(args: SelectSubset<T, flightUpsertArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Flights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightCountArgs} args - Arguments to filter Flights to count.
     * @example
     * // Count the number of Flights
     * const count = await prisma.flight.count({
     *   where: {
     *     // ... the filter for the Flights we want to count
     *   }
     * })
    **/
    count<T extends flightCountArgs>(
      args?: Subset<T, flightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlightAggregateArgs>(args: Subset<T, FlightAggregateArgs>): Prisma.PrismaPromise<GetFlightAggregateType<T>>

    /**
     * Group by Flight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends flightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: flightGroupByArgs['orderBy'] }
        : { orderBy?: flightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, flightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the flight model
   */
  readonly fields: flightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for flight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__flightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    airline<T extends airlineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, airlineDefaultArgs<ExtArgs>>): Prisma__airlineClient<$Result.GetResult<Prisma.$airlinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    departAirport<T extends airportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, airportDefaultArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    arriveAirport<T extends airportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, airportDefaultArgs<ExtArgs>>): Prisma__airportClient<$Result.GetResult<Prisma.$airportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    flightOperates<T extends flight$flightOperatesArgs<ExtArgs> = {}>(args?: Subset<T, flight$flightOperatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transitFrom<T extends flight$transitFromArgs<ExtArgs> = {}>(args?: Subset<T, flight$transitFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transitTo<T extends flight$transitToArgs<ExtArgs> = {}>(args?: Subset<T, flight$transitToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the flight model
   */
  interface flightFieldRefs {
    readonly flightNum: FieldRef<"flight", 'String'>
    readonly airlineCode: FieldRef<"flight", 'String'>
    readonly departAirportId: FieldRef<"flight", 'String'>
    readonly arriveAirportId: FieldRef<"flight", 'String'>
  }
    

  // Custom InputTypes
  /**
   * flight findUnique
   */
  export type flightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * Filter, which flight to fetch.
     */
    where: flightWhereUniqueInput
  }

  /**
   * flight findUniqueOrThrow
   */
  export type flightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * Filter, which flight to fetch.
     */
    where: flightWhereUniqueInput
  }

  /**
   * flight findFirst
   */
  export type flightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * Filter, which flight to fetch.
     */
    where?: flightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flights to fetch.
     */
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flights.
     */
    cursor?: flightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flights.
     */
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * flight findFirstOrThrow
   */
  export type flightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * Filter, which flight to fetch.
     */
    where?: flightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flights to fetch.
     */
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flights.
     */
    cursor?: flightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flights.
     */
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * flight findMany
   */
  export type flightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * Filter, which flights to fetch.
     */
    where?: flightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flights to fetch.
     */
    orderBy?: flightOrderByWithRelationInput | flightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing flights.
     */
    cursor?: flightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flights.
     */
    skip?: number
    distinct?: FlightScalarFieldEnum | FlightScalarFieldEnum[]
  }

  /**
   * flight create
   */
  export type flightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * The data needed to create a flight.
     */
    data: XOR<flightCreateInput, flightUncheckedCreateInput>
  }

  /**
   * flight createMany
   */
  export type flightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many flights.
     */
    data: flightCreateManyInput | flightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * flight update
   */
  export type flightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * The data needed to update a flight.
     */
    data: XOR<flightUpdateInput, flightUncheckedUpdateInput>
    /**
     * Choose, which flight to update.
     */
    where: flightWhereUniqueInput
  }

  /**
   * flight updateMany
   */
  export type flightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update flights.
     */
    data: XOR<flightUpdateManyMutationInput, flightUncheckedUpdateManyInput>
    /**
     * Filter which flights to update
     */
    where?: flightWhereInput
    /**
     * Limit how many flights to update.
     */
    limit?: number
  }

  /**
   * flight upsert
   */
  export type flightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * The filter to search for the flight to update in case it exists.
     */
    where: flightWhereUniqueInput
    /**
     * In case the flight found by the `where` argument doesn't exist, create a new flight with this data.
     */
    create: XOR<flightCreateInput, flightUncheckedCreateInput>
    /**
     * In case the flight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<flightUpdateInput, flightUncheckedUpdateInput>
  }

  /**
   * flight delete
   */
  export type flightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
    /**
     * Filter which flight to delete.
     */
    where: flightWhereUniqueInput
  }

  /**
   * flight deleteMany
   */
  export type flightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flights to delete
     */
    where?: flightWhereInput
    /**
     * Limit how many flights to delete.
     */
    limit?: number
  }

  /**
   * flight.flightOperates
   */
  export type flight$flightOperatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flightOperate
     */
    select?: flightOperateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flightOperate
     */
    omit?: flightOperateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightOperateInclude<ExtArgs> | null
    where?: flightOperateWhereInput
    orderBy?: flightOperateOrderByWithRelationInput | flightOperateOrderByWithRelationInput[]
    cursor?: flightOperateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightOperateScalarFieldEnum | FlightOperateScalarFieldEnum[]
  }

  /**
   * flight.transitFrom
   */
  export type flight$transitFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transit
     */
    select?: transitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transit
     */
    omit?: transitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transitInclude<ExtArgs> | null
    where?: transitWhereInput
    orderBy?: transitOrderByWithRelationInput | transitOrderByWithRelationInput[]
    cursor?: transitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransitScalarFieldEnum | TransitScalarFieldEnum[]
  }

  /**
   * flight.transitTo
   */
  export type flight$transitToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transit
     */
    select?: transitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transit
     */
    omit?: transitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transitInclude<ExtArgs> | null
    where?: transitWhereInput
    orderBy?: transitOrderByWithRelationInput | transitOrderByWithRelationInput[]
    cursor?: transitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransitScalarFieldEnum | TransitScalarFieldEnum[]
  }

  /**
   * flight without action
   */
  export type flightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flight
     */
    select?: flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flight
     */
    omit?: flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightInclude<ExtArgs> | null
  }


  /**
   * Model flightOperate
   */

  export type AggregateFlightOperate = {
    _count: FlightOperateCountAggregateOutputType | null
    _min: FlightOperateMinAggregateOutputType | null
    _max: FlightOperateMaxAggregateOutputType | null
  }

  export type FlightOperateMinAggregateOutputType = {
    flightId: string | null
    flightNum: string | null
    airlineCode: string | null
    departureTime: Date | null
    arrivalTime: Date | null
    departureGate: string | null
    aircraftId: string | null
  }

  export type FlightOperateMaxAggregateOutputType = {
    flightId: string | null
    flightNum: string | null
    airlineCode: string | null
    departureTime: Date | null
    arrivalTime: Date | null
    departureGate: string | null
    aircraftId: string | null
  }

  export type FlightOperateCountAggregateOutputType = {
    flightId: number
    flightNum: number
    airlineCode: number
    departureTime: number
    arrivalTime: number
    departureGate: number
    aircraftId: number
    _all: number
  }


  export type FlightOperateMinAggregateInputType = {
    flightId?: true
    flightNum?: true
    airlineCode?: true
    departureTime?: true
    arrivalTime?: true
    departureGate?: true
    aircraftId?: true
  }

  export type FlightOperateMaxAggregateInputType = {
    flightId?: true
    flightNum?: true
    airlineCode?: true
    departureTime?: true
    arrivalTime?: true
    departureGate?: true
    aircraftId?: true
  }

  export type FlightOperateCountAggregateInputType = {
    flightId?: true
    flightNum?: true
    airlineCode?: true
    departureTime?: true
    arrivalTime?: true
    departureGate?: true
    aircraftId?: true
    _all?: true
  }

  export type FlightOperateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flightOperate to aggregate.
     */
    where?: flightOperateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flightOperates to fetch.
     */
    orderBy?: flightOperateOrderByWithRelationInput | flightOperateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: flightOperateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flightOperates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flightOperates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned flightOperates
    **/
    _count?: true | FlightOperateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlightOperateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlightOperateMaxAggregateInputType
  }

  export type GetFlightOperateAggregateType<T extends FlightOperateAggregateArgs> = {
        [P in keyof T & keyof AggregateFlightOperate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlightOperate[P]>
      : GetScalarType<T[P], AggregateFlightOperate[P]>
  }




  export type flightOperateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: flightOperateWhereInput
    orderBy?: flightOperateOrderByWithAggregationInput | flightOperateOrderByWithAggregationInput[]
    by: FlightOperateScalarFieldEnum[] | FlightOperateScalarFieldEnum
    having?: flightOperateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlightOperateCountAggregateInputType | true
    _min?: FlightOperateMinAggregateInputType
    _max?: FlightOperateMaxAggregateInputType
  }

  export type FlightOperateGroupByOutputType = {
    flightId: string
    flightNum: string
    airlineCode: string
    departureTime: Date
    arrivalTime: Date
    departureGate: string
    aircraftId: string
    _count: FlightOperateCountAggregateOutputType | null
    _min: FlightOperateMinAggregateOutputType | null
    _max: FlightOperateMaxAggregateOutputType | null
  }

  type GetFlightOperateGroupByPayload<T extends flightOperateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlightOperateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlightOperateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlightOperateGroupByOutputType[P]>
            : GetScalarType<T[P], FlightOperateGroupByOutputType[P]>
        }
      >
    >


  export type flightOperateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    flightId?: boolean
    flightNum?: boolean
    airlineCode?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    departureGate?: boolean
    aircraftId?: boolean
    aircraft?: boolean | aircraftDefaultArgs<ExtArgs>
    flight?: boolean | flightDefaultArgs<ExtArgs>
    bookingFlights?: boolean | flightOperate$bookingFlightsArgs<ExtArgs>
    tickets?: boolean | flightOperate$ticketsArgs<ExtArgs>
    _count?: boolean | FlightOperateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flightOperate"]>



  export type flightOperateSelectScalar = {
    flightId?: boolean
    flightNum?: boolean
    airlineCode?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    departureGate?: boolean
    aircraftId?: boolean
  }

  export type flightOperateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"flightId" | "flightNum" | "airlineCode" | "departureTime" | "arrivalTime" | "departureGate" | "aircraftId", ExtArgs["result"]["flightOperate"]>
  export type flightOperateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraft?: boolean | aircraftDefaultArgs<ExtArgs>
    flight?: boolean | flightDefaultArgs<ExtArgs>
    bookingFlights?: boolean | flightOperate$bookingFlightsArgs<ExtArgs>
    tickets?: boolean | flightOperate$ticketsArgs<ExtArgs>
    _count?: boolean | FlightOperateCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $flightOperatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "flightOperate"
    objects: {
      aircraft: Prisma.$aircraftPayload<ExtArgs>
      flight: Prisma.$flightPayload<ExtArgs>
      bookingFlights: Prisma.$booking_flightPayload<ExtArgs>[]
      tickets: Prisma.$ticketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      flightId: string
      flightNum: string
      airlineCode: string
      departureTime: Date
      arrivalTime: Date
      departureGate: string
      aircraftId: string
    }, ExtArgs["result"]["flightOperate"]>
    composites: {}
  }

  type flightOperateGetPayload<S extends boolean | null | undefined | flightOperateDefaultArgs> = $Result.GetResult<Prisma.$flightOperatePayload, S>

  type flightOperateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<flightOperateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlightOperateCountAggregateInputType | true
    }

  export interface flightOperateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['flightOperate'], meta: { name: 'flightOperate' } }
    /**
     * Find zero or one FlightOperate that matches the filter.
     * @param {flightOperateFindUniqueArgs} args - Arguments to find a FlightOperate
     * @example
     * // Get one FlightOperate
     * const flightOperate = await prisma.flightOperate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends flightOperateFindUniqueArgs>(args: SelectSubset<T, flightOperateFindUniqueArgs<ExtArgs>>): Prisma__flightOperateClient<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FlightOperate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {flightOperateFindUniqueOrThrowArgs} args - Arguments to find a FlightOperate
     * @example
     * // Get one FlightOperate
     * const flightOperate = await prisma.flightOperate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends flightOperateFindUniqueOrThrowArgs>(args: SelectSubset<T, flightOperateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__flightOperateClient<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlightOperate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightOperateFindFirstArgs} args - Arguments to find a FlightOperate
     * @example
     * // Get one FlightOperate
     * const flightOperate = await prisma.flightOperate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends flightOperateFindFirstArgs>(args?: SelectSubset<T, flightOperateFindFirstArgs<ExtArgs>>): Prisma__flightOperateClient<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FlightOperate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightOperateFindFirstOrThrowArgs} args - Arguments to find a FlightOperate
     * @example
     * // Get one FlightOperate
     * const flightOperate = await prisma.flightOperate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends flightOperateFindFirstOrThrowArgs>(args?: SelectSubset<T, flightOperateFindFirstOrThrowArgs<ExtArgs>>): Prisma__flightOperateClient<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FlightOperates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightOperateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlightOperates
     * const flightOperates = await prisma.flightOperate.findMany()
     * 
     * // Get first 10 FlightOperates
     * const flightOperates = await prisma.flightOperate.findMany({ take: 10 })
     * 
     * // Only select the `flightId`
     * const flightOperateWithFlightIdOnly = await prisma.flightOperate.findMany({ select: { flightId: true } })
     * 
     */
    findMany<T extends flightOperateFindManyArgs>(args?: SelectSubset<T, flightOperateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FlightOperate.
     * @param {flightOperateCreateArgs} args - Arguments to create a FlightOperate.
     * @example
     * // Create one FlightOperate
     * const FlightOperate = await prisma.flightOperate.create({
     *   data: {
     *     // ... data to create a FlightOperate
     *   }
     * })
     * 
     */
    create<T extends flightOperateCreateArgs>(args: SelectSubset<T, flightOperateCreateArgs<ExtArgs>>): Prisma__flightOperateClient<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FlightOperates.
     * @param {flightOperateCreateManyArgs} args - Arguments to create many FlightOperates.
     * @example
     * // Create many FlightOperates
     * const flightOperate = await prisma.flightOperate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends flightOperateCreateManyArgs>(args?: SelectSubset<T, flightOperateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FlightOperate.
     * @param {flightOperateDeleteArgs} args - Arguments to delete one FlightOperate.
     * @example
     * // Delete one FlightOperate
     * const FlightOperate = await prisma.flightOperate.delete({
     *   where: {
     *     // ... filter to delete one FlightOperate
     *   }
     * })
     * 
     */
    delete<T extends flightOperateDeleteArgs>(args: SelectSubset<T, flightOperateDeleteArgs<ExtArgs>>): Prisma__flightOperateClient<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FlightOperate.
     * @param {flightOperateUpdateArgs} args - Arguments to update one FlightOperate.
     * @example
     * // Update one FlightOperate
     * const flightOperate = await prisma.flightOperate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends flightOperateUpdateArgs>(args: SelectSubset<T, flightOperateUpdateArgs<ExtArgs>>): Prisma__flightOperateClient<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FlightOperates.
     * @param {flightOperateDeleteManyArgs} args - Arguments to filter FlightOperates to delete.
     * @example
     * // Delete a few FlightOperates
     * const { count } = await prisma.flightOperate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends flightOperateDeleteManyArgs>(args?: SelectSubset<T, flightOperateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlightOperates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightOperateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlightOperates
     * const flightOperate = await prisma.flightOperate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends flightOperateUpdateManyArgs>(args: SelectSubset<T, flightOperateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FlightOperate.
     * @param {flightOperateUpsertArgs} args - Arguments to update or create a FlightOperate.
     * @example
     * // Update or create a FlightOperate
     * const flightOperate = await prisma.flightOperate.upsert({
     *   create: {
     *     // ... data to create a FlightOperate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlightOperate we want to update
     *   }
     * })
     */
    upsert<T extends flightOperateUpsertArgs>(args: SelectSubset<T, flightOperateUpsertArgs<ExtArgs>>): Prisma__flightOperateClient<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FlightOperates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightOperateCountArgs} args - Arguments to filter FlightOperates to count.
     * @example
     * // Count the number of FlightOperates
     * const count = await prisma.flightOperate.count({
     *   where: {
     *     // ... the filter for the FlightOperates we want to count
     *   }
     * })
    **/
    count<T extends flightOperateCountArgs>(
      args?: Subset<T, flightOperateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlightOperateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlightOperate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightOperateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlightOperateAggregateArgs>(args: Subset<T, FlightOperateAggregateArgs>): Prisma.PrismaPromise<GetFlightOperateAggregateType<T>>

    /**
     * Group by FlightOperate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flightOperateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends flightOperateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: flightOperateGroupByArgs['orderBy'] }
        : { orderBy?: flightOperateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, flightOperateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlightOperateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the flightOperate model
   */
  readonly fields: flightOperateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for flightOperate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__flightOperateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aircraft<T extends aircraftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, aircraftDefaultArgs<ExtArgs>>): Prisma__aircraftClient<$Result.GetResult<Prisma.$aircraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    flight<T extends flightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, flightDefaultArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookingFlights<T extends flightOperate$bookingFlightsArgs<ExtArgs> = {}>(args?: Subset<T, flightOperate$bookingFlightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_flightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends flightOperate$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, flightOperate$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the flightOperate model
   */
  interface flightOperateFieldRefs {
    readonly flightId: FieldRef<"flightOperate", 'String'>
    readonly flightNum: FieldRef<"flightOperate", 'String'>
    readonly airlineCode: FieldRef<"flightOperate", 'String'>
    readonly departureTime: FieldRef<"flightOperate", 'DateTime'>
    readonly arrivalTime: FieldRef<"flightOperate", 'DateTime'>
    readonly departureGate: FieldRef<"flightOperate", 'String'>
    readonly aircraftId: FieldRef<"flightOperate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * flightOperate findUnique
   */
  export type flightOperateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flightOperate
     */
    select?: flightOperateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flightOperate
     */
    omit?: flightOperateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightOperateInclude<ExtArgs> | null
    /**
     * Filter, which flightOperate to fetch.
     */
    where: flightOperateWhereUniqueInput
  }

  /**
   * flightOperate findUniqueOrThrow
   */
  export type flightOperateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flightOperate
     */
    select?: flightOperateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flightOperate
     */
    omit?: flightOperateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightOperateInclude<ExtArgs> | null
    /**
     * Filter, which flightOperate to fetch.
     */
    where: flightOperateWhereUniqueInput
  }

  /**
   * flightOperate findFirst
   */
  export type flightOperateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flightOperate
     */
    select?: flightOperateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flightOperate
     */
    omit?: flightOperateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightOperateInclude<ExtArgs> | null
    /**
     * Filter, which flightOperate to fetch.
     */
    where?: flightOperateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flightOperates to fetch.
     */
    orderBy?: flightOperateOrderByWithRelationInput | flightOperateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flightOperates.
     */
    cursor?: flightOperateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flightOperates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flightOperates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flightOperates.
     */
    distinct?: FlightOperateScalarFieldEnum | FlightOperateScalarFieldEnum[]
  }

  /**
   * flightOperate findFirstOrThrow
   */
  export type flightOperateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flightOperate
     */
    select?: flightOperateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flightOperate
     */
    omit?: flightOperateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightOperateInclude<ExtArgs> | null
    /**
     * Filter, which flightOperate to fetch.
     */
    where?: flightOperateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flightOperates to fetch.
     */
    orderBy?: flightOperateOrderByWithRelationInput | flightOperateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flightOperates.
     */
    cursor?: flightOperateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flightOperates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flightOperates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flightOperates.
     */
    distinct?: FlightOperateScalarFieldEnum | FlightOperateScalarFieldEnum[]
  }

  /**
   * flightOperate findMany
   */
  export type flightOperateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flightOperate
     */
    select?: flightOperateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flightOperate
     */
    omit?: flightOperateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightOperateInclude<ExtArgs> | null
    /**
     * Filter, which flightOperates to fetch.
     */
    where?: flightOperateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flightOperates to fetch.
     */
    orderBy?: flightOperateOrderByWithRelationInput | flightOperateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing flightOperates.
     */
    cursor?: flightOperateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flightOperates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flightOperates.
     */
    skip?: number
    distinct?: FlightOperateScalarFieldEnum | FlightOperateScalarFieldEnum[]
  }

  /**
   * flightOperate create
   */
  export type flightOperateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flightOperate
     */
    select?: flightOperateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flightOperate
     */
    omit?: flightOperateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightOperateInclude<ExtArgs> | null
    /**
     * The data needed to create a flightOperate.
     */
    data: XOR<flightOperateCreateInput, flightOperateUncheckedCreateInput>
  }

  /**
   * flightOperate createMany
   */
  export type flightOperateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many flightOperates.
     */
    data: flightOperateCreateManyInput | flightOperateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * flightOperate update
   */
  export type flightOperateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flightOperate
     */
    select?: flightOperateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flightOperate
     */
    omit?: flightOperateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightOperateInclude<ExtArgs> | null
    /**
     * The data needed to update a flightOperate.
     */
    data: XOR<flightOperateUpdateInput, flightOperateUncheckedUpdateInput>
    /**
     * Choose, which flightOperate to update.
     */
    where: flightOperateWhereUniqueInput
  }

  /**
   * flightOperate updateMany
   */
  export type flightOperateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update flightOperates.
     */
    data: XOR<flightOperateUpdateManyMutationInput, flightOperateUncheckedUpdateManyInput>
    /**
     * Filter which flightOperates to update
     */
    where?: flightOperateWhereInput
    /**
     * Limit how many flightOperates to update.
     */
    limit?: number
  }

  /**
   * flightOperate upsert
   */
  export type flightOperateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flightOperate
     */
    select?: flightOperateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flightOperate
     */
    omit?: flightOperateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightOperateInclude<ExtArgs> | null
    /**
     * The filter to search for the flightOperate to update in case it exists.
     */
    where: flightOperateWhereUniqueInput
    /**
     * In case the flightOperate found by the `where` argument doesn't exist, create a new flightOperate with this data.
     */
    create: XOR<flightOperateCreateInput, flightOperateUncheckedCreateInput>
    /**
     * In case the flightOperate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<flightOperateUpdateInput, flightOperateUncheckedUpdateInput>
  }

  /**
   * flightOperate delete
   */
  export type flightOperateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flightOperate
     */
    select?: flightOperateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flightOperate
     */
    omit?: flightOperateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightOperateInclude<ExtArgs> | null
    /**
     * Filter which flightOperate to delete.
     */
    where: flightOperateWhereUniqueInput
  }

  /**
   * flightOperate deleteMany
   */
  export type flightOperateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which flightOperates to delete
     */
    where?: flightOperateWhereInput
    /**
     * Limit how many flightOperates to delete.
     */
    limit?: number
  }

  /**
   * flightOperate.bookingFlights
   */
  export type flightOperate$bookingFlightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_flight
     */
    select?: booking_flightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking_flight
     */
    omit?: booking_flightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_flightInclude<ExtArgs> | null
    where?: booking_flightWhereInput
    orderBy?: booking_flightOrderByWithRelationInput | booking_flightOrderByWithRelationInput[]
    cursor?: booking_flightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Booking_flightScalarFieldEnum | Booking_flightScalarFieldEnum[]
  }

  /**
   * flightOperate.tickets
   */
  export type flightOperate$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    where?: ticketWhereInput
    orderBy?: ticketOrderByWithRelationInput | ticketOrderByWithRelationInput[]
    cursor?: ticketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * flightOperate without action
   */
  export type flightOperateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the flightOperate
     */
    select?: flightOperateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the flightOperate
     */
    omit?: flightOperateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: flightOperateInclude<ExtArgs> | null
  }


  /**
   * Model passenger
   */

  export type AggregatePassenger = {
    _count: PassengerCountAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  export type PassengerMinAggregateOutputType = {
    passportNum: string | null
    passportCountry: string | null
    passportExpiry: Date | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    nationality: string | null
    ageRange: $Enums.AgeRange | null
    userId: string | null
  }

  export type PassengerMaxAggregateOutputType = {
    passportNum: string | null
    passportCountry: string | null
    passportExpiry: Date | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    nationality: string | null
    ageRange: $Enums.AgeRange | null
    userId: string | null
  }

  export type PassengerCountAggregateOutputType = {
    passportNum: number
    passportCountry: number
    passportExpiry: number
    firstName: number
    lastName: number
    dateOfBirth: number
    nationality: number
    ageRange: number
    userId: number
    _all: number
  }


  export type PassengerMinAggregateInputType = {
    passportNum?: true
    passportCountry?: true
    passportExpiry?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    nationality?: true
    ageRange?: true
    userId?: true
  }

  export type PassengerMaxAggregateInputType = {
    passportNum?: true
    passportCountry?: true
    passportExpiry?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    nationality?: true
    ageRange?: true
    userId?: true
  }

  export type PassengerCountAggregateInputType = {
    passportNum?: true
    passportCountry?: true
    passportExpiry?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    nationality?: true
    ageRange?: true
    userId?: true
    _all?: true
  }

  export type PassengerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which passenger to aggregate.
     */
    where?: passengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passengers to fetch.
     */
    orderBy?: passengerOrderByWithRelationInput | passengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: passengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned passengers
    **/
    _count?: true | PassengerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PassengerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PassengerMaxAggregateInputType
  }

  export type GetPassengerAggregateType<T extends PassengerAggregateArgs> = {
        [P in keyof T & keyof AggregatePassenger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassenger[P]>
      : GetScalarType<T[P], AggregatePassenger[P]>
  }




  export type passengerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: passengerWhereInput
    orderBy?: passengerOrderByWithAggregationInput | passengerOrderByWithAggregationInput[]
    by: PassengerScalarFieldEnum[] | PassengerScalarFieldEnum
    having?: passengerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PassengerCountAggregateInputType | true
    _min?: PassengerMinAggregateInputType
    _max?: PassengerMaxAggregateInputType
  }

  export type PassengerGroupByOutputType = {
    passportNum: string
    passportCountry: string
    passportExpiry: Date
    firstName: string
    lastName: string
    dateOfBirth: Date
    nationality: string
    ageRange: $Enums.AgeRange
    userId: string
    _count: PassengerCountAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  type GetPassengerGroupByPayload<T extends passengerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PassengerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PassengerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PassengerGroupByOutputType[P]>
            : GetScalarType<T[P], PassengerGroupByOutputType[P]>
        }
      >
    >


  export type passengerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    passportNum?: boolean
    passportCountry?: boolean
    passportExpiry?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    ageRange?: boolean
    userId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    passengerBookings?: boolean | passenger$passengerBookingsArgs<ExtArgs>
    tickets?: boolean | passenger$ticketsArgs<ExtArgs>
    _count?: boolean | PassengerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passenger"]>



  export type passengerSelectScalar = {
    passportNum?: boolean
    passportCountry?: boolean
    passportExpiry?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    ageRange?: boolean
    userId?: boolean
  }

  export type passengerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"passportNum" | "passportCountry" | "passportExpiry" | "firstName" | "lastName" | "dateOfBirth" | "nationality" | "ageRange" | "userId", ExtArgs["result"]["passenger"]>
  export type passengerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    passengerBookings?: boolean | passenger$passengerBookingsArgs<ExtArgs>
    tickets?: boolean | passenger$ticketsArgs<ExtArgs>
    _count?: boolean | PassengerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $passengerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "passenger"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      passengerBookings: Prisma.$passenger_bookingPayload<ExtArgs>[]
      tickets: Prisma.$ticketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      passportNum: string
      passportCountry: string
      passportExpiry: Date
      firstName: string
      lastName: string
      dateOfBirth: Date
      nationality: string
      ageRange: $Enums.AgeRange
      userId: string
    }, ExtArgs["result"]["passenger"]>
    composites: {}
  }

  type passengerGetPayload<S extends boolean | null | undefined | passengerDefaultArgs> = $Result.GetResult<Prisma.$passengerPayload, S>

  type passengerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<passengerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PassengerCountAggregateInputType | true
    }

  export interface passengerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['passenger'], meta: { name: 'passenger' } }
    /**
     * Find zero or one Passenger that matches the filter.
     * @param {passengerFindUniqueArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends passengerFindUniqueArgs>(args: SelectSubset<T, passengerFindUniqueArgs<ExtArgs>>): Prisma__passengerClient<$Result.GetResult<Prisma.$passengerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Passenger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {passengerFindUniqueOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends passengerFindUniqueOrThrowArgs>(args: SelectSubset<T, passengerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__passengerClient<$Result.GetResult<Prisma.$passengerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passengerFindFirstArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends passengerFindFirstArgs>(args?: SelectSubset<T, passengerFindFirstArgs<ExtArgs>>): Prisma__passengerClient<$Result.GetResult<Prisma.$passengerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passengerFindFirstOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends passengerFindFirstOrThrowArgs>(args?: SelectSubset<T, passengerFindFirstOrThrowArgs<ExtArgs>>): Prisma__passengerClient<$Result.GetResult<Prisma.$passengerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passengers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passengerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passengers
     * const passengers = await prisma.passenger.findMany()
     * 
     * // Get first 10 Passengers
     * const passengers = await prisma.passenger.findMany({ take: 10 })
     * 
     * // Only select the `passportNum`
     * const passengerWithPassportNumOnly = await prisma.passenger.findMany({ select: { passportNum: true } })
     * 
     */
    findMany<T extends passengerFindManyArgs>(args?: SelectSubset<T, passengerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Passenger.
     * @param {passengerCreateArgs} args - Arguments to create a Passenger.
     * @example
     * // Create one Passenger
     * const Passenger = await prisma.passenger.create({
     *   data: {
     *     // ... data to create a Passenger
     *   }
     * })
     * 
     */
    create<T extends passengerCreateArgs>(args: SelectSubset<T, passengerCreateArgs<ExtArgs>>): Prisma__passengerClient<$Result.GetResult<Prisma.$passengerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passengers.
     * @param {passengerCreateManyArgs} args - Arguments to create many Passengers.
     * @example
     * // Create many Passengers
     * const passenger = await prisma.passenger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends passengerCreateManyArgs>(args?: SelectSubset<T, passengerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Passenger.
     * @param {passengerDeleteArgs} args - Arguments to delete one Passenger.
     * @example
     * // Delete one Passenger
     * const Passenger = await prisma.passenger.delete({
     *   where: {
     *     // ... filter to delete one Passenger
     *   }
     * })
     * 
     */
    delete<T extends passengerDeleteArgs>(args: SelectSubset<T, passengerDeleteArgs<ExtArgs>>): Prisma__passengerClient<$Result.GetResult<Prisma.$passengerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Passenger.
     * @param {passengerUpdateArgs} args - Arguments to update one Passenger.
     * @example
     * // Update one Passenger
     * const passenger = await prisma.passenger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends passengerUpdateArgs>(args: SelectSubset<T, passengerUpdateArgs<ExtArgs>>): Prisma__passengerClient<$Result.GetResult<Prisma.$passengerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passengers.
     * @param {passengerDeleteManyArgs} args - Arguments to filter Passengers to delete.
     * @example
     * // Delete a few Passengers
     * const { count } = await prisma.passenger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends passengerDeleteManyArgs>(args?: SelectSubset<T, passengerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passengerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passengers
     * const passenger = await prisma.passenger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends passengerUpdateManyArgs>(args: SelectSubset<T, passengerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Passenger.
     * @param {passengerUpsertArgs} args - Arguments to update or create a Passenger.
     * @example
     * // Update or create a Passenger
     * const passenger = await prisma.passenger.upsert({
     *   create: {
     *     // ... data to create a Passenger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Passenger we want to update
     *   }
     * })
     */
    upsert<T extends passengerUpsertArgs>(args: SelectSubset<T, passengerUpsertArgs<ExtArgs>>): Prisma__passengerClient<$Result.GetResult<Prisma.$passengerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passengerCountArgs} args - Arguments to filter Passengers to count.
     * @example
     * // Count the number of Passengers
     * const count = await prisma.passenger.count({
     *   where: {
     *     // ... the filter for the Passengers we want to count
     *   }
     * })
    **/
    count<T extends passengerCountArgs>(
      args?: Subset<T, passengerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PassengerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PassengerAggregateArgs>(args: Subset<T, PassengerAggregateArgs>): Prisma.PrismaPromise<GetPassengerAggregateType<T>>

    /**
     * Group by Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passengerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends passengerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: passengerGroupByArgs['orderBy'] }
        : { orderBy?: passengerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, passengerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassengerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the passenger model
   */
  readonly fields: passengerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for passenger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__passengerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    passengerBookings<T extends passenger$passengerBookingsArgs<ExtArgs> = {}>(args?: Subset<T, passenger$passengerBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passenger_bookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends passenger$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, passenger$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the passenger model
   */
  interface passengerFieldRefs {
    readonly passportNum: FieldRef<"passenger", 'String'>
    readonly passportCountry: FieldRef<"passenger", 'String'>
    readonly passportExpiry: FieldRef<"passenger", 'DateTime'>
    readonly firstName: FieldRef<"passenger", 'String'>
    readonly lastName: FieldRef<"passenger", 'String'>
    readonly dateOfBirth: FieldRef<"passenger", 'DateTime'>
    readonly nationality: FieldRef<"passenger", 'String'>
    readonly ageRange: FieldRef<"passenger", 'AgeRange'>
    readonly userId: FieldRef<"passenger", 'String'>
  }
    

  // Custom InputTypes
  /**
   * passenger findUnique
   */
  export type passengerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger
     */
    select?: passengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger
     */
    omit?: passengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passengerInclude<ExtArgs> | null
    /**
     * Filter, which passenger to fetch.
     */
    where: passengerWhereUniqueInput
  }

  /**
   * passenger findUniqueOrThrow
   */
  export type passengerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger
     */
    select?: passengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger
     */
    omit?: passengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passengerInclude<ExtArgs> | null
    /**
     * Filter, which passenger to fetch.
     */
    where: passengerWhereUniqueInput
  }

  /**
   * passenger findFirst
   */
  export type passengerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger
     */
    select?: passengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger
     */
    omit?: passengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passengerInclude<ExtArgs> | null
    /**
     * Filter, which passenger to fetch.
     */
    where?: passengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passengers to fetch.
     */
    orderBy?: passengerOrderByWithRelationInput | passengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for passengers.
     */
    cursor?: passengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of passengers.
     */
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * passenger findFirstOrThrow
   */
  export type passengerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger
     */
    select?: passengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger
     */
    omit?: passengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passengerInclude<ExtArgs> | null
    /**
     * Filter, which passenger to fetch.
     */
    where?: passengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passengers to fetch.
     */
    orderBy?: passengerOrderByWithRelationInput | passengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for passengers.
     */
    cursor?: passengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of passengers.
     */
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * passenger findMany
   */
  export type passengerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger
     */
    select?: passengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger
     */
    omit?: passengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passengerInclude<ExtArgs> | null
    /**
     * Filter, which passengers to fetch.
     */
    where?: passengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passengers to fetch.
     */
    orderBy?: passengerOrderByWithRelationInput | passengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing passengers.
     */
    cursor?: passengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passengers.
     */
    skip?: number
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * passenger create
   */
  export type passengerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger
     */
    select?: passengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger
     */
    omit?: passengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passengerInclude<ExtArgs> | null
    /**
     * The data needed to create a passenger.
     */
    data: XOR<passengerCreateInput, passengerUncheckedCreateInput>
  }

  /**
   * passenger createMany
   */
  export type passengerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many passengers.
     */
    data: passengerCreateManyInput | passengerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * passenger update
   */
  export type passengerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger
     */
    select?: passengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger
     */
    omit?: passengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passengerInclude<ExtArgs> | null
    /**
     * The data needed to update a passenger.
     */
    data: XOR<passengerUpdateInput, passengerUncheckedUpdateInput>
    /**
     * Choose, which passenger to update.
     */
    where: passengerWhereUniqueInput
  }

  /**
   * passenger updateMany
   */
  export type passengerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update passengers.
     */
    data: XOR<passengerUpdateManyMutationInput, passengerUncheckedUpdateManyInput>
    /**
     * Filter which passengers to update
     */
    where?: passengerWhereInput
    /**
     * Limit how many passengers to update.
     */
    limit?: number
  }

  /**
   * passenger upsert
   */
  export type passengerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger
     */
    select?: passengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger
     */
    omit?: passengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passengerInclude<ExtArgs> | null
    /**
     * The filter to search for the passenger to update in case it exists.
     */
    where: passengerWhereUniqueInput
    /**
     * In case the passenger found by the `where` argument doesn't exist, create a new passenger with this data.
     */
    create: XOR<passengerCreateInput, passengerUncheckedCreateInput>
    /**
     * In case the passenger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<passengerUpdateInput, passengerUncheckedUpdateInput>
  }

  /**
   * passenger delete
   */
  export type passengerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger
     */
    select?: passengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger
     */
    omit?: passengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passengerInclude<ExtArgs> | null
    /**
     * Filter which passenger to delete.
     */
    where: passengerWhereUniqueInput
  }

  /**
   * passenger deleteMany
   */
  export type passengerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which passengers to delete
     */
    where?: passengerWhereInput
    /**
     * Limit how many passengers to delete.
     */
    limit?: number
  }

  /**
   * passenger.passengerBookings
   */
  export type passenger$passengerBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger_booking
     */
    select?: passenger_bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger_booking
     */
    omit?: passenger_bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passenger_bookingInclude<ExtArgs> | null
    where?: passenger_bookingWhereInput
    orderBy?: passenger_bookingOrderByWithRelationInput | passenger_bookingOrderByWithRelationInput[]
    cursor?: passenger_bookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Passenger_bookingScalarFieldEnum | Passenger_bookingScalarFieldEnum[]
  }

  /**
   * passenger.tickets
   */
  export type passenger$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    where?: ticketWhereInput
    orderBy?: ticketOrderByWithRelationInput | ticketOrderByWithRelationInput[]
    cursor?: ticketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * passenger without action
   */
  export type passengerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger
     */
    select?: passengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger
     */
    omit?: passengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passengerInclude<ExtArgs> | null
  }


  /**
   * Model passenger_booking
   */

  export type AggregatePassenger_booking = {
    _count: Passenger_bookingCountAggregateOutputType | null
    _min: Passenger_bookingMinAggregateOutputType | null
    _max: Passenger_bookingMaxAggregateOutputType | null
  }

  export type Passenger_bookingMinAggregateOutputType = {
    bookingId: string | null
    passportNum: string | null
  }

  export type Passenger_bookingMaxAggregateOutputType = {
    bookingId: string | null
    passportNum: string | null
  }

  export type Passenger_bookingCountAggregateOutputType = {
    bookingId: number
    passportNum: number
    _all: number
  }


  export type Passenger_bookingMinAggregateInputType = {
    bookingId?: true
    passportNum?: true
  }

  export type Passenger_bookingMaxAggregateInputType = {
    bookingId?: true
    passportNum?: true
  }

  export type Passenger_bookingCountAggregateInputType = {
    bookingId?: true
    passportNum?: true
    _all?: true
  }

  export type Passenger_bookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which passenger_booking to aggregate.
     */
    where?: passenger_bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passenger_bookings to fetch.
     */
    orderBy?: passenger_bookingOrderByWithRelationInput | passenger_bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: passenger_bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passenger_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passenger_bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned passenger_bookings
    **/
    _count?: true | Passenger_bookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Passenger_bookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Passenger_bookingMaxAggregateInputType
  }

  export type GetPassenger_bookingAggregateType<T extends Passenger_bookingAggregateArgs> = {
        [P in keyof T & keyof AggregatePassenger_booking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassenger_booking[P]>
      : GetScalarType<T[P], AggregatePassenger_booking[P]>
  }




  export type passenger_bookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: passenger_bookingWhereInput
    orderBy?: passenger_bookingOrderByWithAggregationInput | passenger_bookingOrderByWithAggregationInput[]
    by: Passenger_bookingScalarFieldEnum[] | Passenger_bookingScalarFieldEnum
    having?: passenger_bookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Passenger_bookingCountAggregateInputType | true
    _min?: Passenger_bookingMinAggregateInputType
    _max?: Passenger_bookingMaxAggregateInputType
  }

  export type Passenger_bookingGroupByOutputType = {
    bookingId: string
    passportNum: string
    _count: Passenger_bookingCountAggregateOutputType | null
    _min: Passenger_bookingMinAggregateOutputType | null
    _max: Passenger_bookingMaxAggregateOutputType | null
  }

  type GetPassenger_bookingGroupByPayload<T extends passenger_bookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Passenger_bookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Passenger_bookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Passenger_bookingGroupByOutputType[P]>
            : GetScalarType<T[P], Passenger_bookingGroupByOutputType[P]>
        }
      >
    >


  export type passenger_bookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bookingId?: boolean
    passportNum?: boolean
    booking?: boolean | bookingDefaultArgs<ExtArgs>
    passenger?: boolean | passengerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passenger_booking"]>



  export type passenger_bookingSelectScalar = {
    bookingId?: boolean
    passportNum?: boolean
  }

  export type passenger_bookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"bookingId" | "passportNum", ExtArgs["result"]["passenger_booking"]>
  export type passenger_bookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingDefaultArgs<ExtArgs>
    passenger?: boolean | passengerDefaultArgs<ExtArgs>
  }

  export type $passenger_bookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "passenger_booking"
    objects: {
      booking: Prisma.$bookingPayload<ExtArgs>
      passenger: Prisma.$passengerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bookingId: string
      passportNum: string
    }, ExtArgs["result"]["passenger_booking"]>
    composites: {}
  }

  type passenger_bookingGetPayload<S extends boolean | null | undefined | passenger_bookingDefaultArgs> = $Result.GetResult<Prisma.$passenger_bookingPayload, S>

  type passenger_bookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<passenger_bookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Passenger_bookingCountAggregateInputType | true
    }

  export interface passenger_bookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['passenger_booking'], meta: { name: 'passenger_booking' } }
    /**
     * Find zero or one Passenger_booking that matches the filter.
     * @param {passenger_bookingFindUniqueArgs} args - Arguments to find a Passenger_booking
     * @example
     * // Get one Passenger_booking
     * const passenger_booking = await prisma.passenger_booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends passenger_bookingFindUniqueArgs>(args: SelectSubset<T, passenger_bookingFindUniqueArgs<ExtArgs>>): Prisma__passenger_bookingClient<$Result.GetResult<Prisma.$passenger_bookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Passenger_booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {passenger_bookingFindUniqueOrThrowArgs} args - Arguments to find a Passenger_booking
     * @example
     * // Get one Passenger_booking
     * const passenger_booking = await prisma.passenger_booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends passenger_bookingFindUniqueOrThrowArgs>(args: SelectSubset<T, passenger_bookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__passenger_bookingClient<$Result.GetResult<Prisma.$passenger_bookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger_booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passenger_bookingFindFirstArgs} args - Arguments to find a Passenger_booking
     * @example
     * // Get one Passenger_booking
     * const passenger_booking = await prisma.passenger_booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends passenger_bookingFindFirstArgs>(args?: SelectSubset<T, passenger_bookingFindFirstArgs<ExtArgs>>): Prisma__passenger_bookingClient<$Result.GetResult<Prisma.$passenger_bookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger_booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passenger_bookingFindFirstOrThrowArgs} args - Arguments to find a Passenger_booking
     * @example
     * // Get one Passenger_booking
     * const passenger_booking = await prisma.passenger_booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends passenger_bookingFindFirstOrThrowArgs>(args?: SelectSubset<T, passenger_bookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__passenger_bookingClient<$Result.GetResult<Prisma.$passenger_bookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passenger_bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passenger_bookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passenger_bookings
     * const passenger_bookings = await prisma.passenger_booking.findMany()
     * 
     * // Get first 10 Passenger_bookings
     * const passenger_bookings = await prisma.passenger_booking.findMany({ take: 10 })
     * 
     * // Only select the `bookingId`
     * const passenger_bookingWithBookingIdOnly = await prisma.passenger_booking.findMany({ select: { bookingId: true } })
     * 
     */
    findMany<T extends passenger_bookingFindManyArgs>(args?: SelectSubset<T, passenger_bookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passenger_bookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Passenger_booking.
     * @param {passenger_bookingCreateArgs} args - Arguments to create a Passenger_booking.
     * @example
     * // Create one Passenger_booking
     * const Passenger_booking = await prisma.passenger_booking.create({
     *   data: {
     *     // ... data to create a Passenger_booking
     *   }
     * })
     * 
     */
    create<T extends passenger_bookingCreateArgs>(args: SelectSubset<T, passenger_bookingCreateArgs<ExtArgs>>): Prisma__passenger_bookingClient<$Result.GetResult<Prisma.$passenger_bookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passenger_bookings.
     * @param {passenger_bookingCreateManyArgs} args - Arguments to create many Passenger_bookings.
     * @example
     * // Create many Passenger_bookings
     * const passenger_booking = await prisma.passenger_booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends passenger_bookingCreateManyArgs>(args?: SelectSubset<T, passenger_bookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Passenger_booking.
     * @param {passenger_bookingDeleteArgs} args - Arguments to delete one Passenger_booking.
     * @example
     * // Delete one Passenger_booking
     * const Passenger_booking = await prisma.passenger_booking.delete({
     *   where: {
     *     // ... filter to delete one Passenger_booking
     *   }
     * })
     * 
     */
    delete<T extends passenger_bookingDeleteArgs>(args: SelectSubset<T, passenger_bookingDeleteArgs<ExtArgs>>): Prisma__passenger_bookingClient<$Result.GetResult<Prisma.$passenger_bookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Passenger_booking.
     * @param {passenger_bookingUpdateArgs} args - Arguments to update one Passenger_booking.
     * @example
     * // Update one Passenger_booking
     * const passenger_booking = await prisma.passenger_booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends passenger_bookingUpdateArgs>(args: SelectSubset<T, passenger_bookingUpdateArgs<ExtArgs>>): Prisma__passenger_bookingClient<$Result.GetResult<Prisma.$passenger_bookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passenger_bookings.
     * @param {passenger_bookingDeleteManyArgs} args - Arguments to filter Passenger_bookings to delete.
     * @example
     * // Delete a few Passenger_bookings
     * const { count } = await prisma.passenger_booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends passenger_bookingDeleteManyArgs>(args?: SelectSubset<T, passenger_bookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passenger_bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passenger_bookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passenger_bookings
     * const passenger_booking = await prisma.passenger_booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends passenger_bookingUpdateManyArgs>(args: SelectSubset<T, passenger_bookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Passenger_booking.
     * @param {passenger_bookingUpsertArgs} args - Arguments to update or create a Passenger_booking.
     * @example
     * // Update or create a Passenger_booking
     * const passenger_booking = await prisma.passenger_booking.upsert({
     *   create: {
     *     // ... data to create a Passenger_booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Passenger_booking we want to update
     *   }
     * })
     */
    upsert<T extends passenger_bookingUpsertArgs>(args: SelectSubset<T, passenger_bookingUpsertArgs<ExtArgs>>): Prisma__passenger_bookingClient<$Result.GetResult<Prisma.$passenger_bookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passenger_bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passenger_bookingCountArgs} args - Arguments to filter Passenger_bookings to count.
     * @example
     * // Count the number of Passenger_bookings
     * const count = await prisma.passenger_booking.count({
     *   where: {
     *     // ... the filter for the Passenger_bookings we want to count
     *   }
     * })
    **/
    count<T extends passenger_bookingCountArgs>(
      args?: Subset<T, passenger_bookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Passenger_bookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Passenger_booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Passenger_bookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Passenger_bookingAggregateArgs>(args: Subset<T, Passenger_bookingAggregateArgs>): Prisma.PrismaPromise<GetPassenger_bookingAggregateType<T>>

    /**
     * Group by Passenger_booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passenger_bookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends passenger_bookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: passenger_bookingGroupByArgs['orderBy'] }
        : { orderBy?: passenger_bookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, passenger_bookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassenger_bookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the passenger_booking model
   */
  readonly fields: passenger_bookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for passenger_booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__passenger_bookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends bookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingDefaultArgs<ExtArgs>>): Prisma__bookingClient<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    passenger<T extends passengerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, passengerDefaultArgs<ExtArgs>>): Prisma__passengerClient<$Result.GetResult<Prisma.$passengerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the passenger_booking model
   */
  interface passenger_bookingFieldRefs {
    readonly bookingId: FieldRef<"passenger_booking", 'String'>
    readonly passportNum: FieldRef<"passenger_booking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * passenger_booking findUnique
   */
  export type passenger_bookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger_booking
     */
    select?: passenger_bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger_booking
     */
    omit?: passenger_bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passenger_bookingInclude<ExtArgs> | null
    /**
     * Filter, which passenger_booking to fetch.
     */
    where: passenger_bookingWhereUniqueInput
  }

  /**
   * passenger_booking findUniqueOrThrow
   */
  export type passenger_bookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger_booking
     */
    select?: passenger_bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger_booking
     */
    omit?: passenger_bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passenger_bookingInclude<ExtArgs> | null
    /**
     * Filter, which passenger_booking to fetch.
     */
    where: passenger_bookingWhereUniqueInput
  }

  /**
   * passenger_booking findFirst
   */
  export type passenger_bookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger_booking
     */
    select?: passenger_bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger_booking
     */
    omit?: passenger_bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passenger_bookingInclude<ExtArgs> | null
    /**
     * Filter, which passenger_booking to fetch.
     */
    where?: passenger_bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passenger_bookings to fetch.
     */
    orderBy?: passenger_bookingOrderByWithRelationInput | passenger_bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for passenger_bookings.
     */
    cursor?: passenger_bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passenger_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passenger_bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of passenger_bookings.
     */
    distinct?: Passenger_bookingScalarFieldEnum | Passenger_bookingScalarFieldEnum[]
  }

  /**
   * passenger_booking findFirstOrThrow
   */
  export type passenger_bookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger_booking
     */
    select?: passenger_bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger_booking
     */
    omit?: passenger_bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passenger_bookingInclude<ExtArgs> | null
    /**
     * Filter, which passenger_booking to fetch.
     */
    where?: passenger_bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passenger_bookings to fetch.
     */
    orderBy?: passenger_bookingOrderByWithRelationInput | passenger_bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for passenger_bookings.
     */
    cursor?: passenger_bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passenger_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passenger_bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of passenger_bookings.
     */
    distinct?: Passenger_bookingScalarFieldEnum | Passenger_bookingScalarFieldEnum[]
  }

  /**
   * passenger_booking findMany
   */
  export type passenger_bookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger_booking
     */
    select?: passenger_bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger_booking
     */
    omit?: passenger_bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passenger_bookingInclude<ExtArgs> | null
    /**
     * Filter, which passenger_bookings to fetch.
     */
    where?: passenger_bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passenger_bookings to fetch.
     */
    orderBy?: passenger_bookingOrderByWithRelationInput | passenger_bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing passenger_bookings.
     */
    cursor?: passenger_bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passenger_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passenger_bookings.
     */
    skip?: number
    distinct?: Passenger_bookingScalarFieldEnum | Passenger_bookingScalarFieldEnum[]
  }

  /**
   * passenger_booking create
   */
  export type passenger_bookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger_booking
     */
    select?: passenger_bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger_booking
     */
    omit?: passenger_bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passenger_bookingInclude<ExtArgs> | null
    /**
     * The data needed to create a passenger_booking.
     */
    data: XOR<passenger_bookingCreateInput, passenger_bookingUncheckedCreateInput>
  }

  /**
   * passenger_booking createMany
   */
  export type passenger_bookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many passenger_bookings.
     */
    data: passenger_bookingCreateManyInput | passenger_bookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * passenger_booking update
   */
  export type passenger_bookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger_booking
     */
    select?: passenger_bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger_booking
     */
    omit?: passenger_bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passenger_bookingInclude<ExtArgs> | null
    /**
     * The data needed to update a passenger_booking.
     */
    data: XOR<passenger_bookingUpdateInput, passenger_bookingUncheckedUpdateInput>
    /**
     * Choose, which passenger_booking to update.
     */
    where: passenger_bookingWhereUniqueInput
  }

  /**
   * passenger_booking updateMany
   */
  export type passenger_bookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update passenger_bookings.
     */
    data: XOR<passenger_bookingUpdateManyMutationInput, passenger_bookingUncheckedUpdateManyInput>
    /**
     * Filter which passenger_bookings to update
     */
    where?: passenger_bookingWhereInput
    /**
     * Limit how many passenger_bookings to update.
     */
    limit?: number
  }

  /**
   * passenger_booking upsert
   */
  export type passenger_bookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger_booking
     */
    select?: passenger_bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger_booking
     */
    omit?: passenger_bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passenger_bookingInclude<ExtArgs> | null
    /**
     * The filter to search for the passenger_booking to update in case it exists.
     */
    where: passenger_bookingWhereUniqueInput
    /**
     * In case the passenger_booking found by the `where` argument doesn't exist, create a new passenger_booking with this data.
     */
    create: XOR<passenger_bookingCreateInput, passenger_bookingUncheckedCreateInput>
    /**
     * In case the passenger_booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<passenger_bookingUpdateInput, passenger_bookingUncheckedUpdateInput>
  }

  /**
   * passenger_booking delete
   */
  export type passenger_bookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger_booking
     */
    select?: passenger_bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger_booking
     */
    omit?: passenger_bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passenger_bookingInclude<ExtArgs> | null
    /**
     * Filter which passenger_booking to delete.
     */
    where: passenger_bookingWhereUniqueInput
  }

  /**
   * passenger_booking deleteMany
   */
  export type passenger_bookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which passenger_bookings to delete
     */
    where?: passenger_bookingWhereInput
    /**
     * Limit how many passenger_bookings to delete.
     */
    limit?: number
  }

  /**
   * passenger_booking without action
   */
  export type passenger_bookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger_booking
     */
    select?: passenger_bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger_booking
     */
    omit?: passenger_bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passenger_bookingInclude<ExtArgs> | null
  }


  /**
   * Model payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    paymentId: string | null
    amount: number | null
    method: string | null
    paymentDate: Date | null
    bookingId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    paymentId: string | null
    amount: number | null
    method: string | null
    paymentDate: Date | null
    bookingId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    paymentId: number
    amount: number
    method: number
    paymentDate: number
    bookingId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    paymentId?: true
    amount?: true
    method?: true
    paymentDate?: true
    bookingId?: true
  }

  export type PaymentMaxAggregateInputType = {
    paymentId?: true
    amount?: true
    method?: true
    paymentDate?: true
    bookingId?: true
  }

  export type PaymentCountAggregateInputType = {
    paymentId?: true
    amount?: true
    method?: true
    paymentDate?: true
    bookingId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment to aggregate.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithAggregationInput | paymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    paymentId: string
    amount: number
    method: string
    paymentDate: Date
    bookingId: string
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    paymentId?: boolean
    amount?: boolean
    method?: boolean
    paymentDate?: boolean
    bookingId?: boolean
    booking?: boolean | bookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type paymentSelectScalar = {
    paymentId?: boolean
    amount?: boolean
    method?: boolean
    paymentDate?: boolean
    bookingId?: boolean
  }

  export type paymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"paymentId" | "amount" | "method" | "paymentDate" | "bookingId", ExtArgs["result"]["payment"]>
  export type paymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingDefaultArgs<ExtArgs>
  }

  export type $paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment"
    objects: {
      booking: Prisma.$bookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      paymentId: string
      amount: number
      method: string
      paymentDate: Date
      bookingId: string
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type paymentGetPayload<S extends boolean | null | undefined | paymentDefaultArgs> = $Result.GetResult<Prisma.$paymentPayload, S>

  type paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment'], meta: { name: 'payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentFindUniqueArgs>(args: SelectSubset<T, paymentFindUniqueArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentFindFirstArgs>(args?: SelectSubset<T, paymentFindFirstArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `paymentId`
     * const paymentWithPaymentIdOnly = await prisma.payment.findMany({ select: { paymentId: true } })
     * 
     */
    findMany<T extends paymentFindManyArgs>(args?: SelectSubset<T, paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends paymentCreateArgs>(args: SelectSubset<T, paymentCreateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentCreateManyArgs>(args?: SelectSubset<T, paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends paymentDeleteArgs>(args: SelectSubset<T, paymentDeleteArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentUpdateArgs>(args: SelectSubset<T, paymentUpdateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentDeleteManyArgs>(args?: SelectSubset<T, paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentUpdateManyArgs>(args: SelectSubset<T, paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends paymentUpsertArgs>(args: SelectSubset<T, paymentUpsertArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentGroupByArgs['orderBy'] }
        : { orderBy?: paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment model
   */
  readonly fields: paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends bookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingDefaultArgs<ExtArgs>>): Prisma__bookingClient<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment model
   */
  interface paymentFieldRefs {
    readonly paymentId: FieldRef<"payment", 'String'>
    readonly amount: FieldRef<"payment", 'Float'>
    readonly method: FieldRef<"payment", 'String'>
    readonly paymentDate: FieldRef<"payment", 'DateTime'>
    readonly bookingId: FieldRef<"payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payment findUnique
   */
  export type paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findFirst
   */
  export type paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findMany
   */
  export type paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment create
   */
  export type paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The data needed to create a payment.
     */
    data: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }

  /**
   * payment createMany
   */
  export type paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment update
   */
  export type paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The data needed to update a payment.
     */
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payment upsert
   */
  export type paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The filter to search for the payment to update in case it exists.
     */
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     */
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }

  /**
   * payment delete
   */
  export type paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter which payment to delete.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payment without action
   */
  export type paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
  }


  /**
   * Model aircraft_seatmap
   */

  export type AggregateAircraft_seatmap = {
    _count: Aircraft_seatmapCountAggregateOutputType | null
    _min: Aircraft_seatmapMinAggregateOutputType | null
    _max: Aircraft_seatmapMaxAggregateOutputType | null
  }

  export type Aircraft_seatmapMinAggregateOutputType = {
    aircraftId: string | null
    seatMapId: string | null
  }

  export type Aircraft_seatmapMaxAggregateOutputType = {
    aircraftId: string | null
    seatMapId: string | null
  }

  export type Aircraft_seatmapCountAggregateOutputType = {
    aircraftId: number
    seatMapId: number
    _all: number
  }


  export type Aircraft_seatmapMinAggregateInputType = {
    aircraftId?: true
    seatMapId?: true
  }

  export type Aircraft_seatmapMaxAggregateInputType = {
    aircraftId?: true
    seatMapId?: true
  }

  export type Aircraft_seatmapCountAggregateInputType = {
    aircraftId?: true
    seatMapId?: true
    _all?: true
  }

  export type Aircraft_seatmapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aircraft_seatmap to aggregate.
     */
    where?: aircraft_seatmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aircraft_seatmaps to fetch.
     */
    orderBy?: aircraft_seatmapOrderByWithRelationInput | aircraft_seatmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aircraft_seatmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aircraft_seatmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aircraft_seatmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aircraft_seatmaps
    **/
    _count?: true | Aircraft_seatmapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Aircraft_seatmapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Aircraft_seatmapMaxAggregateInputType
  }

  export type GetAircraft_seatmapAggregateType<T extends Aircraft_seatmapAggregateArgs> = {
        [P in keyof T & keyof AggregateAircraft_seatmap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAircraft_seatmap[P]>
      : GetScalarType<T[P], AggregateAircraft_seatmap[P]>
  }




  export type aircraft_seatmapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aircraft_seatmapWhereInput
    orderBy?: aircraft_seatmapOrderByWithAggregationInput | aircraft_seatmapOrderByWithAggregationInput[]
    by: Aircraft_seatmapScalarFieldEnum[] | Aircraft_seatmapScalarFieldEnum
    having?: aircraft_seatmapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Aircraft_seatmapCountAggregateInputType | true
    _min?: Aircraft_seatmapMinAggregateInputType
    _max?: Aircraft_seatmapMaxAggregateInputType
  }

  export type Aircraft_seatmapGroupByOutputType = {
    aircraftId: string
    seatMapId: string
    _count: Aircraft_seatmapCountAggregateOutputType | null
    _min: Aircraft_seatmapMinAggregateOutputType | null
    _max: Aircraft_seatmapMaxAggregateOutputType | null
  }

  type GetAircraft_seatmapGroupByPayload<T extends aircraft_seatmapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Aircraft_seatmapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Aircraft_seatmapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Aircraft_seatmapGroupByOutputType[P]>
            : GetScalarType<T[P], Aircraft_seatmapGroupByOutputType[P]>
        }
      >
    >


  export type aircraft_seatmapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    aircraftId?: boolean
    seatMapId?: boolean
    aircraft?: boolean | aircraftDefaultArgs<ExtArgs>
    seatmap?: boolean | seatmap_infoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aircraft_seatmap"]>



  export type aircraft_seatmapSelectScalar = {
    aircraftId?: boolean
    seatMapId?: boolean
  }

  export type aircraft_seatmapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"aircraftId" | "seatMapId", ExtArgs["result"]["aircraft_seatmap"]>
  export type aircraft_seatmapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aircraft?: boolean | aircraftDefaultArgs<ExtArgs>
    seatmap?: boolean | seatmap_infoDefaultArgs<ExtArgs>
  }

  export type $aircraft_seatmapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "aircraft_seatmap"
    objects: {
      aircraft: Prisma.$aircraftPayload<ExtArgs>
      seatmap: Prisma.$seatmap_infoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      aircraftId: string
      seatMapId: string
    }, ExtArgs["result"]["aircraft_seatmap"]>
    composites: {}
  }

  type aircraft_seatmapGetPayload<S extends boolean | null | undefined | aircraft_seatmapDefaultArgs> = $Result.GetResult<Prisma.$aircraft_seatmapPayload, S>

  type aircraft_seatmapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<aircraft_seatmapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Aircraft_seatmapCountAggregateInputType | true
    }

  export interface aircraft_seatmapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['aircraft_seatmap'], meta: { name: 'aircraft_seatmap' } }
    /**
     * Find zero or one Aircraft_seatmap that matches the filter.
     * @param {aircraft_seatmapFindUniqueArgs} args - Arguments to find a Aircraft_seatmap
     * @example
     * // Get one Aircraft_seatmap
     * const aircraft_seatmap = await prisma.aircraft_seatmap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends aircraft_seatmapFindUniqueArgs>(args: SelectSubset<T, aircraft_seatmapFindUniqueArgs<ExtArgs>>): Prisma__aircraft_seatmapClient<$Result.GetResult<Prisma.$aircraft_seatmapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Aircraft_seatmap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {aircraft_seatmapFindUniqueOrThrowArgs} args - Arguments to find a Aircraft_seatmap
     * @example
     * // Get one Aircraft_seatmap
     * const aircraft_seatmap = await prisma.aircraft_seatmap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends aircraft_seatmapFindUniqueOrThrowArgs>(args: SelectSubset<T, aircraft_seatmapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__aircraft_seatmapClient<$Result.GetResult<Prisma.$aircraft_seatmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aircraft_seatmap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraft_seatmapFindFirstArgs} args - Arguments to find a Aircraft_seatmap
     * @example
     * // Get one Aircraft_seatmap
     * const aircraft_seatmap = await prisma.aircraft_seatmap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends aircraft_seatmapFindFirstArgs>(args?: SelectSubset<T, aircraft_seatmapFindFirstArgs<ExtArgs>>): Prisma__aircraft_seatmapClient<$Result.GetResult<Prisma.$aircraft_seatmapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aircraft_seatmap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraft_seatmapFindFirstOrThrowArgs} args - Arguments to find a Aircraft_seatmap
     * @example
     * // Get one Aircraft_seatmap
     * const aircraft_seatmap = await prisma.aircraft_seatmap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends aircraft_seatmapFindFirstOrThrowArgs>(args?: SelectSubset<T, aircraft_seatmapFindFirstOrThrowArgs<ExtArgs>>): Prisma__aircraft_seatmapClient<$Result.GetResult<Prisma.$aircraft_seatmapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Aircraft_seatmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraft_seatmapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Aircraft_seatmaps
     * const aircraft_seatmaps = await prisma.aircraft_seatmap.findMany()
     * 
     * // Get first 10 Aircraft_seatmaps
     * const aircraft_seatmaps = await prisma.aircraft_seatmap.findMany({ take: 10 })
     * 
     * // Only select the `aircraftId`
     * const aircraft_seatmapWithAircraftIdOnly = await prisma.aircraft_seatmap.findMany({ select: { aircraftId: true } })
     * 
     */
    findMany<T extends aircraft_seatmapFindManyArgs>(args?: SelectSubset<T, aircraft_seatmapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aircraft_seatmapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Aircraft_seatmap.
     * @param {aircraft_seatmapCreateArgs} args - Arguments to create a Aircraft_seatmap.
     * @example
     * // Create one Aircraft_seatmap
     * const Aircraft_seatmap = await prisma.aircraft_seatmap.create({
     *   data: {
     *     // ... data to create a Aircraft_seatmap
     *   }
     * })
     * 
     */
    create<T extends aircraft_seatmapCreateArgs>(args: SelectSubset<T, aircraft_seatmapCreateArgs<ExtArgs>>): Prisma__aircraft_seatmapClient<$Result.GetResult<Prisma.$aircraft_seatmapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Aircraft_seatmaps.
     * @param {aircraft_seatmapCreateManyArgs} args - Arguments to create many Aircraft_seatmaps.
     * @example
     * // Create many Aircraft_seatmaps
     * const aircraft_seatmap = await prisma.aircraft_seatmap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends aircraft_seatmapCreateManyArgs>(args?: SelectSubset<T, aircraft_seatmapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Aircraft_seatmap.
     * @param {aircraft_seatmapDeleteArgs} args - Arguments to delete one Aircraft_seatmap.
     * @example
     * // Delete one Aircraft_seatmap
     * const Aircraft_seatmap = await prisma.aircraft_seatmap.delete({
     *   where: {
     *     // ... filter to delete one Aircraft_seatmap
     *   }
     * })
     * 
     */
    delete<T extends aircraft_seatmapDeleteArgs>(args: SelectSubset<T, aircraft_seatmapDeleteArgs<ExtArgs>>): Prisma__aircraft_seatmapClient<$Result.GetResult<Prisma.$aircraft_seatmapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Aircraft_seatmap.
     * @param {aircraft_seatmapUpdateArgs} args - Arguments to update one Aircraft_seatmap.
     * @example
     * // Update one Aircraft_seatmap
     * const aircraft_seatmap = await prisma.aircraft_seatmap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends aircraft_seatmapUpdateArgs>(args: SelectSubset<T, aircraft_seatmapUpdateArgs<ExtArgs>>): Prisma__aircraft_seatmapClient<$Result.GetResult<Prisma.$aircraft_seatmapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Aircraft_seatmaps.
     * @param {aircraft_seatmapDeleteManyArgs} args - Arguments to filter Aircraft_seatmaps to delete.
     * @example
     * // Delete a few Aircraft_seatmaps
     * const { count } = await prisma.aircraft_seatmap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends aircraft_seatmapDeleteManyArgs>(args?: SelectSubset<T, aircraft_seatmapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aircraft_seatmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraft_seatmapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Aircraft_seatmaps
     * const aircraft_seatmap = await prisma.aircraft_seatmap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends aircraft_seatmapUpdateManyArgs>(args: SelectSubset<T, aircraft_seatmapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Aircraft_seatmap.
     * @param {aircraft_seatmapUpsertArgs} args - Arguments to update or create a Aircraft_seatmap.
     * @example
     * // Update or create a Aircraft_seatmap
     * const aircraft_seatmap = await prisma.aircraft_seatmap.upsert({
     *   create: {
     *     // ... data to create a Aircraft_seatmap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aircraft_seatmap we want to update
     *   }
     * })
     */
    upsert<T extends aircraft_seatmapUpsertArgs>(args: SelectSubset<T, aircraft_seatmapUpsertArgs<ExtArgs>>): Prisma__aircraft_seatmapClient<$Result.GetResult<Prisma.$aircraft_seatmapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Aircraft_seatmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraft_seatmapCountArgs} args - Arguments to filter Aircraft_seatmaps to count.
     * @example
     * // Count the number of Aircraft_seatmaps
     * const count = await prisma.aircraft_seatmap.count({
     *   where: {
     *     // ... the filter for the Aircraft_seatmaps we want to count
     *   }
     * })
    **/
    count<T extends aircraft_seatmapCountArgs>(
      args?: Subset<T, aircraft_seatmapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Aircraft_seatmapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aircraft_seatmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Aircraft_seatmapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Aircraft_seatmapAggregateArgs>(args: Subset<T, Aircraft_seatmapAggregateArgs>): Prisma.PrismaPromise<GetAircraft_seatmapAggregateType<T>>

    /**
     * Group by Aircraft_seatmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aircraft_seatmapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aircraft_seatmapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aircraft_seatmapGroupByArgs['orderBy'] }
        : { orderBy?: aircraft_seatmapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aircraft_seatmapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAircraft_seatmapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the aircraft_seatmap model
   */
  readonly fields: aircraft_seatmapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for aircraft_seatmap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__aircraft_seatmapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aircraft<T extends aircraftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, aircraftDefaultArgs<ExtArgs>>): Prisma__aircraftClient<$Result.GetResult<Prisma.$aircraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seatmap<T extends seatmap_infoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, seatmap_infoDefaultArgs<ExtArgs>>): Prisma__seatmap_infoClient<$Result.GetResult<Prisma.$seatmap_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the aircraft_seatmap model
   */
  interface aircraft_seatmapFieldRefs {
    readonly aircraftId: FieldRef<"aircraft_seatmap", 'String'>
    readonly seatMapId: FieldRef<"aircraft_seatmap", 'String'>
  }
    

  // Custom InputTypes
  /**
   * aircraft_seatmap findUnique
   */
  export type aircraft_seatmapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft_seatmap
     */
    select?: aircraft_seatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft_seatmap
     */
    omit?: aircraft_seatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraft_seatmapInclude<ExtArgs> | null
    /**
     * Filter, which aircraft_seatmap to fetch.
     */
    where: aircraft_seatmapWhereUniqueInput
  }

  /**
   * aircraft_seatmap findUniqueOrThrow
   */
  export type aircraft_seatmapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft_seatmap
     */
    select?: aircraft_seatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft_seatmap
     */
    omit?: aircraft_seatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraft_seatmapInclude<ExtArgs> | null
    /**
     * Filter, which aircraft_seatmap to fetch.
     */
    where: aircraft_seatmapWhereUniqueInput
  }

  /**
   * aircraft_seatmap findFirst
   */
  export type aircraft_seatmapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft_seatmap
     */
    select?: aircraft_seatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft_seatmap
     */
    omit?: aircraft_seatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraft_seatmapInclude<ExtArgs> | null
    /**
     * Filter, which aircraft_seatmap to fetch.
     */
    where?: aircraft_seatmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aircraft_seatmaps to fetch.
     */
    orderBy?: aircraft_seatmapOrderByWithRelationInput | aircraft_seatmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aircraft_seatmaps.
     */
    cursor?: aircraft_seatmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aircraft_seatmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aircraft_seatmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aircraft_seatmaps.
     */
    distinct?: Aircraft_seatmapScalarFieldEnum | Aircraft_seatmapScalarFieldEnum[]
  }

  /**
   * aircraft_seatmap findFirstOrThrow
   */
  export type aircraft_seatmapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft_seatmap
     */
    select?: aircraft_seatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft_seatmap
     */
    omit?: aircraft_seatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraft_seatmapInclude<ExtArgs> | null
    /**
     * Filter, which aircraft_seatmap to fetch.
     */
    where?: aircraft_seatmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aircraft_seatmaps to fetch.
     */
    orderBy?: aircraft_seatmapOrderByWithRelationInput | aircraft_seatmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aircraft_seatmaps.
     */
    cursor?: aircraft_seatmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aircraft_seatmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aircraft_seatmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aircraft_seatmaps.
     */
    distinct?: Aircraft_seatmapScalarFieldEnum | Aircraft_seatmapScalarFieldEnum[]
  }

  /**
   * aircraft_seatmap findMany
   */
  export type aircraft_seatmapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft_seatmap
     */
    select?: aircraft_seatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft_seatmap
     */
    omit?: aircraft_seatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraft_seatmapInclude<ExtArgs> | null
    /**
     * Filter, which aircraft_seatmaps to fetch.
     */
    where?: aircraft_seatmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aircraft_seatmaps to fetch.
     */
    orderBy?: aircraft_seatmapOrderByWithRelationInput | aircraft_seatmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aircraft_seatmaps.
     */
    cursor?: aircraft_seatmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aircraft_seatmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aircraft_seatmaps.
     */
    skip?: number
    distinct?: Aircraft_seatmapScalarFieldEnum | Aircraft_seatmapScalarFieldEnum[]
  }

  /**
   * aircraft_seatmap create
   */
  export type aircraft_seatmapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft_seatmap
     */
    select?: aircraft_seatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft_seatmap
     */
    omit?: aircraft_seatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraft_seatmapInclude<ExtArgs> | null
    /**
     * The data needed to create a aircraft_seatmap.
     */
    data: XOR<aircraft_seatmapCreateInput, aircraft_seatmapUncheckedCreateInput>
  }

  /**
   * aircraft_seatmap createMany
   */
  export type aircraft_seatmapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many aircraft_seatmaps.
     */
    data: aircraft_seatmapCreateManyInput | aircraft_seatmapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aircraft_seatmap update
   */
  export type aircraft_seatmapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft_seatmap
     */
    select?: aircraft_seatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft_seatmap
     */
    omit?: aircraft_seatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraft_seatmapInclude<ExtArgs> | null
    /**
     * The data needed to update a aircraft_seatmap.
     */
    data: XOR<aircraft_seatmapUpdateInput, aircraft_seatmapUncheckedUpdateInput>
    /**
     * Choose, which aircraft_seatmap to update.
     */
    where: aircraft_seatmapWhereUniqueInput
  }

  /**
   * aircraft_seatmap updateMany
   */
  export type aircraft_seatmapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update aircraft_seatmaps.
     */
    data: XOR<aircraft_seatmapUpdateManyMutationInput, aircraft_seatmapUncheckedUpdateManyInput>
    /**
     * Filter which aircraft_seatmaps to update
     */
    where?: aircraft_seatmapWhereInput
    /**
     * Limit how many aircraft_seatmaps to update.
     */
    limit?: number
  }

  /**
   * aircraft_seatmap upsert
   */
  export type aircraft_seatmapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft_seatmap
     */
    select?: aircraft_seatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft_seatmap
     */
    omit?: aircraft_seatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraft_seatmapInclude<ExtArgs> | null
    /**
     * The filter to search for the aircraft_seatmap to update in case it exists.
     */
    where: aircraft_seatmapWhereUniqueInput
    /**
     * In case the aircraft_seatmap found by the `where` argument doesn't exist, create a new aircraft_seatmap with this data.
     */
    create: XOR<aircraft_seatmapCreateInput, aircraft_seatmapUncheckedCreateInput>
    /**
     * In case the aircraft_seatmap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aircraft_seatmapUpdateInput, aircraft_seatmapUncheckedUpdateInput>
  }

  /**
   * aircraft_seatmap delete
   */
  export type aircraft_seatmapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft_seatmap
     */
    select?: aircraft_seatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft_seatmap
     */
    omit?: aircraft_seatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraft_seatmapInclude<ExtArgs> | null
    /**
     * Filter which aircraft_seatmap to delete.
     */
    where: aircraft_seatmapWhereUniqueInput
  }

  /**
   * aircraft_seatmap deleteMany
   */
  export type aircraft_seatmapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aircraft_seatmaps to delete
     */
    where?: aircraft_seatmapWhereInput
    /**
     * Limit how many aircraft_seatmaps to delete.
     */
    limit?: number
  }

  /**
   * aircraft_seatmap without action
   */
  export type aircraft_seatmapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft_seatmap
     */
    select?: aircraft_seatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft_seatmap
     */
    omit?: aircraft_seatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraft_seatmapInclude<ExtArgs> | null
  }


  /**
   * Model seatmap_info
   */

  export type AggregateSeatmap_info = {
    _count: Seatmap_infoCountAggregateOutputType | null
    _min: Seatmap_infoMinAggregateOutputType | null
    _max: Seatmap_infoMaxAggregateOutputType | null
  }

  export type Seatmap_infoMinAggregateOutputType = {
    seatMapId: string | null
    airlineCode: string | null
    aircraftModel: string | null
    version: string | null
  }

  export type Seatmap_infoMaxAggregateOutputType = {
    seatMapId: string | null
    airlineCode: string | null
    aircraftModel: string | null
    version: string | null
  }

  export type Seatmap_infoCountAggregateOutputType = {
    seatMapId: number
    airlineCode: number
    aircraftModel: number
    version: number
    _all: number
  }


  export type Seatmap_infoMinAggregateInputType = {
    seatMapId?: true
    airlineCode?: true
    aircraftModel?: true
    version?: true
  }

  export type Seatmap_infoMaxAggregateInputType = {
    seatMapId?: true
    airlineCode?: true
    aircraftModel?: true
    version?: true
  }

  export type Seatmap_infoCountAggregateInputType = {
    seatMapId?: true
    airlineCode?: true
    aircraftModel?: true
    version?: true
    _all?: true
  }

  export type Seatmap_infoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seatmap_info to aggregate.
     */
    where?: seatmap_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seatmap_infos to fetch.
     */
    orderBy?: seatmap_infoOrderByWithRelationInput | seatmap_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: seatmap_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seatmap_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seatmap_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned seatmap_infos
    **/
    _count?: true | Seatmap_infoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Seatmap_infoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Seatmap_infoMaxAggregateInputType
  }

  export type GetSeatmap_infoAggregateType<T extends Seatmap_infoAggregateArgs> = {
        [P in keyof T & keyof AggregateSeatmap_info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeatmap_info[P]>
      : GetScalarType<T[P], AggregateSeatmap_info[P]>
  }




  export type seatmap_infoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seatmap_infoWhereInput
    orderBy?: seatmap_infoOrderByWithAggregationInput | seatmap_infoOrderByWithAggregationInput[]
    by: Seatmap_infoScalarFieldEnum[] | Seatmap_infoScalarFieldEnum
    having?: seatmap_infoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Seatmap_infoCountAggregateInputType | true
    _min?: Seatmap_infoMinAggregateInputType
    _max?: Seatmap_infoMaxAggregateInputType
  }

  export type Seatmap_infoGroupByOutputType = {
    seatMapId: string
    airlineCode: string
    aircraftModel: string
    version: string
    _count: Seatmap_infoCountAggregateOutputType | null
    _min: Seatmap_infoMinAggregateOutputType | null
    _max: Seatmap_infoMaxAggregateOutputType | null
  }

  type GetSeatmap_infoGroupByPayload<T extends seatmap_infoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Seatmap_infoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Seatmap_infoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Seatmap_infoGroupByOutputType[P]>
            : GetScalarType<T[P], Seatmap_infoGroupByOutputType[P]>
        }
      >
    >


  export type seatmap_infoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seatMapId?: boolean
    airlineCode?: boolean
    aircraftModel?: boolean
    version?: boolean
    seat?: boolean | seatmap_info$seatArgs<ExtArgs>
    aircraft?: boolean | seatmap_info$aircraftArgs<ExtArgs>
    _count?: boolean | Seatmap_infoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatmap_info"]>



  export type seatmap_infoSelectScalar = {
    seatMapId?: boolean
    airlineCode?: boolean
    aircraftModel?: boolean
    version?: boolean
  }

  export type seatmap_infoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"seatMapId" | "airlineCode" | "aircraftModel" | "version", ExtArgs["result"]["seatmap_info"]>
  export type seatmap_infoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seat?: boolean | seatmap_info$seatArgs<ExtArgs>
    aircraft?: boolean | seatmap_info$aircraftArgs<ExtArgs>
    _count?: boolean | Seatmap_infoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $seatmap_infoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "seatmap_info"
    objects: {
      seat: Prisma.$seatPayload<ExtArgs>[]
      aircraft: Prisma.$aircraft_seatmapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      seatMapId: string
      airlineCode: string
      aircraftModel: string
      version: string
    }, ExtArgs["result"]["seatmap_info"]>
    composites: {}
  }

  type seatmap_infoGetPayload<S extends boolean | null | undefined | seatmap_infoDefaultArgs> = $Result.GetResult<Prisma.$seatmap_infoPayload, S>

  type seatmap_infoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<seatmap_infoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Seatmap_infoCountAggregateInputType | true
    }

  export interface seatmap_infoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['seatmap_info'], meta: { name: 'seatmap_info' } }
    /**
     * Find zero or one Seatmap_info that matches the filter.
     * @param {seatmap_infoFindUniqueArgs} args - Arguments to find a Seatmap_info
     * @example
     * // Get one Seatmap_info
     * const seatmap_info = await prisma.seatmap_info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends seatmap_infoFindUniqueArgs>(args: SelectSubset<T, seatmap_infoFindUniqueArgs<ExtArgs>>): Prisma__seatmap_infoClient<$Result.GetResult<Prisma.$seatmap_infoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seatmap_info that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {seatmap_infoFindUniqueOrThrowArgs} args - Arguments to find a Seatmap_info
     * @example
     * // Get one Seatmap_info
     * const seatmap_info = await prisma.seatmap_info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends seatmap_infoFindUniqueOrThrowArgs>(args: SelectSubset<T, seatmap_infoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__seatmap_infoClient<$Result.GetResult<Prisma.$seatmap_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seatmap_info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatmap_infoFindFirstArgs} args - Arguments to find a Seatmap_info
     * @example
     * // Get one Seatmap_info
     * const seatmap_info = await prisma.seatmap_info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends seatmap_infoFindFirstArgs>(args?: SelectSubset<T, seatmap_infoFindFirstArgs<ExtArgs>>): Prisma__seatmap_infoClient<$Result.GetResult<Prisma.$seatmap_infoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seatmap_info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatmap_infoFindFirstOrThrowArgs} args - Arguments to find a Seatmap_info
     * @example
     * // Get one Seatmap_info
     * const seatmap_info = await prisma.seatmap_info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends seatmap_infoFindFirstOrThrowArgs>(args?: SelectSubset<T, seatmap_infoFindFirstOrThrowArgs<ExtArgs>>): Prisma__seatmap_infoClient<$Result.GetResult<Prisma.$seatmap_infoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seatmap_infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatmap_infoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seatmap_infos
     * const seatmap_infos = await prisma.seatmap_info.findMany()
     * 
     * // Get first 10 Seatmap_infos
     * const seatmap_infos = await prisma.seatmap_info.findMany({ take: 10 })
     * 
     * // Only select the `seatMapId`
     * const seatmap_infoWithSeatMapIdOnly = await prisma.seatmap_info.findMany({ select: { seatMapId: true } })
     * 
     */
    findMany<T extends seatmap_infoFindManyArgs>(args?: SelectSubset<T, seatmap_infoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seatmap_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seatmap_info.
     * @param {seatmap_infoCreateArgs} args - Arguments to create a Seatmap_info.
     * @example
     * // Create one Seatmap_info
     * const Seatmap_info = await prisma.seatmap_info.create({
     *   data: {
     *     // ... data to create a Seatmap_info
     *   }
     * })
     * 
     */
    create<T extends seatmap_infoCreateArgs>(args: SelectSubset<T, seatmap_infoCreateArgs<ExtArgs>>): Prisma__seatmap_infoClient<$Result.GetResult<Prisma.$seatmap_infoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seatmap_infos.
     * @param {seatmap_infoCreateManyArgs} args - Arguments to create many Seatmap_infos.
     * @example
     * // Create many Seatmap_infos
     * const seatmap_info = await prisma.seatmap_info.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends seatmap_infoCreateManyArgs>(args?: SelectSubset<T, seatmap_infoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Seatmap_info.
     * @param {seatmap_infoDeleteArgs} args - Arguments to delete one Seatmap_info.
     * @example
     * // Delete one Seatmap_info
     * const Seatmap_info = await prisma.seatmap_info.delete({
     *   where: {
     *     // ... filter to delete one Seatmap_info
     *   }
     * })
     * 
     */
    delete<T extends seatmap_infoDeleteArgs>(args: SelectSubset<T, seatmap_infoDeleteArgs<ExtArgs>>): Prisma__seatmap_infoClient<$Result.GetResult<Prisma.$seatmap_infoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seatmap_info.
     * @param {seatmap_infoUpdateArgs} args - Arguments to update one Seatmap_info.
     * @example
     * // Update one Seatmap_info
     * const seatmap_info = await prisma.seatmap_info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends seatmap_infoUpdateArgs>(args: SelectSubset<T, seatmap_infoUpdateArgs<ExtArgs>>): Prisma__seatmap_infoClient<$Result.GetResult<Prisma.$seatmap_infoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seatmap_infos.
     * @param {seatmap_infoDeleteManyArgs} args - Arguments to filter Seatmap_infos to delete.
     * @example
     * // Delete a few Seatmap_infos
     * const { count } = await prisma.seatmap_info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends seatmap_infoDeleteManyArgs>(args?: SelectSubset<T, seatmap_infoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seatmap_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatmap_infoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seatmap_infos
     * const seatmap_info = await prisma.seatmap_info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends seatmap_infoUpdateManyArgs>(args: SelectSubset<T, seatmap_infoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seatmap_info.
     * @param {seatmap_infoUpsertArgs} args - Arguments to update or create a Seatmap_info.
     * @example
     * // Update or create a Seatmap_info
     * const seatmap_info = await prisma.seatmap_info.upsert({
     *   create: {
     *     // ... data to create a Seatmap_info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seatmap_info we want to update
     *   }
     * })
     */
    upsert<T extends seatmap_infoUpsertArgs>(args: SelectSubset<T, seatmap_infoUpsertArgs<ExtArgs>>): Prisma__seatmap_infoClient<$Result.GetResult<Prisma.$seatmap_infoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seatmap_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatmap_infoCountArgs} args - Arguments to filter Seatmap_infos to count.
     * @example
     * // Count the number of Seatmap_infos
     * const count = await prisma.seatmap_info.count({
     *   where: {
     *     // ... the filter for the Seatmap_infos we want to count
     *   }
     * })
    **/
    count<T extends seatmap_infoCountArgs>(
      args?: Subset<T, seatmap_infoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Seatmap_infoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seatmap_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Seatmap_infoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Seatmap_infoAggregateArgs>(args: Subset<T, Seatmap_infoAggregateArgs>): Prisma.PrismaPromise<GetSeatmap_infoAggregateType<T>>

    /**
     * Group by Seatmap_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatmap_infoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends seatmap_infoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: seatmap_infoGroupByArgs['orderBy'] }
        : { orderBy?: seatmap_infoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, seatmap_infoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatmap_infoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the seatmap_info model
   */
  readonly fields: seatmap_infoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for seatmap_info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__seatmap_infoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seat<T extends seatmap_info$seatArgs<ExtArgs> = {}>(args?: Subset<T, seatmap_info$seatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aircraft<T extends seatmap_info$aircraftArgs<ExtArgs> = {}>(args?: Subset<T, seatmap_info$aircraftArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aircraft_seatmapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the seatmap_info model
   */
  interface seatmap_infoFieldRefs {
    readonly seatMapId: FieldRef<"seatmap_info", 'String'>
    readonly airlineCode: FieldRef<"seatmap_info", 'String'>
    readonly aircraftModel: FieldRef<"seatmap_info", 'String'>
    readonly version: FieldRef<"seatmap_info", 'String'>
  }
    

  // Custom InputTypes
  /**
   * seatmap_info findUnique
   */
  export type seatmap_infoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seatmap_info
     */
    select?: seatmap_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seatmap_info
     */
    omit?: seatmap_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatmap_infoInclude<ExtArgs> | null
    /**
     * Filter, which seatmap_info to fetch.
     */
    where: seatmap_infoWhereUniqueInput
  }

  /**
   * seatmap_info findUniqueOrThrow
   */
  export type seatmap_infoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seatmap_info
     */
    select?: seatmap_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seatmap_info
     */
    omit?: seatmap_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatmap_infoInclude<ExtArgs> | null
    /**
     * Filter, which seatmap_info to fetch.
     */
    where: seatmap_infoWhereUniqueInput
  }

  /**
   * seatmap_info findFirst
   */
  export type seatmap_infoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seatmap_info
     */
    select?: seatmap_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seatmap_info
     */
    omit?: seatmap_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatmap_infoInclude<ExtArgs> | null
    /**
     * Filter, which seatmap_info to fetch.
     */
    where?: seatmap_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seatmap_infos to fetch.
     */
    orderBy?: seatmap_infoOrderByWithRelationInput | seatmap_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seatmap_infos.
     */
    cursor?: seatmap_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seatmap_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seatmap_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seatmap_infos.
     */
    distinct?: Seatmap_infoScalarFieldEnum | Seatmap_infoScalarFieldEnum[]
  }

  /**
   * seatmap_info findFirstOrThrow
   */
  export type seatmap_infoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seatmap_info
     */
    select?: seatmap_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seatmap_info
     */
    omit?: seatmap_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatmap_infoInclude<ExtArgs> | null
    /**
     * Filter, which seatmap_info to fetch.
     */
    where?: seatmap_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seatmap_infos to fetch.
     */
    orderBy?: seatmap_infoOrderByWithRelationInput | seatmap_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seatmap_infos.
     */
    cursor?: seatmap_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seatmap_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seatmap_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seatmap_infos.
     */
    distinct?: Seatmap_infoScalarFieldEnum | Seatmap_infoScalarFieldEnum[]
  }

  /**
   * seatmap_info findMany
   */
  export type seatmap_infoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seatmap_info
     */
    select?: seatmap_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seatmap_info
     */
    omit?: seatmap_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatmap_infoInclude<ExtArgs> | null
    /**
     * Filter, which seatmap_infos to fetch.
     */
    where?: seatmap_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seatmap_infos to fetch.
     */
    orderBy?: seatmap_infoOrderByWithRelationInput | seatmap_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing seatmap_infos.
     */
    cursor?: seatmap_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seatmap_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seatmap_infos.
     */
    skip?: number
    distinct?: Seatmap_infoScalarFieldEnum | Seatmap_infoScalarFieldEnum[]
  }

  /**
   * seatmap_info create
   */
  export type seatmap_infoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seatmap_info
     */
    select?: seatmap_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seatmap_info
     */
    omit?: seatmap_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatmap_infoInclude<ExtArgs> | null
    /**
     * The data needed to create a seatmap_info.
     */
    data: XOR<seatmap_infoCreateInput, seatmap_infoUncheckedCreateInput>
  }

  /**
   * seatmap_info createMany
   */
  export type seatmap_infoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many seatmap_infos.
     */
    data: seatmap_infoCreateManyInput | seatmap_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * seatmap_info update
   */
  export type seatmap_infoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seatmap_info
     */
    select?: seatmap_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seatmap_info
     */
    omit?: seatmap_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatmap_infoInclude<ExtArgs> | null
    /**
     * The data needed to update a seatmap_info.
     */
    data: XOR<seatmap_infoUpdateInput, seatmap_infoUncheckedUpdateInput>
    /**
     * Choose, which seatmap_info to update.
     */
    where: seatmap_infoWhereUniqueInput
  }

  /**
   * seatmap_info updateMany
   */
  export type seatmap_infoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update seatmap_infos.
     */
    data: XOR<seatmap_infoUpdateManyMutationInput, seatmap_infoUncheckedUpdateManyInput>
    /**
     * Filter which seatmap_infos to update
     */
    where?: seatmap_infoWhereInput
    /**
     * Limit how many seatmap_infos to update.
     */
    limit?: number
  }

  /**
   * seatmap_info upsert
   */
  export type seatmap_infoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seatmap_info
     */
    select?: seatmap_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seatmap_info
     */
    omit?: seatmap_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatmap_infoInclude<ExtArgs> | null
    /**
     * The filter to search for the seatmap_info to update in case it exists.
     */
    where: seatmap_infoWhereUniqueInput
    /**
     * In case the seatmap_info found by the `where` argument doesn't exist, create a new seatmap_info with this data.
     */
    create: XOR<seatmap_infoCreateInput, seatmap_infoUncheckedCreateInput>
    /**
     * In case the seatmap_info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<seatmap_infoUpdateInput, seatmap_infoUncheckedUpdateInput>
  }

  /**
   * seatmap_info delete
   */
  export type seatmap_infoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seatmap_info
     */
    select?: seatmap_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seatmap_info
     */
    omit?: seatmap_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatmap_infoInclude<ExtArgs> | null
    /**
     * Filter which seatmap_info to delete.
     */
    where: seatmap_infoWhereUniqueInput
  }

  /**
   * seatmap_info deleteMany
   */
  export type seatmap_infoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seatmap_infos to delete
     */
    where?: seatmap_infoWhereInput
    /**
     * Limit how many seatmap_infos to delete.
     */
    limit?: number
  }

  /**
   * seatmap_info.seat
   */
  export type seatmap_info$seatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    where?: seatWhereInput
    orderBy?: seatOrderByWithRelationInput | seatOrderByWithRelationInput[]
    cursor?: seatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * seatmap_info.aircraft
   */
  export type seatmap_info$aircraftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aircraft_seatmap
     */
    select?: aircraft_seatmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aircraft_seatmap
     */
    omit?: aircraft_seatmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aircraft_seatmapInclude<ExtArgs> | null
    where?: aircraft_seatmapWhereInput
    orderBy?: aircraft_seatmapOrderByWithRelationInput | aircraft_seatmapOrderByWithRelationInput[]
    cursor?: aircraft_seatmapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Aircraft_seatmapScalarFieldEnum | Aircraft_seatmapScalarFieldEnum[]
  }

  /**
   * seatmap_info without action
   */
  export type seatmap_infoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seatmap_info
     */
    select?: seatmap_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seatmap_info
     */
    omit?: seatmap_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatmap_infoInclude<ExtArgs> | null
  }


  /**
   * Model seat
   */

  export type AggregateSeat = {
    _count: SeatCountAggregateOutputType | null
    _avg: SeatAvgAggregateOutputType | null
    _sum: SeatSumAggregateOutputType | null
    _min: SeatMinAggregateOutputType | null
    _max: SeatMaxAggregateOutputType | null
  }

  export type SeatAvgAggregateOutputType = {
    row: number | null
    price: number | null
    floor: number | null
  }

  export type SeatSumAggregateOutputType = {
    row: number | null
    price: number | null
    floor: number | null
  }

  export type SeatMinAggregateOutputType = {
    seatMapId: string | null
    seatId: string | null
    seatNum: string | null
    row: number | null
    class: $Enums.SeatClass | null
    price: number | null
    features: string | null
    floor: number | null
  }

  export type SeatMaxAggregateOutputType = {
    seatMapId: string | null
    seatId: string | null
    seatNum: string | null
    row: number | null
    class: $Enums.SeatClass | null
    price: number | null
    features: string | null
    floor: number | null
  }

  export type SeatCountAggregateOutputType = {
    seatMapId: number
    seatId: number
    seatNum: number
    row: number
    class: number
    price: number
    features: number
    floor: number
    _all: number
  }


  export type SeatAvgAggregateInputType = {
    row?: true
    price?: true
    floor?: true
  }

  export type SeatSumAggregateInputType = {
    row?: true
    price?: true
    floor?: true
  }

  export type SeatMinAggregateInputType = {
    seatMapId?: true
    seatId?: true
    seatNum?: true
    row?: true
    class?: true
    price?: true
    features?: true
    floor?: true
  }

  export type SeatMaxAggregateInputType = {
    seatMapId?: true
    seatId?: true
    seatNum?: true
    row?: true
    class?: true
    price?: true
    features?: true
    floor?: true
  }

  export type SeatCountAggregateInputType = {
    seatMapId?: true
    seatId?: true
    seatNum?: true
    row?: true
    class?: true
    price?: true
    features?: true
    floor?: true
    _all?: true
  }

  export type SeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seat to aggregate.
     */
    where?: seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seats to fetch.
     */
    orderBy?: seatOrderByWithRelationInput | seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned seats
    **/
    _count?: true | SeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeatMaxAggregateInputType
  }

  export type GetSeatAggregateType<T extends SeatAggregateArgs> = {
        [P in keyof T & keyof AggregateSeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeat[P]>
      : GetScalarType<T[P], AggregateSeat[P]>
  }




  export type seatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seatWhereInput
    orderBy?: seatOrderByWithAggregationInput | seatOrderByWithAggregationInput[]
    by: SeatScalarFieldEnum[] | SeatScalarFieldEnum
    having?: seatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeatCountAggregateInputType | true
    _avg?: SeatAvgAggregateInputType
    _sum?: SeatSumAggregateInputType
    _min?: SeatMinAggregateInputType
    _max?: SeatMaxAggregateInputType
  }

  export type SeatGroupByOutputType = {
    seatMapId: string
    seatId: string
    seatNum: string
    row: number
    class: $Enums.SeatClass
    price: number
    features: string
    floor: number
    _count: SeatCountAggregateOutputType | null
    _avg: SeatAvgAggregateOutputType | null
    _sum: SeatSumAggregateOutputType | null
    _min: SeatMinAggregateOutputType | null
    _max: SeatMaxAggregateOutputType | null
  }

  type GetSeatGroupByPayload<T extends seatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeatGroupByOutputType[P]>
            : GetScalarType<T[P], SeatGroupByOutputType[P]>
        }
      >
    >


  export type seatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seatMapId?: boolean
    seatId?: boolean
    seatNum?: boolean
    row?: boolean
    class?: boolean
    price?: boolean
    features?: boolean
    floor?: boolean
    tickets?: boolean | seat$ticketsArgs<ExtArgs>
    seatmap?: boolean | seatmap_infoDefaultArgs<ExtArgs>
    _count?: boolean | SeatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seat"]>



  export type seatSelectScalar = {
    seatMapId?: boolean
    seatId?: boolean
    seatNum?: boolean
    row?: boolean
    class?: boolean
    price?: boolean
    features?: boolean
    floor?: boolean
  }

  export type seatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"seatMapId" | "seatId" | "seatNum" | "row" | "class" | "price" | "features" | "floor", ExtArgs["result"]["seat"]>
  export type seatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | seat$ticketsArgs<ExtArgs>
    seatmap?: boolean | seatmap_infoDefaultArgs<ExtArgs>
    _count?: boolean | SeatCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $seatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "seat"
    objects: {
      tickets: Prisma.$ticketPayload<ExtArgs>[]
      seatmap: Prisma.$seatmap_infoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      seatMapId: string
      seatId: string
      seatNum: string
      row: number
      class: $Enums.SeatClass
      price: number
      features: string
      floor: number
    }, ExtArgs["result"]["seat"]>
    composites: {}
  }

  type seatGetPayload<S extends boolean | null | undefined | seatDefaultArgs> = $Result.GetResult<Prisma.$seatPayload, S>

  type seatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<seatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeatCountAggregateInputType | true
    }

  export interface seatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['seat'], meta: { name: 'seat' } }
    /**
     * Find zero or one Seat that matches the filter.
     * @param {seatFindUniqueArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends seatFindUniqueArgs>(args: SelectSubset<T, seatFindUniqueArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {seatFindUniqueOrThrowArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends seatFindUniqueOrThrowArgs>(args: SelectSubset<T, seatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatFindFirstArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends seatFindFirstArgs>(args?: SelectSubset<T, seatFindFirstArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatFindFirstOrThrowArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends seatFindFirstOrThrowArgs>(args?: SelectSubset<T, seatFindFirstOrThrowArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seats
     * const seats = await prisma.seat.findMany()
     * 
     * // Get first 10 Seats
     * const seats = await prisma.seat.findMany({ take: 10 })
     * 
     * // Only select the `seatMapId`
     * const seatWithSeatMapIdOnly = await prisma.seat.findMany({ select: { seatMapId: true } })
     * 
     */
    findMany<T extends seatFindManyArgs>(args?: SelectSubset<T, seatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seat.
     * @param {seatCreateArgs} args - Arguments to create a Seat.
     * @example
     * // Create one Seat
     * const Seat = await prisma.seat.create({
     *   data: {
     *     // ... data to create a Seat
     *   }
     * })
     * 
     */
    create<T extends seatCreateArgs>(args: SelectSubset<T, seatCreateArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seats.
     * @param {seatCreateManyArgs} args - Arguments to create many Seats.
     * @example
     * // Create many Seats
     * const seat = await prisma.seat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends seatCreateManyArgs>(args?: SelectSubset<T, seatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Seat.
     * @param {seatDeleteArgs} args - Arguments to delete one Seat.
     * @example
     * // Delete one Seat
     * const Seat = await prisma.seat.delete({
     *   where: {
     *     // ... filter to delete one Seat
     *   }
     * })
     * 
     */
    delete<T extends seatDeleteArgs>(args: SelectSubset<T, seatDeleteArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seat.
     * @param {seatUpdateArgs} args - Arguments to update one Seat.
     * @example
     * // Update one Seat
     * const seat = await prisma.seat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends seatUpdateArgs>(args: SelectSubset<T, seatUpdateArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seats.
     * @param {seatDeleteManyArgs} args - Arguments to filter Seats to delete.
     * @example
     * // Delete a few Seats
     * const { count } = await prisma.seat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends seatDeleteManyArgs>(args?: SelectSubset<T, seatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seats
     * const seat = await prisma.seat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends seatUpdateManyArgs>(args: SelectSubset<T, seatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seat.
     * @param {seatUpsertArgs} args - Arguments to update or create a Seat.
     * @example
     * // Update or create a Seat
     * const seat = await prisma.seat.upsert({
     *   create: {
     *     // ... data to create a Seat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seat we want to update
     *   }
     * })
     */
    upsert<T extends seatUpsertArgs>(args: SelectSubset<T, seatUpsertArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatCountArgs} args - Arguments to filter Seats to count.
     * @example
     * // Count the number of Seats
     * const count = await prisma.seat.count({
     *   where: {
     *     // ... the filter for the Seats we want to count
     *   }
     * })
    **/
    count<T extends seatCountArgs>(
      args?: Subset<T, seatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeatAggregateArgs>(args: Subset<T, SeatAggregateArgs>): Prisma.PrismaPromise<GetSeatAggregateType<T>>

    /**
     * Group by Seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends seatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: seatGroupByArgs['orderBy'] }
        : { orderBy?: seatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, seatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the seat model
   */
  readonly fields: seatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for seat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__seatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tickets<T extends seat$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, seat$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seatmap<T extends seatmap_infoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, seatmap_infoDefaultArgs<ExtArgs>>): Prisma__seatmap_infoClient<$Result.GetResult<Prisma.$seatmap_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the seat model
   */
  interface seatFieldRefs {
    readonly seatMapId: FieldRef<"seat", 'String'>
    readonly seatId: FieldRef<"seat", 'String'>
    readonly seatNum: FieldRef<"seat", 'String'>
    readonly row: FieldRef<"seat", 'Int'>
    readonly class: FieldRef<"seat", 'SeatClass'>
    readonly price: FieldRef<"seat", 'Float'>
    readonly features: FieldRef<"seat", 'String'>
    readonly floor: FieldRef<"seat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * seat findUnique
   */
  export type seatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * Filter, which seat to fetch.
     */
    where: seatWhereUniqueInput
  }

  /**
   * seat findUniqueOrThrow
   */
  export type seatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * Filter, which seat to fetch.
     */
    where: seatWhereUniqueInput
  }

  /**
   * seat findFirst
   */
  export type seatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * Filter, which seat to fetch.
     */
    where?: seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seats to fetch.
     */
    orderBy?: seatOrderByWithRelationInput | seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seats.
     */
    cursor?: seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seats.
     */
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * seat findFirstOrThrow
   */
  export type seatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * Filter, which seat to fetch.
     */
    where?: seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seats to fetch.
     */
    orderBy?: seatOrderByWithRelationInput | seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seats.
     */
    cursor?: seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seats.
     */
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * seat findMany
   */
  export type seatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * Filter, which seats to fetch.
     */
    where?: seatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seats to fetch.
     */
    orderBy?: seatOrderByWithRelationInput | seatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing seats.
     */
    cursor?: seatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seats.
     */
    skip?: number
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * seat create
   */
  export type seatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * The data needed to create a seat.
     */
    data: XOR<seatCreateInput, seatUncheckedCreateInput>
  }

  /**
   * seat createMany
   */
  export type seatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many seats.
     */
    data: seatCreateManyInput | seatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * seat update
   */
  export type seatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * The data needed to update a seat.
     */
    data: XOR<seatUpdateInput, seatUncheckedUpdateInput>
    /**
     * Choose, which seat to update.
     */
    where: seatWhereUniqueInput
  }

  /**
   * seat updateMany
   */
  export type seatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update seats.
     */
    data: XOR<seatUpdateManyMutationInput, seatUncheckedUpdateManyInput>
    /**
     * Filter which seats to update
     */
    where?: seatWhereInput
    /**
     * Limit how many seats to update.
     */
    limit?: number
  }

  /**
   * seat upsert
   */
  export type seatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * The filter to search for the seat to update in case it exists.
     */
    where: seatWhereUniqueInput
    /**
     * In case the seat found by the `where` argument doesn't exist, create a new seat with this data.
     */
    create: XOR<seatCreateInput, seatUncheckedCreateInput>
    /**
     * In case the seat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<seatUpdateInput, seatUncheckedUpdateInput>
  }

  /**
   * seat delete
   */
  export type seatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
    /**
     * Filter which seat to delete.
     */
    where: seatWhereUniqueInput
  }

  /**
   * seat deleteMany
   */
  export type seatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seats to delete
     */
    where?: seatWhereInput
    /**
     * Limit how many seats to delete.
     */
    limit?: number
  }

  /**
   * seat.tickets
   */
  export type seat$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    where?: ticketWhereInput
    orderBy?: ticketOrderByWithRelationInput | ticketOrderByWithRelationInput[]
    cursor?: ticketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * seat without action
   */
  export type seatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seat
     */
    select?: seatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seat
     */
    omit?: seatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seatInclude<ExtArgs> | null
  }


  /**
   * Model ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    baggageAllowanceWeight: number | null
    baggageAllowancePrice: number | null
    mealPrice: number | null
    ticketPrice: number | null
  }

  export type TicketSumAggregateOutputType = {
    baggageAllowanceWeight: number | null
    baggageAllowancePrice: number | null
    mealPrice: number | null
    ticketPrice: number | null
  }

  export type TicketMinAggregateOutputType = {
    ticketNum: string | null
    farePackage: $Enums.FarePackage | null
    baggageAllowanceWeight: number | null
    baggageAllowancePrice: number | null
    mealSelection: string | null
    mealPrice: number | null
    ticketPrice: number | null
    bookingId: string | null
    flightId: string | null
    passportNum: string | null
    seatNum: string | null
  }

  export type TicketMaxAggregateOutputType = {
    ticketNum: string | null
    farePackage: $Enums.FarePackage | null
    baggageAllowanceWeight: number | null
    baggageAllowancePrice: number | null
    mealSelection: string | null
    mealPrice: number | null
    ticketPrice: number | null
    bookingId: string | null
    flightId: string | null
    passportNum: string | null
    seatNum: string | null
  }

  export type TicketCountAggregateOutputType = {
    ticketNum: number
    farePackage: number
    baggageAllowanceWeight: number
    baggageAllowancePrice: number
    mealSelection: number
    mealPrice: number
    ticketPrice: number
    bookingId: number
    flightId: number
    passportNum: number
    seatNum: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    baggageAllowanceWeight?: true
    baggageAllowancePrice?: true
    mealPrice?: true
    ticketPrice?: true
  }

  export type TicketSumAggregateInputType = {
    baggageAllowanceWeight?: true
    baggageAllowancePrice?: true
    mealPrice?: true
    ticketPrice?: true
  }

  export type TicketMinAggregateInputType = {
    ticketNum?: true
    farePackage?: true
    baggageAllowanceWeight?: true
    baggageAllowancePrice?: true
    mealSelection?: true
    mealPrice?: true
    ticketPrice?: true
    bookingId?: true
    flightId?: true
    passportNum?: true
    seatNum?: true
  }

  export type TicketMaxAggregateInputType = {
    ticketNum?: true
    farePackage?: true
    baggageAllowanceWeight?: true
    baggageAllowancePrice?: true
    mealSelection?: true
    mealPrice?: true
    ticketPrice?: true
    bookingId?: true
    flightId?: true
    passportNum?: true
    seatNum?: true
  }

  export type TicketCountAggregateInputType = {
    ticketNum?: true
    farePackage?: true
    baggageAllowanceWeight?: true
    baggageAllowancePrice?: true
    mealSelection?: true
    mealPrice?: true
    ticketPrice?: true
    bookingId?: true
    flightId?: true
    passportNum?: true
    seatNum?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ticket to aggregate.
     */
    where?: ticketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tickets to fetch.
     */
    orderBy?: ticketOrderByWithRelationInput | ticketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ticketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type ticketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ticketWhereInput
    orderBy?: ticketOrderByWithAggregationInput | ticketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: ticketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    ticketNum: string
    farePackage: $Enums.FarePackage
    baggageAllowanceWeight: number
    baggageAllowancePrice: number
    mealSelection: string
    mealPrice: number
    ticketPrice: number
    bookingId: string
    flightId: string
    passportNum: string
    seatNum: string
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends ticketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type ticketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ticketNum?: boolean
    farePackage?: boolean
    baggageAllowanceWeight?: boolean
    baggageAllowancePrice?: boolean
    mealSelection?: boolean
    mealPrice?: boolean
    ticketPrice?: boolean
    bookingId?: boolean
    flightId?: boolean
    passportNum?: boolean
    seatNum?: boolean
    booking?: boolean | bookingDefaultArgs<ExtArgs>
    passenger?: boolean | passengerDefaultArgs<ExtArgs>
    flight?: boolean | flightOperateDefaultArgs<ExtArgs>
    seat?: boolean | seatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>



  export type ticketSelectScalar = {
    ticketNum?: boolean
    farePackage?: boolean
    baggageAllowanceWeight?: boolean
    baggageAllowancePrice?: boolean
    mealSelection?: boolean
    mealPrice?: boolean
    ticketPrice?: boolean
    bookingId?: boolean
    flightId?: boolean
    passportNum?: boolean
    seatNum?: boolean
  }

  export type ticketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ticketNum" | "farePackage" | "baggageAllowanceWeight" | "baggageAllowancePrice" | "mealSelection" | "mealPrice" | "ticketPrice" | "bookingId" | "flightId" | "passportNum" | "seatNum", ExtArgs["result"]["ticket"]>
  export type ticketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingDefaultArgs<ExtArgs>
    passenger?: boolean | passengerDefaultArgs<ExtArgs>
    flight?: boolean | flightOperateDefaultArgs<ExtArgs>
    seat?: boolean | seatDefaultArgs<ExtArgs>
  }

  export type $ticketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ticket"
    objects: {
      booking: Prisma.$bookingPayload<ExtArgs>
      passenger: Prisma.$passengerPayload<ExtArgs>
      flight: Prisma.$flightOperatePayload<ExtArgs>
      seat: Prisma.$seatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ticketNum: string
      farePackage: $Enums.FarePackage
      baggageAllowanceWeight: number
      baggageAllowancePrice: number
      mealSelection: string
      mealPrice: number
      ticketPrice: number
      bookingId: string
      flightId: string
      passportNum: string
      seatNum: string
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type ticketGetPayload<S extends boolean | null | undefined | ticketDefaultArgs> = $Result.GetResult<Prisma.$ticketPayload, S>

  type ticketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ticketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface ticketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ticket'], meta: { name: 'ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {ticketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ticketFindUniqueArgs>(args: SelectSubset<T, ticketFindUniqueArgs<ExtArgs>>): Prisma__ticketClient<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ticketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ticketFindUniqueOrThrowArgs>(args: SelectSubset<T, ticketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ticketClient<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ticketFindFirstArgs>(args?: SelectSubset<T, ticketFindFirstArgs<ExtArgs>>): Prisma__ticketClient<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ticketFindFirstOrThrowArgs>(args?: SelectSubset<T, ticketFindFirstOrThrowArgs<ExtArgs>>): Prisma__ticketClient<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `ticketNum`
     * const ticketWithTicketNumOnly = await prisma.ticket.findMany({ select: { ticketNum: true } })
     * 
     */
    findMany<T extends ticketFindManyArgs>(args?: SelectSubset<T, ticketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {ticketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends ticketCreateArgs>(args: SelectSubset<T, ticketCreateArgs<ExtArgs>>): Prisma__ticketClient<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {ticketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ticketCreateManyArgs>(args?: SelectSubset<T, ticketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ticket.
     * @param {ticketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends ticketDeleteArgs>(args: SelectSubset<T, ticketDeleteArgs<ExtArgs>>): Prisma__ticketClient<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {ticketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ticketUpdateArgs>(args: SelectSubset<T, ticketUpdateArgs<ExtArgs>>): Prisma__ticketClient<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {ticketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ticketDeleteManyArgs>(args?: SelectSubset<T, ticketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ticketUpdateManyArgs>(args: SelectSubset<T, ticketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ticket.
     * @param {ticketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends ticketUpsertArgs>(args: SelectSubset<T, ticketUpsertArgs<ExtArgs>>): Prisma__ticketClient<$Result.GetResult<Prisma.$ticketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends ticketCountArgs>(
      args?: Subset<T, ticketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ticketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ticketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ticketGroupByArgs['orderBy'] }
        : { orderBy?: ticketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ticketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ticket model
   */
  readonly fields: ticketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ticketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends bookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingDefaultArgs<ExtArgs>>): Prisma__bookingClient<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    passenger<T extends passengerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, passengerDefaultArgs<ExtArgs>>): Prisma__passengerClient<$Result.GetResult<Prisma.$passengerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    flight<T extends flightOperateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, flightOperateDefaultArgs<ExtArgs>>): Prisma__flightOperateClient<$Result.GetResult<Prisma.$flightOperatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seat<T extends seatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, seatDefaultArgs<ExtArgs>>): Prisma__seatClient<$Result.GetResult<Prisma.$seatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ticket model
   */
  interface ticketFieldRefs {
    readonly ticketNum: FieldRef<"ticket", 'String'>
    readonly farePackage: FieldRef<"ticket", 'FarePackage'>
    readonly baggageAllowanceWeight: FieldRef<"ticket", 'Int'>
    readonly baggageAllowancePrice: FieldRef<"ticket", 'Float'>
    readonly mealSelection: FieldRef<"ticket", 'String'>
    readonly mealPrice: FieldRef<"ticket", 'Float'>
    readonly ticketPrice: FieldRef<"ticket", 'Float'>
    readonly bookingId: FieldRef<"ticket", 'String'>
    readonly flightId: FieldRef<"ticket", 'String'>
    readonly passportNum: FieldRef<"ticket", 'String'>
    readonly seatNum: FieldRef<"ticket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ticket findUnique
   */
  export type ticketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    /**
     * Filter, which ticket to fetch.
     */
    where: ticketWhereUniqueInput
  }

  /**
   * ticket findUniqueOrThrow
   */
  export type ticketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    /**
     * Filter, which ticket to fetch.
     */
    where: ticketWhereUniqueInput
  }

  /**
   * ticket findFirst
   */
  export type ticketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    /**
     * Filter, which ticket to fetch.
     */
    where?: ticketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tickets to fetch.
     */
    orderBy?: ticketOrderByWithRelationInput | ticketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tickets.
     */
    cursor?: ticketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * ticket findFirstOrThrow
   */
  export type ticketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    /**
     * Filter, which ticket to fetch.
     */
    where?: ticketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tickets to fetch.
     */
    orderBy?: ticketOrderByWithRelationInput | ticketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tickets.
     */
    cursor?: ticketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * ticket findMany
   */
  export type ticketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    /**
     * Filter, which tickets to fetch.
     */
    where?: ticketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tickets to fetch.
     */
    orderBy?: ticketOrderByWithRelationInput | ticketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tickets.
     */
    cursor?: ticketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * ticket create
   */
  export type ticketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    /**
     * The data needed to create a ticket.
     */
    data: XOR<ticketCreateInput, ticketUncheckedCreateInput>
  }

  /**
   * ticket createMany
   */
  export type ticketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tickets.
     */
    data: ticketCreateManyInput | ticketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ticket update
   */
  export type ticketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    /**
     * The data needed to update a ticket.
     */
    data: XOR<ticketUpdateInput, ticketUncheckedUpdateInput>
    /**
     * Choose, which ticket to update.
     */
    where: ticketWhereUniqueInput
  }

  /**
   * ticket updateMany
   */
  export type ticketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tickets.
     */
    data: XOR<ticketUpdateManyMutationInput, ticketUncheckedUpdateManyInput>
    /**
     * Filter which tickets to update
     */
    where?: ticketWhereInput
    /**
     * Limit how many tickets to update.
     */
    limit?: number
  }

  /**
   * ticket upsert
   */
  export type ticketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    /**
     * The filter to search for the ticket to update in case it exists.
     */
    where: ticketWhereUniqueInput
    /**
     * In case the ticket found by the `where` argument doesn't exist, create a new ticket with this data.
     */
    create: XOR<ticketCreateInput, ticketUncheckedCreateInput>
    /**
     * In case the ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ticketUpdateInput, ticketUncheckedUpdateInput>
  }

  /**
   * ticket delete
   */
  export type ticketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
    /**
     * Filter which ticket to delete.
     */
    where: ticketWhereUniqueInput
  }

  /**
   * ticket deleteMany
   */
  export type ticketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tickets to delete
     */
    where?: ticketWhereInput
    /**
     * Limit how many tickets to delete.
     */
    limit?: number
  }

  /**
   * ticket without action
   */
  export type ticketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ticket
     */
    select?: ticketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ticket
     */
    omit?: ticketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ticketInclude<ExtArgs> | null
  }


  /**
   * Model transit
   */

  export type AggregateTransit = {
    _count: TransitCountAggregateOutputType | null
    _min: TransitMinAggregateOutputType | null
    _max: TransitMaxAggregateOutputType | null
  }

  export type TransitMinAggregateOutputType = {
    flightNumFrom: string | null
    airlineCodeFrom: string | null
    flightNumTo: string | null
    airlineCodeTo: string | null
  }

  export type TransitMaxAggregateOutputType = {
    flightNumFrom: string | null
    airlineCodeFrom: string | null
    flightNumTo: string | null
    airlineCodeTo: string | null
  }

  export type TransitCountAggregateOutputType = {
    flightNumFrom: number
    airlineCodeFrom: number
    flightNumTo: number
    airlineCodeTo: number
    _all: number
  }


  export type TransitMinAggregateInputType = {
    flightNumFrom?: true
    airlineCodeFrom?: true
    flightNumTo?: true
    airlineCodeTo?: true
  }

  export type TransitMaxAggregateInputType = {
    flightNumFrom?: true
    airlineCodeFrom?: true
    flightNumTo?: true
    airlineCodeTo?: true
  }

  export type TransitCountAggregateInputType = {
    flightNumFrom?: true
    airlineCodeFrom?: true
    flightNumTo?: true
    airlineCodeTo?: true
    _all?: true
  }

  export type TransitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transit to aggregate.
     */
    where?: transitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transits to fetch.
     */
    orderBy?: transitOrderByWithRelationInput | transitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transits
    **/
    _count?: true | TransitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransitMaxAggregateInputType
  }

  export type GetTransitAggregateType<T extends TransitAggregateArgs> = {
        [P in keyof T & keyof AggregateTransit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransit[P]>
      : GetScalarType<T[P], AggregateTransit[P]>
  }




  export type transitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transitWhereInput
    orderBy?: transitOrderByWithAggregationInput | transitOrderByWithAggregationInput[]
    by: TransitScalarFieldEnum[] | TransitScalarFieldEnum
    having?: transitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransitCountAggregateInputType | true
    _min?: TransitMinAggregateInputType
    _max?: TransitMaxAggregateInputType
  }

  export type TransitGroupByOutputType = {
    flightNumFrom: string
    airlineCodeFrom: string
    flightNumTo: string
    airlineCodeTo: string
    _count: TransitCountAggregateOutputType | null
    _min: TransitMinAggregateOutputType | null
    _max: TransitMaxAggregateOutputType | null
  }

  type GetTransitGroupByPayload<T extends transitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransitGroupByOutputType[P]>
            : GetScalarType<T[P], TransitGroupByOutputType[P]>
        }
      >
    >


  export type transitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    flightNumFrom?: boolean
    airlineCodeFrom?: boolean
    flightNumTo?: boolean
    airlineCodeTo?: boolean
    from?: boolean | flightDefaultArgs<ExtArgs>
    to?: boolean | flightDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transit"]>



  export type transitSelectScalar = {
    flightNumFrom?: boolean
    airlineCodeFrom?: boolean
    flightNumTo?: boolean
    airlineCodeTo?: boolean
  }

  export type transitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"flightNumFrom" | "airlineCodeFrom" | "flightNumTo" | "airlineCodeTo", ExtArgs["result"]["transit"]>
  export type transitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    from?: boolean | flightDefaultArgs<ExtArgs>
    to?: boolean | flightDefaultArgs<ExtArgs>
  }

  export type $transitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transit"
    objects: {
      from: Prisma.$flightPayload<ExtArgs>
      to: Prisma.$flightPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      flightNumFrom: string
      airlineCodeFrom: string
      flightNumTo: string
      airlineCodeTo: string
    }, ExtArgs["result"]["transit"]>
    composites: {}
  }

  type transitGetPayload<S extends boolean | null | undefined | transitDefaultArgs> = $Result.GetResult<Prisma.$transitPayload, S>

  type transitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransitCountAggregateInputType | true
    }

  export interface transitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transit'], meta: { name: 'transit' } }
    /**
     * Find zero or one Transit that matches the filter.
     * @param {transitFindUniqueArgs} args - Arguments to find a Transit
     * @example
     * // Get one Transit
     * const transit = await prisma.transit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transitFindUniqueArgs>(args: SelectSubset<T, transitFindUniqueArgs<ExtArgs>>): Prisma__transitClient<$Result.GetResult<Prisma.$transitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transitFindUniqueOrThrowArgs} args - Arguments to find a Transit
     * @example
     * // Get one Transit
     * const transit = await prisma.transit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transitFindUniqueOrThrowArgs>(args: SelectSubset<T, transitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transitClient<$Result.GetResult<Prisma.$transitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transitFindFirstArgs} args - Arguments to find a Transit
     * @example
     * // Get one Transit
     * const transit = await prisma.transit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transitFindFirstArgs>(args?: SelectSubset<T, transitFindFirstArgs<ExtArgs>>): Prisma__transitClient<$Result.GetResult<Prisma.$transitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transitFindFirstOrThrowArgs} args - Arguments to find a Transit
     * @example
     * // Get one Transit
     * const transit = await prisma.transit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transitFindFirstOrThrowArgs>(args?: SelectSubset<T, transitFindFirstOrThrowArgs<ExtArgs>>): Prisma__transitClient<$Result.GetResult<Prisma.$transitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transits
     * const transits = await prisma.transit.findMany()
     * 
     * // Get first 10 Transits
     * const transits = await prisma.transit.findMany({ take: 10 })
     * 
     * // Only select the `flightNumFrom`
     * const transitWithFlightNumFromOnly = await prisma.transit.findMany({ select: { flightNumFrom: true } })
     * 
     */
    findMany<T extends transitFindManyArgs>(args?: SelectSubset<T, transitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transit.
     * @param {transitCreateArgs} args - Arguments to create a Transit.
     * @example
     * // Create one Transit
     * const Transit = await prisma.transit.create({
     *   data: {
     *     // ... data to create a Transit
     *   }
     * })
     * 
     */
    create<T extends transitCreateArgs>(args: SelectSubset<T, transitCreateArgs<ExtArgs>>): Prisma__transitClient<$Result.GetResult<Prisma.$transitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transits.
     * @param {transitCreateManyArgs} args - Arguments to create many Transits.
     * @example
     * // Create many Transits
     * const transit = await prisma.transit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transitCreateManyArgs>(args?: SelectSubset<T, transitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transit.
     * @param {transitDeleteArgs} args - Arguments to delete one Transit.
     * @example
     * // Delete one Transit
     * const Transit = await prisma.transit.delete({
     *   where: {
     *     // ... filter to delete one Transit
     *   }
     * })
     * 
     */
    delete<T extends transitDeleteArgs>(args: SelectSubset<T, transitDeleteArgs<ExtArgs>>): Prisma__transitClient<$Result.GetResult<Prisma.$transitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transit.
     * @param {transitUpdateArgs} args - Arguments to update one Transit.
     * @example
     * // Update one Transit
     * const transit = await prisma.transit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transitUpdateArgs>(args: SelectSubset<T, transitUpdateArgs<ExtArgs>>): Prisma__transitClient<$Result.GetResult<Prisma.$transitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transits.
     * @param {transitDeleteManyArgs} args - Arguments to filter Transits to delete.
     * @example
     * // Delete a few Transits
     * const { count } = await prisma.transit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transitDeleteManyArgs>(args?: SelectSubset<T, transitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transits
     * const transit = await prisma.transit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transitUpdateManyArgs>(args: SelectSubset<T, transitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transit.
     * @param {transitUpsertArgs} args - Arguments to update or create a Transit.
     * @example
     * // Update or create a Transit
     * const transit = await prisma.transit.upsert({
     *   create: {
     *     // ... data to create a Transit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transit we want to update
     *   }
     * })
     */
    upsert<T extends transitUpsertArgs>(args: SelectSubset<T, transitUpsertArgs<ExtArgs>>): Prisma__transitClient<$Result.GetResult<Prisma.$transitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transitCountArgs} args - Arguments to filter Transits to count.
     * @example
     * // Count the number of Transits
     * const count = await prisma.transit.count({
     *   where: {
     *     // ... the filter for the Transits we want to count
     *   }
     * })
    **/
    count<T extends transitCountArgs>(
      args?: Subset<T, transitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransitAggregateArgs>(args: Subset<T, TransitAggregateArgs>): Prisma.PrismaPromise<GetTransitAggregateType<T>>

    /**
     * Group by Transit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transitGroupByArgs['orderBy'] }
        : { orderBy?: transitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transit model
   */
  readonly fields: transitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    from<T extends flightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, flightDefaultArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    to<T extends flightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, flightDefaultArgs<ExtArgs>>): Prisma__flightClient<$Result.GetResult<Prisma.$flightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transit model
   */
  interface transitFieldRefs {
    readonly flightNumFrom: FieldRef<"transit", 'String'>
    readonly airlineCodeFrom: FieldRef<"transit", 'String'>
    readonly flightNumTo: FieldRef<"transit", 'String'>
    readonly airlineCodeTo: FieldRef<"transit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * transit findUnique
   */
  export type transitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transit
     */
    select?: transitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transit
     */
    omit?: transitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transitInclude<ExtArgs> | null
    /**
     * Filter, which transit to fetch.
     */
    where: transitWhereUniqueInput
  }

  /**
   * transit findUniqueOrThrow
   */
  export type transitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transit
     */
    select?: transitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transit
     */
    omit?: transitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transitInclude<ExtArgs> | null
    /**
     * Filter, which transit to fetch.
     */
    where: transitWhereUniqueInput
  }

  /**
   * transit findFirst
   */
  export type transitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transit
     */
    select?: transitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transit
     */
    omit?: transitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transitInclude<ExtArgs> | null
    /**
     * Filter, which transit to fetch.
     */
    where?: transitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transits to fetch.
     */
    orderBy?: transitOrderByWithRelationInput | transitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transits.
     */
    cursor?: transitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transits.
     */
    distinct?: TransitScalarFieldEnum | TransitScalarFieldEnum[]
  }

  /**
   * transit findFirstOrThrow
   */
  export type transitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transit
     */
    select?: transitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transit
     */
    omit?: transitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transitInclude<ExtArgs> | null
    /**
     * Filter, which transit to fetch.
     */
    where?: transitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transits to fetch.
     */
    orderBy?: transitOrderByWithRelationInput | transitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transits.
     */
    cursor?: transitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transits.
     */
    distinct?: TransitScalarFieldEnum | TransitScalarFieldEnum[]
  }

  /**
   * transit findMany
   */
  export type transitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transit
     */
    select?: transitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transit
     */
    omit?: transitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transitInclude<ExtArgs> | null
    /**
     * Filter, which transits to fetch.
     */
    where?: transitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transits to fetch.
     */
    orderBy?: transitOrderByWithRelationInput | transitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transits.
     */
    cursor?: transitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transits.
     */
    skip?: number
    distinct?: TransitScalarFieldEnum | TransitScalarFieldEnum[]
  }

  /**
   * transit create
   */
  export type transitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transit
     */
    select?: transitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transit
     */
    omit?: transitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transitInclude<ExtArgs> | null
    /**
     * The data needed to create a transit.
     */
    data: XOR<transitCreateInput, transitUncheckedCreateInput>
  }

  /**
   * transit createMany
   */
  export type transitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transits.
     */
    data: transitCreateManyInput | transitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transit update
   */
  export type transitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transit
     */
    select?: transitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transit
     */
    omit?: transitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transitInclude<ExtArgs> | null
    /**
     * The data needed to update a transit.
     */
    data: XOR<transitUpdateInput, transitUncheckedUpdateInput>
    /**
     * Choose, which transit to update.
     */
    where: transitWhereUniqueInput
  }

  /**
   * transit updateMany
   */
  export type transitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transits.
     */
    data: XOR<transitUpdateManyMutationInput, transitUncheckedUpdateManyInput>
    /**
     * Filter which transits to update
     */
    where?: transitWhereInput
    /**
     * Limit how many transits to update.
     */
    limit?: number
  }

  /**
   * transit upsert
   */
  export type transitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transit
     */
    select?: transitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transit
     */
    omit?: transitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transitInclude<ExtArgs> | null
    /**
     * The filter to search for the transit to update in case it exists.
     */
    where: transitWhereUniqueInput
    /**
     * In case the transit found by the `where` argument doesn't exist, create a new transit with this data.
     */
    create: XOR<transitCreateInput, transitUncheckedCreateInput>
    /**
     * In case the transit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transitUpdateInput, transitUncheckedUpdateInput>
  }

  /**
   * transit delete
   */
  export type transitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transit
     */
    select?: transitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transit
     */
    omit?: transitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transitInclude<ExtArgs> | null
    /**
     * Filter which transit to delete.
     */
    where: transitWhereUniqueInput
  }

  /**
   * transit deleteMany
   */
  export type transitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transits to delete
     */
    where?: transitWhereInput
    /**
     * Limit how many transits to delete.
     */
    limit?: number
  }

  /**
   * transit without action
   */
  export type transitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transit
     */
    select?: transitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transit
     */
    omit?: transitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transitInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    uuid: string | null
    password: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    phone: string | null
    registerDate: Date | null
  }

  export type UserMaxAggregateOutputType = {
    uuid: string | null
    password: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    phone: string | null
    registerDate: Date | null
  }

  export type UserCountAggregateOutputType = {
    uuid: number
    password: number
    firstname: number
    lastname: number
    email: number
    phone: number
    registerDate: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    uuid?: true
    password?: true
    firstname?: true
    lastname?: true
    email?: true
    phone?: true
    registerDate?: true
  }

  export type UserMaxAggregateInputType = {
    uuid?: true
    password?: true
    firstname?: true
    lastname?: true
    email?: true
    phone?: true
    registerDate?: true
  }

  export type UserCountAggregateInputType = {
    uuid?: true
    password?: true
    firstname?: true
    lastname?: true
    email?: true
    phone?: true
    registerDate?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    uuid: string
    password: string
    firstname: string
    lastname: string
    email: string
    phone: string
    registerDate: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uuid?: boolean
    password?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    phone?: boolean
    registerDate?: boolean
    bookings?: boolean | user$bookingsArgs<ExtArgs>
    passengers?: boolean | user$passengersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    uuid?: boolean
    password?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    phone?: boolean
    registerDate?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uuid" | "password" | "firstname" | "lastname" | "email" | "phone" | "registerDate", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | user$bookingsArgs<ExtArgs>
    passengers?: boolean | user$passengersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      bookings: Prisma.$bookingPayload<ExtArgs>[]
      passengers: Prisma.$passengerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      uuid: string
      password: string
      firstname: string
      lastname: string
      email: string
      phone: string
      registerDate: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `uuid`
     * const userWithUuidOnly = await prisma.user.findMany({ select: { uuid: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends user$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, user$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passengers<T extends user$passengersArgs<ExtArgs> = {}>(args?: Subset<T, user$passengersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly uuid: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly firstname: FieldRef<"user", 'String'>
    readonly lastname: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly phone: FieldRef<"user", 'String'>
    readonly registerDate: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.bookings
   */
  export type user$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking
     */
    select?: bookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the booking
     */
    omit?: bookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingInclude<ExtArgs> | null
    where?: bookingWhereInput
    orderBy?: bookingOrderByWithRelationInput | bookingOrderByWithRelationInput[]
    cursor?: bookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * user.passengers
   */
  export type user$passengersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passenger
     */
    select?: passengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passenger
     */
    omit?: passengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passengerInclude<ExtArgs> | null
    where?: passengerWhereInput
    orderBy?: passengerOrderByWithRelationInput | passengerOrderByWithRelationInput[]
    cursor?: passengerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    fullname: 'fullname',
    permission: 'permission'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AirlineScalarFieldEnum: {
    airlineCode: 'airlineCode',
    airlineName: 'airlineName'
  };

  export type AirlineScalarFieldEnum = (typeof AirlineScalarFieldEnum)[keyof typeof AirlineScalarFieldEnum]


  export const AircraftScalarFieldEnum: {
    aircraftId: 'aircraftId',
    ownerAirlineCode: 'ownerAirlineCode',
    model: 'model'
  };

  export type AircraftScalarFieldEnum = (typeof AircraftScalarFieldEnum)[keyof typeof AircraftScalarFieldEnum]


  export const AircraftCostScalarFieldEnum: {
    model: 'model',
    ownerAirlineCode: 'ownerAirlineCode',
    costPerMile: 'costPerMile'
  };

  export type AircraftCostScalarFieldEnum = (typeof AircraftCostScalarFieldEnum)[keyof typeof AircraftCostScalarFieldEnum]


  export const AirportScalarFieldEnum: {
    airportCode: 'airportCode',
    name: 'name',
    country: 'country',
    city: 'city',
    timezone: 'timezone',
    latitude: 'latitude',
    longitude: 'longitude',
    altitude: 'altitude'
  };

  export type AirportScalarFieldEnum = (typeof AirportScalarFieldEnum)[keyof typeof AirportScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    bookingId: 'bookingId',
    bookingDate: 'bookingDate',
    status: 'status',
    userId: 'userId'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const Booking_flightScalarFieldEnum: {
    bookingId: 'bookingId',
    flightId: 'flightId'
  };

  export type Booking_flightScalarFieldEnum = (typeof Booking_flightScalarFieldEnum)[keyof typeof Booking_flightScalarFieldEnum]


  export const FlightScalarFieldEnum: {
    flightNum: 'flightNum',
    airlineCode: 'airlineCode',
    departAirportId: 'departAirportId',
    arriveAirportId: 'arriveAirportId'
  };

  export type FlightScalarFieldEnum = (typeof FlightScalarFieldEnum)[keyof typeof FlightScalarFieldEnum]


  export const FlightOperateScalarFieldEnum: {
    flightId: 'flightId',
    flightNum: 'flightNum',
    airlineCode: 'airlineCode',
    departureTime: 'departureTime',
    arrivalTime: 'arrivalTime',
    departureGate: 'departureGate',
    aircraftId: 'aircraftId'
  };

  export type FlightOperateScalarFieldEnum = (typeof FlightOperateScalarFieldEnum)[keyof typeof FlightOperateScalarFieldEnum]


  export const PassengerScalarFieldEnum: {
    passportNum: 'passportNum',
    passportCountry: 'passportCountry',
    passportExpiry: 'passportExpiry',
    firstName: 'firstName',
    lastName: 'lastName',
    dateOfBirth: 'dateOfBirth',
    nationality: 'nationality',
    ageRange: 'ageRange',
    userId: 'userId'
  };

  export type PassengerScalarFieldEnum = (typeof PassengerScalarFieldEnum)[keyof typeof PassengerScalarFieldEnum]


  export const Passenger_bookingScalarFieldEnum: {
    bookingId: 'bookingId',
    passportNum: 'passportNum'
  };

  export type Passenger_bookingScalarFieldEnum = (typeof Passenger_bookingScalarFieldEnum)[keyof typeof Passenger_bookingScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    paymentId: 'paymentId',
    amount: 'amount',
    method: 'method',
    paymentDate: 'paymentDate',
    bookingId: 'bookingId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const Aircraft_seatmapScalarFieldEnum: {
    aircraftId: 'aircraftId',
    seatMapId: 'seatMapId'
  };

  export type Aircraft_seatmapScalarFieldEnum = (typeof Aircraft_seatmapScalarFieldEnum)[keyof typeof Aircraft_seatmapScalarFieldEnum]


  export const Seatmap_infoScalarFieldEnum: {
    seatMapId: 'seatMapId',
    airlineCode: 'airlineCode',
    aircraftModel: 'aircraftModel',
    version: 'version'
  };

  export type Seatmap_infoScalarFieldEnum = (typeof Seatmap_infoScalarFieldEnum)[keyof typeof Seatmap_infoScalarFieldEnum]


  export const SeatScalarFieldEnum: {
    seatMapId: 'seatMapId',
    seatId: 'seatId',
    seatNum: 'seatNum',
    row: 'row',
    class: 'class',
    price: 'price',
    features: 'features',
    floor: 'floor'
  };

  export type SeatScalarFieldEnum = (typeof SeatScalarFieldEnum)[keyof typeof SeatScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    ticketNum: 'ticketNum',
    farePackage: 'farePackage',
    baggageAllowanceWeight: 'baggageAllowanceWeight',
    baggageAllowancePrice: 'baggageAllowancePrice',
    mealSelection: 'mealSelection',
    mealPrice: 'mealPrice',
    ticketPrice: 'ticketPrice',
    bookingId: 'bookingId',
    flightId: 'flightId',
    passportNum: 'passportNum',
    seatNum: 'seatNum'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TransitScalarFieldEnum: {
    flightNumFrom: 'flightNumFrom',
    airlineCodeFrom: 'airlineCodeFrom',
    flightNumTo: 'flightNumTo',
    airlineCodeTo: 'airlineCodeTo'
  };

  export type TransitScalarFieldEnum = (typeof TransitScalarFieldEnum)[keyof typeof TransitScalarFieldEnum]


  export const UserScalarFieldEnum: {
    uuid: 'uuid',
    password: 'password',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    phone: 'phone',
    registerDate: 'registerDate'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const adminOrderByRelevanceFieldEnum: {
    username: 'username',
    password: 'password',
    fullname: 'fullname'
  };

  export type adminOrderByRelevanceFieldEnum = (typeof adminOrderByRelevanceFieldEnum)[keyof typeof adminOrderByRelevanceFieldEnum]


  export const airlineOrderByRelevanceFieldEnum: {
    airlineCode: 'airlineCode',
    airlineName: 'airlineName'
  };

  export type airlineOrderByRelevanceFieldEnum = (typeof airlineOrderByRelevanceFieldEnum)[keyof typeof airlineOrderByRelevanceFieldEnum]


  export const aircraftOrderByRelevanceFieldEnum: {
    aircraftId: 'aircraftId',
    ownerAirlineCode: 'ownerAirlineCode',
    model: 'model'
  };

  export type aircraftOrderByRelevanceFieldEnum = (typeof aircraftOrderByRelevanceFieldEnum)[keyof typeof aircraftOrderByRelevanceFieldEnum]


  export const aircraftCostOrderByRelevanceFieldEnum: {
    model: 'model',
    ownerAirlineCode: 'ownerAirlineCode'
  };

  export type aircraftCostOrderByRelevanceFieldEnum = (typeof aircraftCostOrderByRelevanceFieldEnum)[keyof typeof aircraftCostOrderByRelevanceFieldEnum]


  export const airportOrderByRelevanceFieldEnum: {
    airportCode: 'airportCode',
    name: 'name',
    country: 'country',
    city: 'city',
    timezone: 'timezone'
  };

  export type airportOrderByRelevanceFieldEnum = (typeof airportOrderByRelevanceFieldEnum)[keyof typeof airportOrderByRelevanceFieldEnum]


  export const bookingOrderByRelevanceFieldEnum: {
    bookingId: 'bookingId',
    userId: 'userId'
  };

  export type bookingOrderByRelevanceFieldEnum = (typeof bookingOrderByRelevanceFieldEnum)[keyof typeof bookingOrderByRelevanceFieldEnum]


  export const booking_flightOrderByRelevanceFieldEnum: {
    bookingId: 'bookingId',
    flightId: 'flightId'
  };

  export type booking_flightOrderByRelevanceFieldEnum = (typeof booking_flightOrderByRelevanceFieldEnum)[keyof typeof booking_flightOrderByRelevanceFieldEnum]


  export const flightOrderByRelevanceFieldEnum: {
    flightNum: 'flightNum',
    airlineCode: 'airlineCode',
    departAirportId: 'departAirportId',
    arriveAirportId: 'arriveAirportId'
  };

  export type flightOrderByRelevanceFieldEnum = (typeof flightOrderByRelevanceFieldEnum)[keyof typeof flightOrderByRelevanceFieldEnum]


  export const flightOperateOrderByRelevanceFieldEnum: {
    flightId: 'flightId',
    flightNum: 'flightNum',
    airlineCode: 'airlineCode',
    departureGate: 'departureGate',
    aircraftId: 'aircraftId'
  };

  export type flightOperateOrderByRelevanceFieldEnum = (typeof flightOperateOrderByRelevanceFieldEnum)[keyof typeof flightOperateOrderByRelevanceFieldEnum]


  export const passengerOrderByRelevanceFieldEnum: {
    passportNum: 'passportNum',
    passportCountry: 'passportCountry',
    firstName: 'firstName',
    lastName: 'lastName',
    nationality: 'nationality',
    userId: 'userId'
  };

  export type passengerOrderByRelevanceFieldEnum = (typeof passengerOrderByRelevanceFieldEnum)[keyof typeof passengerOrderByRelevanceFieldEnum]


  export const passenger_bookingOrderByRelevanceFieldEnum: {
    bookingId: 'bookingId',
    passportNum: 'passportNum'
  };

  export type passenger_bookingOrderByRelevanceFieldEnum = (typeof passenger_bookingOrderByRelevanceFieldEnum)[keyof typeof passenger_bookingOrderByRelevanceFieldEnum]


  export const paymentOrderByRelevanceFieldEnum: {
    paymentId: 'paymentId',
    method: 'method',
    bookingId: 'bookingId'
  };

  export type paymentOrderByRelevanceFieldEnum = (typeof paymentOrderByRelevanceFieldEnum)[keyof typeof paymentOrderByRelevanceFieldEnum]


  export const aircraft_seatmapOrderByRelevanceFieldEnum: {
    aircraftId: 'aircraftId',
    seatMapId: 'seatMapId'
  };

  export type aircraft_seatmapOrderByRelevanceFieldEnum = (typeof aircraft_seatmapOrderByRelevanceFieldEnum)[keyof typeof aircraft_seatmapOrderByRelevanceFieldEnum]


  export const seatmap_infoOrderByRelevanceFieldEnum: {
    seatMapId: 'seatMapId',
    airlineCode: 'airlineCode',
    aircraftModel: 'aircraftModel',
    version: 'version'
  };

  export type seatmap_infoOrderByRelevanceFieldEnum = (typeof seatmap_infoOrderByRelevanceFieldEnum)[keyof typeof seatmap_infoOrderByRelevanceFieldEnum]


  export const seatOrderByRelevanceFieldEnum: {
    seatMapId: 'seatMapId',
    seatId: 'seatId',
    seatNum: 'seatNum',
    features: 'features'
  };

  export type seatOrderByRelevanceFieldEnum = (typeof seatOrderByRelevanceFieldEnum)[keyof typeof seatOrderByRelevanceFieldEnum]


  export const ticketOrderByRelevanceFieldEnum: {
    ticketNum: 'ticketNum',
    mealSelection: 'mealSelection',
    bookingId: 'bookingId',
    flightId: 'flightId',
    passportNum: 'passportNum',
    seatNum: 'seatNum'
  };

  export type ticketOrderByRelevanceFieldEnum = (typeof ticketOrderByRelevanceFieldEnum)[keyof typeof ticketOrderByRelevanceFieldEnum]


  export const transitOrderByRelevanceFieldEnum: {
    flightNumFrom: 'flightNumFrom',
    airlineCodeFrom: 'airlineCodeFrom',
    flightNumTo: 'flightNumTo',
    airlineCodeTo: 'airlineCodeTo'
  };

  export type transitOrderByRelevanceFieldEnum = (typeof transitOrderByRelevanceFieldEnum)[keyof typeof transitOrderByRelevanceFieldEnum]


  export const userOrderByRelevanceFieldEnum: {
    uuid: 'uuid',
    password: 'password',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    phone: 'phone'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Permission'
   */
  export type EnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'AgeRange'
   */
  export type EnumAgeRangeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgeRange'>
    


  /**
   * Reference to a field of type 'SeatClass'
   */
  export type EnumSeatClassFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeatClass'>
    


  /**
   * Reference to a field of type 'FarePackage'
   */
  export type EnumFarePackageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FarePackage'>
    
  /**
   * Deep Input Types
   */


  export type adminWhereInput = {
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    id?: IntFilter<"admin"> | number
    username?: StringFilter<"admin"> | string
    password?: StringFilter<"admin"> | string
    fullname?: StringNullableFilter<"admin"> | string | null
    permission?: EnumPermissionFilter<"admin"> | $Enums.Permission
  }

  export type adminOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    fullname?: SortOrderInput | SortOrder
    permission?: SortOrder
    _relevance?: adminOrderByRelevanceInput
  }

  export type adminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    username?: StringFilter<"admin"> | string
    password?: StringFilter<"admin"> | string
    fullname?: StringNullableFilter<"admin"> | string | null
    permission?: EnumPermissionFilter<"admin"> | $Enums.Permission
  }, "id">

  export type adminOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    fullname?: SortOrderInput | SortOrder
    permission?: SortOrder
    _count?: adminCountOrderByAggregateInput
    _avg?: adminAvgOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
    _sum?: adminSumOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    OR?: adminScalarWhereWithAggregatesInput[]
    NOT?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admin"> | number
    username?: StringWithAggregatesFilter<"admin"> | string
    password?: StringWithAggregatesFilter<"admin"> | string
    fullname?: StringNullableWithAggregatesFilter<"admin"> | string | null
    permission?: EnumPermissionWithAggregatesFilter<"admin"> | $Enums.Permission
  }

  export type airlineWhereInput = {
    AND?: airlineWhereInput | airlineWhereInput[]
    OR?: airlineWhereInput[]
    NOT?: airlineWhereInput | airlineWhereInput[]
    airlineCode?: StringFilter<"airline"> | string
    airlineName?: StringFilter<"airline"> | string
    aircraft?: AircraftListRelationFilter
    aircraftCost?: AircraftCostListRelationFilter
    flight?: FlightListRelationFilter
  }

  export type airlineOrderByWithRelationInput = {
    airlineCode?: SortOrder
    airlineName?: SortOrder
    aircraft?: aircraftOrderByRelationAggregateInput
    aircraftCost?: aircraftCostOrderByRelationAggregateInput
    flight?: flightOrderByRelationAggregateInput
    _relevance?: airlineOrderByRelevanceInput
  }

  export type airlineWhereUniqueInput = Prisma.AtLeast<{
    airlineCode?: string
    AND?: airlineWhereInput | airlineWhereInput[]
    OR?: airlineWhereInput[]
    NOT?: airlineWhereInput | airlineWhereInput[]
    airlineName?: StringFilter<"airline"> | string
    aircraft?: AircraftListRelationFilter
    aircraftCost?: AircraftCostListRelationFilter
    flight?: FlightListRelationFilter
  }, "airlineCode">

  export type airlineOrderByWithAggregationInput = {
    airlineCode?: SortOrder
    airlineName?: SortOrder
    _count?: airlineCountOrderByAggregateInput
    _max?: airlineMaxOrderByAggregateInput
    _min?: airlineMinOrderByAggregateInput
  }

  export type airlineScalarWhereWithAggregatesInput = {
    AND?: airlineScalarWhereWithAggregatesInput | airlineScalarWhereWithAggregatesInput[]
    OR?: airlineScalarWhereWithAggregatesInput[]
    NOT?: airlineScalarWhereWithAggregatesInput | airlineScalarWhereWithAggregatesInput[]
    airlineCode?: StringWithAggregatesFilter<"airline"> | string
    airlineName?: StringWithAggregatesFilter<"airline"> | string
  }

  export type aircraftWhereInput = {
    AND?: aircraftWhereInput | aircraftWhereInput[]
    OR?: aircraftWhereInput[]
    NOT?: aircraftWhereInput | aircraftWhereInput[]
    aircraftId?: StringFilter<"aircraft"> | string
    ownerAirlineCode?: StringFilter<"aircraft"> | string
    model?: StringFilter<"aircraft"> | string
    airline?: XOR<AirlineScalarRelationFilter, airlineWhereInput>
    flightOperate?: FlightOperateListRelationFilter
    aircraftSeatmap?: Aircraft_seatmapListRelationFilter
  }

  export type aircraftOrderByWithRelationInput = {
    aircraftId?: SortOrder
    ownerAirlineCode?: SortOrder
    model?: SortOrder
    airline?: airlineOrderByWithRelationInput
    flightOperate?: flightOperateOrderByRelationAggregateInput
    aircraftSeatmap?: aircraft_seatmapOrderByRelationAggregateInput
    _relevance?: aircraftOrderByRelevanceInput
  }

  export type aircraftWhereUniqueInput = Prisma.AtLeast<{
    aircraftId?: string
    AND?: aircraftWhereInput | aircraftWhereInput[]
    OR?: aircraftWhereInput[]
    NOT?: aircraftWhereInput | aircraftWhereInput[]
    ownerAirlineCode?: StringFilter<"aircraft"> | string
    model?: StringFilter<"aircraft"> | string
    airline?: XOR<AirlineScalarRelationFilter, airlineWhereInput>
    flightOperate?: FlightOperateListRelationFilter
    aircraftSeatmap?: Aircraft_seatmapListRelationFilter
  }, "aircraftId">

  export type aircraftOrderByWithAggregationInput = {
    aircraftId?: SortOrder
    ownerAirlineCode?: SortOrder
    model?: SortOrder
    _count?: aircraftCountOrderByAggregateInput
    _max?: aircraftMaxOrderByAggregateInput
    _min?: aircraftMinOrderByAggregateInput
  }

  export type aircraftScalarWhereWithAggregatesInput = {
    AND?: aircraftScalarWhereWithAggregatesInput | aircraftScalarWhereWithAggregatesInput[]
    OR?: aircraftScalarWhereWithAggregatesInput[]
    NOT?: aircraftScalarWhereWithAggregatesInput | aircraftScalarWhereWithAggregatesInput[]
    aircraftId?: StringWithAggregatesFilter<"aircraft"> | string
    ownerAirlineCode?: StringWithAggregatesFilter<"aircraft"> | string
    model?: StringWithAggregatesFilter<"aircraft"> | string
  }

  export type aircraftCostWhereInput = {
    AND?: aircraftCostWhereInput | aircraftCostWhereInput[]
    OR?: aircraftCostWhereInput[]
    NOT?: aircraftCostWhereInput | aircraftCostWhereInput[]
    model?: StringFilter<"aircraftCost"> | string
    ownerAirlineCode?: StringFilter<"aircraftCost"> | string
    costPerMile?: FloatFilter<"aircraftCost"> | number
    airline?: XOR<AirlineScalarRelationFilter, airlineWhereInput>
  }

  export type aircraftCostOrderByWithRelationInput = {
    model?: SortOrder
    ownerAirlineCode?: SortOrder
    costPerMile?: SortOrder
    airline?: airlineOrderByWithRelationInput
    _relevance?: aircraftCostOrderByRelevanceInput
  }

  export type aircraftCostWhereUniqueInput = Prisma.AtLeast<{
    model_ownerAirlineCode?: aircraftCostModelOwnerAirlineCodeCompoundUniqueInput
    AND?: aircraftCostWhereInput | aircraftCostWhereInput[]
    OR?: aircraftCostWhereInput[]
    NOT?: aircraftCostWhereInput | aircraftCostWhereInput[]
    model?: StringFilter<"aircraftCost"> | string
    ownerAirlineCode?: StringFilter<"aircraftCost"> | string
    costPerMile?: FloatFilter<"aircraftCost"> | number
    airline?: XOR<AirlineScalarRelationFilter, airlineWhereInput>
  }, "model_ownerAirlineCode">

  export type aircraftCostOrderByWithAggregationInput = {
    model?: SortOrder
    ownerAirlineCode?: SortOrder
    costPerMile?: SortOrder
    _count?: aircraftCostCountOrderByAggregateInput
    _avg?: aircraftCostAvgOrderByAggregateInput
    _max?: aircraftCostMaxOrderByAggregateInput
    _min?: aircraftCostMinOrderByAggregateInput
    _sum?: aircraftCostSumOrderByAggregateInput
  }

  export type aircraftCostScalarWhereWithAggregatesInput = {
    AND?: aircraftCostScalarWhereWithAggregatesInput | aircraftCostScalarWhereWithAggregatesInput[]
    OR?: aircraftCostScalarWhereWithAggregatesInput[]
    NOT?: aircraftCostScalarWhereWithAggregatesInput | aircraftCostScalarWhereWithAggregatesInput[]
    model?: StringWithAggregatesFilter<"aircraftCost"> | string
    ownerAirlineCode?: StringWithAggregatesFilter<"aircraftCost"> | string
    costPerMile?: FloatWithAggregatesFilter<"aircraftCost"> | number
  }

  export type airportWhereInput = {
    AND?: airportWhereInput | airportWhereInput[]
    OR?: airportWhereInput[]
    NOT?: airportWhereInput | airportWhereInput[]
    airportCode?: StringFilter<"airport"> | string
    name?: StringFilter<"airport"> | string
    country?: StringFilter<"airport"> | string
    city?: StringFilter<"airport"> | string
    timezone?: StringFilter<"airport"> | string
    latitude?: FloatNullableFilter<"airport"> | number | null
    longitude?: FloatNullableFilter<"airport"> | number | null
    altitude?: IntNullableFilter<"airport"> | number | null
    departFlights?: FlightListRelationFilter
    arriveFlights?: FlightListRelationFilter
  }

  export type airportOrderByWithRelationInput = {
    airportCode?: SortOrder
    name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    timezone?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    altitude?: SortOrderInput | SortOrder
    departFlights?: flightOrderByRelationAggregateInput
    arriveFlights?: flightOrderByRelationAggregateInput
    _relevance?: airportOrderByRelevanceInput
  }

  export type airportWhereUniqueInput = Prisma.AtLeast<{
    airportCode?: string
    AND?: airportWhereInput | airportWhereInput[]
    OR?: airportWhereInput[]
    NOT?: airportWhereInput | airportWhereInput[]
    name?: StringFilter<"airport"> | string
    country?: StringFilter<"airport"> | string
    city?: StringFilter<"airport"> | string
    timezone?: StringFilter<"airport"> | string
    latitude?: FloatNullableFilter<"airport"> | number | null
    longitude?: FloatNullableFilter<"airport"> | number | null
    altitude?: IntNullableFilter<"airport"> | number | null
    departFlights?: FlightListRelationFilter
    arriveFlights?: FlightListRelationFilter
  }, "airportCode">

  export type airportOrderByWithAggregationInput = {
    airportCode?: SortOrder
    name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    timezone?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    altitude?: SortOrderInput | SortOrder
    _count?: airportCountOrderByAggregateInput
    _avg?: airportAvgOrderByAggregateInput
    _max?: airportMaxOrderByAggregateInput
    _min?: airportMinOrderByAggregateInput
    _sum?: airportSumOrderByAggregateInput
  }

  export type airportScalarWhereWithAggregatesInput = {
    AND?: airportScalarWhereWithAggregatesInput | airportScalarWhereWithAggregatesInput[]
    OR?: airportScalarWhereWithAggregatesInput[]
    NOT?: airportScalarWhereWithAggregatesInput | airportScalarWhereWithAggregatesInput[]
    airportCode?: StringWithAggregatesFilter<"airport"> | string
    name?: StringWithAggregatesFilter<"airport"> | string
    country?: StringWithAggregatesFilter<"airport"> | string
    city?: StringWithAggregatesFilter<"airport"> | string
    timezone?: StringWithAggregatesFilter<"airport"> | string
    latitude?: FloatNullableWithAggregatesFilter<"airport"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"airport"> | number | null
    altitude?: IntNullableWithAggregatesFilter<"airport"> | number | null
  }

  export type bookingWhereInput = {
    AND?: bookingWhereInput | bookingWhereInput[]
    OR?: bookingWhereInput[]
    NOT?: bookingWhereInput | bookingWhereInput[]
    bookingId?: StringFilter<"booking"> | string
    bookingDate?: DateTimeFilter<"booking"> | Date | string
    status?: EnumBookingStatusFilter<"booking"> | $Enums.BookingStatus
    userId?: StringFilter<"booking"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    bookingFlights?: Booking_flightListRelationFilter
    passengerBookings?: Passenger_bookingListRelationFilter
    tickets?: TicketListRelationFilter
    payment?: XOR<PaymentNullableScalarRelationFilter, paymentWhereInput> | null
  }

  export type bookingOrderByWithRelationInput = {
    bookingId?: SortOrder
    bookingDate?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    user?: userOrderByWithRelationInput
    bookingFlights?: booking_flightOrderByRelationAggregateInput
    passengerBookings?: passenger_bookingOrderByRelationAggregateInput
    tickets?: ticketOrderByRelationAggregateInput
    payment?: paymentOrderByWithRelationInput
    _relevance?: bookingOrderByRelevanceInput
  }

  export type bookingWhereUniqueInput = Prisma.AtLeast<{
    bookingId?: string
    AND?: bookingWhereInput | bookingWhereInput[]
    OR?: bookingWhereInput[]
    NOT?: bookingWhereInput | bookingWhereInput[]
    bookingDate?: DateTimeFilter<"booking"> | Date | string
    status?: EnumBookingStatusFilter<"booking"> | $Enums.BookingStatus
    userId?: StringFilter<"booking"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    bookingFlights?: Booking_flightListRelationFilter
    passengerBookings?: Passenger_bookingListRelationFilter
    tickets?: TicketListRelationFilter
    payment?: XOR<PaymentNullableScalarRelationFilter, paymentWhereInput> | null
  }, "bookingId">

  export type bookingOrderByWithAggregationInput = {
    bookingId?: SortOrder
    bookingDate?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    _count?: bookingCountOrderByAggregateInput
    _max?: bookingMaxOrderByAggregateInput
    _min?: bookingMinOrderByAggregateInput
  }

  export type bookingScalarWhereWithAggregatesInput = {
    AND?: bookingScalarWhereWithAggregatesInput | bookingScalarWhereWithAggregatesInput[]
    OR?: bookingScalarWhereWithAggregatesInput[]
    NOT?: bookingScalarWhereWithAggregatesInput | bookingScalarWhereWithAggregatesInput[]
    bookingId?: StringWithAggregatesFilter<"booking"> | string
    bookingDate?: DateTimeWithAggregatesFilter<"booking"> | Date | string
    status?: EnumBookingStatusWithAggregatesFilter<"booking"> | $Enums.BookingStatus
    userId?: StringWithAggregatesFilter<"booking"> | string
  }

  export type booking_flightWhereInput = {
    AND?: booking_flightWhereInput | booking_flightWhereInput[]
    OR?: booking_flightWhereInput[]
    NOT?: booking_flightWhereInput | booking_flightWhereInput[]
    bookingId?: StringFilter<"booking_flight"> | string
    flightId?: StringFilter<"booking_flight"> | string
    booking?: XOR<BookingScalarRelationFilter, bookingWhereInput>
    flight?: XOR<FlightOperateScalarRelationFilter, flightOperateWhereInput>
  }

  export type booking_flightOrderByWithRelationInput = {
    bookingId?: SortOrder
    flightId?: SortOrder
    booking?: bookingOrderByWithRelationInput
    flight?: flightOperateOrderByWithRelationInput
    _relevance?: booking_flightOrderByRelevanceInput
  }

  export type booking_flightWhereUniqueInput = Prisma.AtLeast<{
    bookingId_flightId?: booking_flightBookingIdFlightIdCompoundUniqueInput
    AND?: booking_flightWhereInput | booking_flightWhereInput[]
    OR?: booking_flightWhereInput[]
    NOT?: booking_flightWhereInput | booking_flightWhereInput[]
    bookingId?: StringFilter<"booking_flight"> | string
    flightId?: StringFilter<"booking_flight"> | string
    booking?: XOR<BookingScalarRelationFilter, bookingWhereInput>
    flight?: XOR<FlightOperateScalarRelationFilter, flightOperateWhereInput>
  }, "bookingId_flightId">

  export type booking_flightOrderByWithAggregationInput = {
    bookingId?: SortOrder
    flightId?: SortOrder
    _count?: booking_flightCountOrderByAggregateInput
    _max?: booking_flightMaxOrderByAggregateInput
    _min?: booking_flightMinOrderByAggregateInput
  }

  export type booking_flightScalarWhereWithAggregatesInput = {
    AND?: booking_flightScalarWhereWithAggregatesInput | booking_flightScalarWhereWithAggregatesInput[]
    OR?: booking_flightScalarWhereWithAggregatesInput[]
    NOT?: booking_flightScalarWhereWithAggregatesInput | booking_flightScalarWhereWithAggregatesInput[]
    bookingId?: StringWithAggregatesFilter<"booking_flight"> | string
    flightId?: StringWithAggregatesFilter<"booking_flight"> | string
  }

  export type flightWhereInput = {
    AND?: flightWhereInput | flightWhereInput[]
    OR?: flightWhereInput[]
    NOT?: flightWhereInput | flightWhereInput[]
    flightNum?: StringFilter<"flight"> | string
    airlineCode?: StringFilter<"flight"> | string
    departAirportId?: StringFilter<"flight"> | string
    arriveAirportId?: StringFilter<"flight"> | string
    airline?: XOR<AirlineScalarRelationFilter, airlineWhereInput>
    departAirport?: XOR<AirportScalarRelationFilter, airportWhereInput>
    arriveAirport?: XOR<AirportScalarRelationFilter, airportWhereInput>
    flightOperates?: FlightOperateListRelationFilter
    transitFrom?: TransitListRelationFilter
    transitTo?: TransitListRelationFilter
  }

  export type flightOrderByWithRelationInput = {
    flightNum?: SortOrder
    airlineCode?: SortOrder
    departAirportId?: SortOrder
    arriveAirportId?: SortOrder
    airline?: airlineOrderByWithRelationInput
    departAirport?: airportOrderByWithRelationInput
    arriveAirport?: airportOrderByWithRelationInput
    flightOperates?: flightOperateOrderByRelationAggregateInput
    transitFrom?: transitOrderByRelationAggregateInput
    transitTo?: transitOrderByRelationAggregateInput
    _relevance?: flightOrderByRelevanceInput
  }

  export type flightWhereUniqueInput = Prisma.AtLeast<{
    flightNum_airlineCode?: flightFlightNumAirlineCodeCompoundUniqueInput
    AND?: flightWhereInput | flightWhereInput[]
    OR?: flightWhereInput[]
    NOT?: flightWhereInput | flightWhereInput[]
    flightNum?: StringFilter<"flight"> | string
    airlineCode?: StringFilter<"flight"> | string
    departAirportId?: StringFilter<"flight"> | string
    arriveAirportId?: StringFilter<"flight"> | string
    airline?: XOR<AirlineScalarRelationFilter, airlineWhereInput>
    departAirport?: XOR<AirportScalarRelationFilter, airportWhereInput>
    arriveAirport?: XOR<AirportScalarRelationFilter, airportWhereInput>
    flightOperates?: FlightOperateListRelationFilter
    transitFrom?: TransitListRelationFilter
    transitTo?: TransitListRelationFilter
  }, "flightNum_airlineCode">

  export type flightOrderByWithAggregationInput = {
    flightNum?: SortOrder
    airlineCode?: SortOrder
    departAirportId?: SortOrder
    arriveAirportId?: SortOrder
    _count?: flightCountOrderByAggregateInput
    _max?: flightMaxOrderByAggregateInput
    _min?: flightMinOrderByAggregateInput
  }

  export type flightScalarWhereWithAggregatesInput = {
    AND?: flightScalarWhereWithAggregatesInput | flightScalarWhereWithAggregatesInput[]
    OR?: flightScalarWhereWithAggregatesInput[]
    NOT?: flightScalarWhereWithAggregatesInput | flightScalarWhereWithAggregatesInput[]
    flightNum?: StringWithAggregatesFilter<"flight"> | string
    airlineCode?: StringWithAggregatesFilter<"flight"> | string
    departAirportId?: StringWithAggregatesFilter<"flight"> | string
    arriveAirportId?: StringWithAggregatesFilter<"flight"> | string
  }

  export type flightOperateWhereInput = {
    AND?: flightOperateWhereInput | flightOperateWhereInput[]
    OR?: flightOperateWhereInput[]
    NOT?: flightOperateWhereInput | flightOperateWhereInput[]
    flightId?: StringFilter<"flightOperate"> | string
    flightNum?: StringFilter<"flightOperate"> | string
    airlineCode?: StringFilter<"flightOperate"> | string
    departureTime?: DateTimeFilter<"flightOperate"> | Date | string
    arrivalTime?: DateTimeFilter<"flightOperate"> | Date | string
    departureGate?: StringFilter<"flightOperate"> | string
    aircraftId?: StringFilter<"flightOperate"> | string
    aircraft?: XOR<AircraftScalarRelationFilter, aircraftWhereInput>
    flight?: XOR<FlightScalarRelationFilter, flightWhereInput>
    bookingFlights?: Booking_flightListRelationFilter
    tickets?: TicketListRelationFilter
  }

  export type flightOperateOrderByWithRelationInput = {
    flightId?: SortOrder
    flightNum?: SortOrder
    airlineCode?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    departureGate?: SortOrder
    aircraftId?: SortOrder
    aircraft?: aircraftOrderByWithRelationInput
    flight?: flightOrderByWithRelationInput
    bookingFlights?: booking_flightOrderByRelationAggregateInput
    tickets?: ticketOrderByRelationAggregateInput
    _relevance?: flightOperateOrderByRelevanceInput
  }

  export type flightOperateWhereUniqueInput = Prisma.AtLeast<{
    flightId?: string
    flightNum_airlineCode_departureTime?: flightOperateFlightNumAirlineCodeDepartureTimeCompoundUniqueInput
    AND?: flightOperateWhereInput | flightOperateWhereInput[]
    OR?: flightOperateWhereInput[]
    NOT?: flightOperateWhereInput | flightOperateWhereInput[]
    flightNum?: StringFilter<"flightOperate"> | string
    airlineCode?: StringFilter<"flightOperate"> | string
    departureTime?: DateTimeFilter<"flightOperate"> | Date | string
    arrivalTime?: DateTimeFilter<"flightOperate"> | Date | string
    departureGate?: StringFilter<"flightOperate"> | string
    aircraftId?: StringFilter<"flightOperate"> | string
    aircraft?: XOR<AircraftScalarRelationFilter, aircraftWhereInput>
    flight?: XOR<FlightScalarRelationFilter, flightWhereInput>
    bookingFlights?: Booking_flightListRelationFilter
    tickets?: TicketListRelationFilter
  }, "flightId" | "flightNum_airlineCode_departureTime">

  export type flightOperateOrderByWithAggregationInput = {
    flightId?: SortOrder
    flightNum?: SortOrder
    airlineCode?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    departureGate?: SortOrder
    aircraftId?: SortOrder
    _count?: flightOperateCountOrderByAggregateInput
    _max?: flightOperateMaxOrderByAggregateInput
    _min?: flightOperateMinOrderByAggregateInput
  }

  export type flightOperateScalarWhereWithAggregatesInput = {
    AND?: flightOperateScalarWhereWithAggregatesInput | flightOperateScalarWhereWithAggregatesInput[]
    OR?: flightOperateScalarWhereWithAggregatesInput[]
    NOT?: flightOperateScalarWhereWithAggregatesInput | flightOperateScalarWhereWithAggregatesInput[]
    flightId?: StringWithAggregatesFilter<"flightOperate"> | string
    flightNum?: StringWithAggregatesFilter<"flightOperate"> | string
    airlineCode?: StringWithAggregatesFilter<"flightOperate"> | string
    departureTime?: DateTimeWithAggregatesFilter<"flightOperate"> | Date | string
    arrivalTime?: DateTimeWithAggregatesFilter<"flightOperate"> | Date | string
    departureGate?: StringWithAggregatesFilter<"flightOperate"> | string
    aircraftId?: StringWithAggregatesFilter<"flightOperate"> | string
  }

  export type passengerWhereInput = {
    AND?: passengerWhereInput | passengerWhereInput[]
    OR?: passengerWhereInput[]
    NOT?: passengerWhereInput | passengerWhereInput[]
    passportNum?: StringFilter<"passenger"> | string
    passportCountry?: StringFilter<"passenger"> | string
    passportExpiry?: DateTimeFilter<"passenger"> | Date | string
    firstName?: StringFilter<"passenger"> | string
    lastName?: StringFilter<"passenger"> | string
    dateOfBirth?: DateTimeFilter<"passenger"> | Date | string
    nationality?: StringFilter<"passenger"> | string
    ageRange?: EnumAgeRangeFilter<"passenger"> | $Enums.AgeRange
    userId?: StringFilter<"passenger"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    passengerBookings?: Passenger_bookingListRelationFilter
    tickets?: TicketListRelationFilter
  }

  export type passengerOrderByWithRelationInput = {
    passportNum?: SortOrder
    passportCountry?: SortOrder
    passportExpiry?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    ageRange?: SortOrder
    userId?: SortOrder
    user?: userOrderByWithRelationInput
    passengerBookings?: passenger_bookingOrderByRelationAggregateInput
    tickets?: ticketOrderByRelationAggregateInput
    _relevance?: passengerOrderByRelevanceInput
  }

  export type passengerWhereUniqueInput = Prisma.AtLeast<{
    passportNum?: string
    AND?: passengerWhereInput | passengerWhereInput[]
    OR?: passengerWhereInput[]
    NOT?: passengerWhereInput | passengerWhereInput[]
    passportCountry?: StringFilter<"passenger"> | string
    passportExpiry?: DateTimeFilter<"passenger"> | Date | string
    firstName?: StringFilter<"passenger"> | string
    lastName?: StringFilter<"passenger"> | string
    dateOfBirth?: DateTimeFilter<"passenger"> | Date | string
    nationality?: StringFilter<"passenger"> | string
    ageRange?: EnumAgeRangeFilter<"passenger"> | $Enums.AgeRange
    userId?: StringFilter<"passenger"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    passengerBookings?: Passenger_bookingListRelationFilter
    tickets?: TicketListRelationFilter
  }, "passportNum">

  export type passengerOrderByWithAggregationInput = {
    passportNum?: SortOrder
    passportCountry?: SortOrder
    passportExpiry?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    ageRange?: SortOrder
    userId?: SortOrder
    _count?: passengerCountOrderByAggregateInput
    _max?: passengerMaxOrderByAggregateInput
    _min?: passengerMinOrderByAggregateInput
  }

  export type passengerScalarWhereWithAggregatesInput = {
    AND?: passengerScalarWhereWithAggregatesInput | passengerScalarWhereWithAggregatesInput[]
    OR?: passengerScalarWhereWithAggregatesInput[]
    NOT?: passengerScalarWhereWithAggregatesInput | passengerScalarWhereWithAggregatesInput[]
    passportNum?: StringWithAggregatesFilter<"passenger"> | string
    passportCountry?: StringWithAggregatesFilter<"passenger"> | string
    passportExpiry?: DateTimeWithAggregatesFilter<"passenger"> | Date | string
    firstName?: StringWithAggregatesFilter<"passenger"> | string
    lastName?: StringWithAggregatesFilter<"passenger"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"passenger"> | Date | string
    nationality?: StringWithAggregatesFilter<"passenger"> | string
    ageRange?: EnumAgeRangeWithAggregatesFilter<"passenger"> | $Enums.AgeRange
    userId?: StringWithAggregatesFilter<"passenger"> | string
  }

  export type passenger_bookingWhereInput = {
    AND?: passenger_bookingWhereInput | passenger_bookingWhereInput[]
    OR?: passenger_bookingWhereInput[]
    NOT?: passenger_bookingWhereInput | passenger_bookingWhereInput[]
    bookingId?: StringFilter<"passenger_booking"> | string
    passportNum?: StringFilter<"passenger_booking"> | string
    booking?: XOR<BookingScalarRelationFilter, bookingWhereInput>
    passenger?: XOR<PassengerScalarRelationFilter, passengerWhereInput>
  }

  export type passenger_bookingOrderByWithRelationInput = {
    bookingId?: SortOrder
    passportNum?: SortOrder
    booking?: bookingOrderByWithRelationInput
    passenger?: passengerOrderByWithRelationInput
    _relevance?: passenger_bookingOrderByRelevanceInput
  }

  export type passenger_bookingWhereUniqueInput = Prisma.AtLeast<{
    bookingId_passportNum?: passenger_bookingBookingIdPassportNumCompoundUniqueInput
    AND?: passenger_bookingWhereInput | passenger_bookingWhereInput[]
    OR?: passenger_bookingWhereInput[]
    NOT?: passenger_bookingWhereInput | passenger_bookingWhereInput[]
    bookingId?: StringFilter<"passenger_booking"> | string
    passportNum?: StringFilter<"passenger_booking"> | string
    booking?: XOR<BookingScalarRelationFilter, bookingWhereInput>
    passenger?: XOR<PassengerScalarRelationFilter, passengerWhereInput>
  }, "bookingId_passportNum">

  export type passenger_bookingOrderByWithAggregationInput = {
    bookingId?: SortOrder
    passportNum?: SortOrder
    _count?: passenger_bookingCountOrderByAggregateInput
    _max?: passenger_bookingMaxOrderByAggregateInput
    _min?: passenger_bookingMinOrderByAggregateInput
  }

  export type passenger_bookingScalarWhereWithAggregatesInput = {
    AND?: passenger_bookingScalarWhereWithAggregatesInput | passenger_bookingScalarWhereWithAggregatesInput[]
    OR?: passenger_bookingScalarWhereWithAggregatesInput[]
    NOT?: passenger_bookingScalarWhereWithAggregatesInput | passenger_bookingScalarWhereWithAggregatesInput[]
    bookingId?: StringWithAggregatesFilter<"passenger_booking"> | string
    passportNum?: StringWithAggregatesFilter<"passenger_booking"> | string
  }

  export type paymentWhereInput = {
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    paymentId?: StringFilter<"payment"> | string
    amount?: FloatFilter<"payment"> | number
    method?: StringFilter<"payment"> | string
    paymentDate?: DateTimeFilter<"payment"> | Date | string
    bookingId?: StringFilter<"payment"> | string
    booking?: XOR<BookingScalarRelationFilter, bookingWhereInput>
  }

  export type paymentOrderByWithRelationInput = {
    paymentId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    paymentDate?: SortOrder
    bookingId?: SortOrder
    booking?: bookingOrderByWithRelationInput
    _relevance?: paymentOrderByRelevanceInput
  }

  export type paymentWhereUniqueInput = Prisma.AtLeast<{
    paymentId?: string
    bookingId?: string
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    amount?: FloatFilter<"payment"> | number
    method?: StringFilter<"payment"> | string
    paymentDate?: DateTimeFilter<"payment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, bookingWhereInput>
  }, "paymentId" | "bookingId">

  export type paymentOrderByWithAggregationInput = {
    paymentId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    paymentDate?: SortOrder
    bookingId?: SortOrder
    _count?: paymentCountOrderByAggregateInput
    _avg?: paymentAvgOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
    _sum?: paymentSumOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    OR?: paymentScalarWhereWithAggregatesInput[]
    NOT?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    paymentId?: StringWithAggregatesFilter<"payment"> | string
    amount?: FloatWithAggregatesFilter<"payment"> | number
    method?: StringWithAggregatesFilter<"payment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"payment"> | Date | string
    bookingId?: StringWithAggregatesFilter<"payment"> | string
  }

  export type aircraft_seatmapWhereInput = {
    AND?: aircraft_seatmapWhereInput | aircraft_seatmapWhereInput[]
    OR?: aircraft_seatmapWhereInput[]
    NOT?: aircraft_seatmapWhereInput | aircraft_seatmapWhereInput[]
    aircraftId?: StringFilter<"aircraft_seatmap"> | string
    seatMapId?: StringFilter<"aircraft_seatmap"> | string
    aircraft?: XOR<AircraftScalarRelationFilter, aircraftWhereInput>
    seatmap?: XOR<Seatmap_infoScalarRelationFilter, seatmap_infoWhereInput>
  }

  export type aircraft_seatmapOrderByWithRelationInput = {
    aircraftId?: SortOrder
    seatMapId?: SortOrder
    aircraft?: aircraftOrderByWithRelationInput
    seatmap?: seatmap_infoOrderByWithRelationInput
    _relevance?: aircraft_seatmapOrderByRelevanceInput
  }

  export type aircraft_seatmapWhereUniqueInput = Prisma.AtLeast<{
    aircraftId_seatMapId?: aircraft_seatmapAircraftIdSeatMapIdCompoundUniqueInput
    AND?: aircraft_seatmapWhereInput | aircraft_seatmapWhereInput[]
    OR?: aircraft_seatmapWhereInput[]
    NOT?: aircraft_seatmapWhereInput | aircraft_seatmapWhereInput[]
    aircraftId?: StringFilter<"aircraft_seatmap"> | string
    seatMapId?: StringFilter<"aircraft_seatmap"> | string
    aircraft?: XOR<AircraftScalarRelationFilter, aircraftWhereInput>
    seatmap?: XOR<Seatmap_infoScalarRelationFilter, seatmap_infoWhereInput>
  }, "aircraftId_seatMapId">

  export type aircraft_seatmapOrderByWithAggregationInput = {
    aircraftId?: SortOrder
    seatMapId?: SortOrder
    _count?: aircraft_seatmapCountOrderByAggregateInput
    _max?: aircraft_seatmapMaxOrderByAggregateInput
    _min?: aircraft_seatmapMinOrderByAggregateInput
  }

  export type aircraft_seatmapScalarWhereWithAggregatesInput = {
    AND?: aircraft_seatmapScalarWhereWithAggregatesInput | aircraft_seatmapScalarWhereWithAggregatesInput[]
    OR?: aircraft_seatmapScalarWhereWithAggregatesInput[]
    NOT?: aircraft_seatmapScalarWhereWithAggregatesInput | aircraft_seatmapScalarWhereWithAggregatesInput[]
    aircraftId?: StringWithAggregatesFilter<"aircraft_seatmap"> | string
    seatMapId?: StringWithAggregatesFilter<"aircraft_seatmap"> | string
  }

  export type seatmap_infoWhereInput = {
    AND?: seatmap_infoWhereInput | seatmap_infoWhereInput[]
    OR?: seatmap_infoWhereInput[]
    NOT?: seatmap_infoWhereInput | seatmap_infoWhereInput[]
    seatMapId?: StringFilter<"seatmap_info"> | string
    airlineCode?: StringFilter<"seatmap_info"> | string
    aircraftModel?: StringFilter<"seatmap_info"> | string
    version?: StringFilter<"seatmap_info"> | string
    seat?: SeatListRelationFilter
    aircraft?: Aircraft_seatmapListRelationFilter
  }

  export type seatmap_infoOrderByWithRelationInput = {
    seatMapId?: SortOrder
    airlineCode?: SortOrder
    aircraftModel?: SortOrder
    version?: SortOrder
    seat?: seatOrderByRelationAggregateInput
    aircraft?: aircraft_seatmapOrderByRelationAggregateInput
    _relevance?: seatmap_infoOrderByRelevanceInput
  }

  export type seatmap_infoWhereUniqueInput = Prisma.AtLeast<{
    seatMapId?: string
    AND?: seatmap_infoWhereInput | seatmap_infoWhereInput[]
    OR?: seatmap_infoWhereInput[]
    NOT?: seatmap_infoWhereInput | seatmap_infoWhereInput[]
    airlineCode?: StringFilter<"seatmap_info"> | string
    aircraftModel?: StringFilter<"seatmap_info"> | string
    version?: StringFilter<"seatmap_info"> | string
    seat?: SeatListRelationFilter
    aircraft?: Aircraft_seatmapListRelationFilter
  }, "seatMapId">

  export type seatmap_infoOrderByWithAggregationInput = {
    seatMapId?: SortOrder
    airlineCode?: SortOrder
    aircraftModel?: SortOrder
    version?: SortOrder
    _count?: seatmap_infoCountOrderByAggregateInput
    _max?: seatmap_infoMaxOrderByAggregateInput
    _min?: seatmap_infoMinOrderByAggregateInput
  }

  export type seatmap_infoScalarWhereWithAggregatesInput = {
    AND?: seatmap_infoScalarWhereWithAggregatesInput | seatmap_infoScalarWhereWithAggregatesInput[]
    OR?: seatmap_infoScalarWhereWithAggregatesInput[]
    NOT?: seatmap_infoScalarWhereWithAggregatesInput | seatmap_infoScalarWhereWithAggregatesInput[]
    seatMapId?: StringWithAggregatesFilter<"seatmap_info"> | string
    airlineCode?: StringWithAggregatesFilter<"seatmap_info"> | string
    aircraftModel?: StringWithAggregatesFilter<"seatmap_info"> | string
    version?: StringWithAggregatesFilter<"seatmap_info"> | string
  }

  export type seatWhereInput = {
    AND?: seatWhereInput | seatWhereInput[]
    OR?: seatWhereInput[]
    NOT?: seatWhereInput | seatWhereInput[]
    seatMapId?: StringFilter<"seat"> | string
    seatId?: StringFilter<"seat"> | string
    seatNum?: StringFilter<"seat"> | string
    row?: IntFilter<"seat"> | number
    class?: EnumSeatClassFilter<"seat"> | $Enums.SeatClass
    price?: FloatFilter<"seat"> | number
    features?: StringFilter<"seat"> | string
    floor?: IntFilter<"seat"> | number
    tickets?: TicketListRelationFilter
    seatmap?: XOR<Seatmap_infoScalarRelationFilter, seatmap_infoWhereInput>
  }

  export type seatOrderByWithRelationInput = {
    seatMapId?: SortOrder
    seatId?: SortOrder
    seatNum?: SortOrder
    row?: SortOrder
    class?: SortOrder
    price?: SortOrder
    features?: SortOrder
    floor?: SortOrder
    tickets?: ticketOrderByRelationAggregateInput
    seatmap?: seatmap_infoOrderByWithRelationInput
    _relevance?: seatOrderByRelevanceInput
  }

  export type seatWhereUniqueInput = Prisma.AtLeast<{
    seatId?: string
    seatMapId_seatId?: seatSeatMapIdSeatIdCompoundUniqueInput
    AND?: seatWhereInput | seatWhereInput[]
    OR?: seatWhereInput[]
    NOT?: seatWhereInput | seatWhereInput[]
    seatMapId?: StringFilter<"seat"> | string
    seatNum?: StringFilter<"seat"> | string
    row?: IntFilter<"seat"> | number
    class?: EnumSeatClassFilter<"seat"> | $Enums.SeatClass
    price?: FloatFilter<"seat"> | number
    features?: StringFilter<"seat"> | string
    floor?: IntFilter<"seat"> | number
    tickets?: TicketListRelationFilter
    seatmap?: XOR<Seatmap_infoScalarRelationFilter, seatmap_infoWhereInput>
  }, "seatMapId_seatId" | "seatId">

  export type seatOrderByWithAggregationInput = {
    seatMapId?: SortOrder
    seatId?: SortOrder
    seatNum?: SortOrder
    row?: SortOrder
    class?: SortOrder
    price?: SortOrder
    features?: SortOrder
    floor?: SortOrder
    _count?: seatCountOrderByAggregateInput
    _avg?: seatAvgOrderByAggregateInput
    _max?: seatMaxOrderByAggregateInput
    _min?: seatMinOrderByAggregateInput
    _sum?: seatSumOrderByAggregateInput
  }

  export type seatScalarWhereWithAggregatesInput = {
    AND?: seatScalarWhereWithAggregatesInput | seatScalarWhereWithAggregatesInput[]
    OR?: seatScalarWhereWithAggregatesInput[]
    NOT?: seatScalarWhereWithAggregatesInput | seatScalarWhereWithAggregatesInput[]
    seatMapId?: StringWithAggregatesFilter<"seat"> | string
    seatId?: StringWithAggregatesFilter<"seat"> | string
    seatNum?: StringWithAggregatesFilter<"seat"> | string
    row?: IntWithAggregatesFilter<"seat"> | number
    class?: EnumSeatClassWithAggregatesFilter<"seat"> | $Enums.SeatClass
    price?: FloatWithAggregatesFilter<"seat"> | number
    features?: StringWithAggregatesFilter<"seat"> | string
    floor?: IntWithAggregatesFilter<"seat"> | number
  }

  export type ticketWhereInput = {
    AND?: ticketWhereInput | ticketWhereInput[]
    OR?: ticketWhereInput[]
    NOT?: ticketWhereInput | ticketWhereInput[]
    ticketNum?: StringFilter<"ticket"> | string
    farePackage?: EnumFarePackageFilter<"ticket"> | $Enums.FarePackage
    baggageAllowanceWeight?: IntFilter<"ticket"> | number
    baggageAllowancePrice?: FloatFilter<"ticket"> | number
    mealSelection?: StringFilter<"ticket"> | string
    mealPrice?: FloatFilter<"ticket"> | number
    ticketPrice?: FloatFilter<"ticket"> | number
    bookingId?: StringFilter<"ticket"> | string
    flightId?: StringFilter<"ticket"> | string
    passportNum?: StringFilter<"ticket"> | string
    seatNum?: StringFilter<"ticket"> | string
    booking?: XOR<BookingScalarRelationFilter, bookingWhereInput>
    passenger?: XOR<PassengerScalarRelationFilter, passengerWhereInput>
    flight?: XOR<FlightOperateScalarRelationFilter, flightOperateWhereInput>
    seat?: XOR<SeatScalarRelationFilter, seatWhereInput>
  }

  export type ticketOrderByWithRelationInput = {
    ticketNum?: SortOrder
    farePackage?: SortOrder
    baggageAllowanceWeight?: SortOrder
    baggageAllowancePrice?: SortOrder
    mealSelection?: SortOrder
    mealPrice?: SortOrder
    ticketPrice?: SortOrder
    bookingId?: SortOrder
    flightId?: SortOrder
    passportNum?: SortOrder
    seatNum?: SortOrder
    booking?: bookingOrderByWithRelationInput
    passenger?: passengerOrderByWithRelationInput
    flight?: flightOperateOrderByWithRelationInput
    seat?: seatOrderByWithRelationInput
    _relevance?: ticketOrderByRelevanceInput
  }

  export type ticketWhereUniqueInput = Prisma.AtLeast<{
    ticketNum?: string
    AND?: ticketWhereInput | ticketWhereInput[]
    OR?: ticketWhereInput[]
    NOT?: ticketWhereInput | ticketWhereInput[]
    farePackage?: EnumFarePackageFilter<"ticket"> | $Enums.FarePackage
    baggageAllowanceWeight?: IntFilter<"ticket"> | number
    baggageAllowancePrice?: FloatFilter<"ticket"> | number
    mealSelection?: StringFilter<"ticket"> | string
    mealPrice?: FloatFilter<"ticket"> | number
    ticketPrice?: FloatFilter<"ticket"> | number
    bookingId?: StringFilter<"ticket"> | string
    flightId?: StringFilter<"ticket"> | string
    passportNum?: StringFilter<"ticket"> | string
    seatNum?: StringFilter<"ticket"> | string
    booking?: XOR<BookingScalarRelationFilter, bookingWhereInput>
    passenger?: XOR<PassengerScalarRelationFilter, passengerWhereInput>
    flight?: XOR<FlightOperateScalarRelationFilter, flightOperateWhereInput>
    seat?: XOR<SeatScalarRelationFilter, seatWhereInput>
  }, "ticketNum">

  export type ticketOrderByWithAggregationInput = {
    ticketNum?: SortOrder
    farePackage?: SortOrder
    baggageAllowanceWeight?: SortOrder
    baggageAllowancePrice?: SortOrder
    mealSelection?: SortOrder
    mealPrice?: SortOrder
    ticketPrice?: SortOrder
    bookingId?: SortOrder
    flightId?: SortOrder
    passportNum?: SortOrder
    seatNum?: SortOrder
    _count?: ticketCountOrderByAggregateInput
    _avg?: ticketAvgOrderByAggregateInput
    _max?: ticketMaxOrderByAggregateInput
    _min?: ticketMinOrderByAggregateInput
    _sum?: ticketSumOrderByAggregateInput
  }

  export type ticketScalarWhereWithAggregatesInput = {
    AND?: ticketScalarWhereWithAggregatesInput | ticketScalarWhereWithAggregatesInput[]
    OR?: ticketScalarWhereWithAggregatesInput[]
    NOT?: ticketScalarWhereWithAggregatesInput | ticketScalarWhereWithAggregatesInput[]
    ticketNum?: StringWithAggregatesFilter<"ticket"> | string
    farePackage?: EnumFarePackageWithAggregatesFilter<"ticket"> | $Enums.FarePackage
    baggageAllowanceWeight?: IntWithAggregatesFilter<"ticket"> | number
    baggageAllowancePrice?: FloatWithAggregatesFilter<"ticket"> | number
    mealSelection?: StringWithAggregatesFilter<"ticket"> | string
    mealPrice?: FloatWithAggregatesFilter<"ticket"> | number
    ticketPrice?: FloatWithAggregatesFilter<"ticket"> | number
    bookingId?: StringWithAggregatesFilter<"ticket"> | string
    flightId?: StringWithAggregatesFilter<"ticket"> | string
    passportNum?: StringWithAggregatesFilter<"ticket"> | string
    seatNum?: StringWithAggregatesFilter<"ticket"> | string
  }

  export type transitWhereInput = {
    AND?: transitWhereInput | transitWhereInput[]
    OR?: transitWhereInput[]
    NOT?: transitWhereInput | transitWhereInput[]
    flightNumFrom?: StringFilter<"transit"> | string
    airlineCodeFrom?: StringFilter<"transit"> | string
    flightNumTo?: StringFilter<"transit"> | string
    airlineCodeTo?: StringFilter<"transit"> | string
    from?: XOR<FlightScalarRelationFilter, flightWhereInput>
    to?: XOR<FlightScalarRelationFilter, flightWhereInput>
  }

  export type transitOrderByWithRelationInput = {
    flightNumFrom?: SortOrder
    airlineCodeFrom?: SortOrder
    flightNumTo?: SortOrder
    airlineCodeTo?: SortOrder
    from?: flightOrderByWithRelationInput
    to?: flightOrderByWithRelationInput
    _relevance?: transitOrderByRelevanceInput
  }

  export type transitWhereUniqueInput = Prisma.AtLeast<{
    flightNumFrom_airlineCodeFrom_flightNumTo_airlineCodeTo?: transitFlightNumFromAirlineCodeFromFlightNumToAirlineCodeToCompoundUniqueInput
    AND?: transitWhereInput | transitWhereInput[]
    OR?: transitWhereInput[]
    NOT?: transitWhereInput | transitWhereInput[]
    flightNumFrom?: StringFilter<"transit"> | string
    airlineCodeFrom?: StringFilter<"transit"> | string
    flightNumTo?: StringFilter<"transit"> | string
    airlineCodeTo?: StringFilter<"transit"> | string
    from?: XOR<FlightScalarRelationFilter, flightWhereInput>
    to?: XOR<FlightScalarRelationFilter, flightWhereInput>
  }, "flightNumFrom_airlineCodeFrom_flightNumTo_airlineCodeTo">

  export type transitOrderByWithAggregationInput = {
    flightNumFrom?: SortOrder
    airlineCodeFrom?: SortOrder
    flightNumTo?: SortOrder
    airlineCodeTo?: SortOrder
    _count?: transitCountOrderByAggregateInput
    _max?: transitMaxOrderByAggregateInput
    _min?: transitMinOrderByAggregateInput
  }

  export type transitScalarWhereWithAggregatesInput = {
    AND?: transitScalarWhereWithAggregatesInput | transitScalarWhereWithAggregatesInput[]
    OR?: transitScalarWhereWithAggregatesInput[]
    NOT?: transitScalarWhereWithAggregatesInput | transitScalarWhereWithAggregatesInput[]
    flightNumFrom?: StringWithAggregatesFilter<"transit"> | string
    airlineCodeFrom?: StringWithAggregatesFilter<"transit"> | string
    flightNumTo?: StringWithAggregatesFilter<"transit"> | string
    airlineCodeTo?: StringWithAggregatesFilter<"transit"> | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    uuid?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    firstname?: StringFilter<"user"> | string
    lastname?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    phone?: StringFilter<"user"> | string
    registerDate?: DateTimeFilter<"user"> | Date | string
    bookings?: BookingListRelationFilter
    passengers?: PassengerListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    uuid?: SortOrder
    password?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    registerDate?: SortOrder
    bookings?: bookingOrderByRelationAggregateInput
    passengers?: passengerOrderByRelationAggregateInput
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    uuid?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    password?: StringFilter<"user"> | string
    firstname?: StringFilter<"user"> | string
    lastname?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    phone?: StringFilter<"user"> | string
    registerDate?: DateTimeFilter<"user"> | Date | string
    bookings?: BookingListRelationFilter
    passengers?: PassengerListRelationFilter
  }, "uuid">

  export type userOrderByWithAggregationInput = {
    uuid?: SortOrder
    password?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    registerDate?: SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    uuid?: StringWithAggregatesFilter<"user"> | string
    password?: StringWithAggregatesFilter<"user"> | string
    firstname?: StringWithAggregatesFilter<"user"> | string
    lastname?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    phone?: StringWithAggregatesFilter<"user"> | string
    registerDate?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type adminCreateInput = {
    username: string
    password: string
    fullname?: string | null
    permission: $Enums.Permission
  }

  export type adminUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    fullname?: string | null
    permission: $Enums.Permission
  }

  export type adminUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
  }

  export type adminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
  }

  export type adminCreateManyInput = {
    id?: number
    username: string
    password: string
    fullname?: string | null
    permission: $Enums.Permission
  }

  export type adminUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
  }

  export type adminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
  }

  export type airlineCreateInput = {
    airlineCode: string
    airlineName: string
    aircraft?: aircraftCreateNestedManyWithoutAirlineInput
    aircraftCost?: aircraftCostCreateNestedManyWithoutAirlineInput
    flight?: flightCreateNestedManyWithoutAirlineInput
  }

  export type airlineUncheckedCreateInput = {
    airlineCode: string
    airlineName: string
    aircraft?: aircraftUncheckedCreateNestedManyWithoutAirlineInput
    aircraftCost?: aircraftCostUncheckedCreateNestedManyWithoutAirlineInput
    flight?: flightUncheckedCreateNestedManyWithoutAirlineInput
  }

  export type airlineUpdateInput = {
    airlineCode?: StringFieldUpdateOperationsInput | string
    airlineName?: StringFieldUpdateOperationsInput | string
    aircraft?: aircraftUpdateManyWithoutAirlineNestedInput
    aircraftCost?: aircraftCostUpdateManyWithoutAirlineNestedInput
    flight?: flightUpdateManyWithoutAirlineNestedInput
  }

  export type airlineUncheckedUpdateInput = {
    airlineCode?: StringFieldUpdateOperationsInput | string
    airlineName?: StringFieldUpdateOperationsInput | string
    aircraft?: aircraftUncheckedUpdateManyWithoutAirlineNestedInput
    aircraftCost?: aircraftCostUncheckedUpdateManyWithoutAirlineNestedInput
    flight?: flightUncheckedUpdateManyWithoutAirlineNestedInput
  }

  export type airlineCreateManyInput = {
    airlineCode: string
    airlineName: string
  }

  export type airlineUpdateManyMutationInput = {
    airlineCode?: StringFieldUpdateOperationsInput | string
    airlineName?: StringFieldUpdateOperationsInput | string
  }

  export type airlineUncheckedUpdateManyInput = {
    airlineCode?: StringFieldUpdateOperationsInput | string
    airlineName?: StringFieldUpdateOperationsInput | string
  }

  export type aircraftCreateInput = {
    aircraftId: string
    model: string
    airline: airlineCreateNestedOneWithoutAircraftInput
    flightOperate?: flightOperateCreateNestedManyWithoutAircraftInput
    aircraftSeatmap?: aircraft_seatmapCreateNestedManyWithoutAircraftInput
  }

  export type aircraftUncheckedCreateInput = {
    aircraftId: string
    ownerAirlineCode: string
    model: string
    flightOperate?: flightOperateUncheckedCreateNestedManyWithoutAircraftInput
    aircraftSeatmap?: aircraft_seatmapUncheckedCreateNestedManyWithoutAircraftInput
  }

  export type aircraftUpdateInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    airline?: airlineUpdateOneRequiredWithoutAircraftNestedInput
    flightOperate?: flightOperateUpdateManyWithoutAircraftNestedInput
    aircraftSeatmap?: aircraft_seatmapUpdateManyWithoutAircraftNestedInput
  }

  export type aircraftUncheckedUpdateInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    ownerAirlineCode?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    flightOperate?: flightOperateUncheckedUpdateManyWithoutAircraftNestedInput
    aircraftSeatmap?: aircraft_seatmapUncheckedUpdateManyWithoutAircraftNestedInput
  }

  export type aircraftCreateManyInput = {
    aircraftId: string
    ownerAirlineCode: string
    model: string
  }

  export type aircraftUpdateManyMutationInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
  }

  export type aircraftUncheckedUpdateManyInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    ownerAirlineCode?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
  }

  export type aircraftCostCreateInput = {
    model: string
    costPerMile: number
    airline: airlineCreateNestedOneWithoutAircraftCostInput
  }

  export type aircraftCostUncheckedCreateInput = {
    model: string
    ownerAirlineCode: string
    costPerMile: number
  }

  export type aircraftCostUpdateInput = {
    model?: StringFieldUpdateOperationsInput | string
    costPerMile?: FloatFieldUpdateOperationsInput | number
    airline?: airlineUpdateOneRequiredWithoutAircraftCostNestedInput
  }

  export type aircraftCostUncheckedUpdateInput = {
    model?: StringFieldUpdateOperationsInput | string
    ownerAirlineCode?: StringFieldUpdateOperationsInput | string
    costPerMile?: FloatFieldUpdateOperationsInput | number
  }

  export type aircraftCostCreateManyInput = {
    model: string
    ownerAirlineCode: string
    costPerMile: number
  }

  export type aircraftCostUpdateManyMutationInput = {
    model?: StringFieldUpdateOperationsInput | string
    costPerMile?: FloatFieldUpdateOperationsInput | number
  }

  export type aircraftCostUncheckedUpdateManyInput = {
    model?: StringFieldUpdateOperationsInput | string
    ownerAirlineCode?: StringFieldUpdateOperationsInput | string
    costPerMile?: FloatFieldUpdateOperationsInput | number
  }

  export type airportCreateInput = {
    airportCode: string
    name: string
    country: string
    city: string
    timezone: string
    latitude?: number | null
    longitude?: number | null
    altitude?: number | null
    departFlights?: flightCreateNestedManyWithoutDepartAirportInput
    arriveFlights?: flightCreateNestedManyWithoutArriveAirportInput
  }

  export type airportUncheckedCreateInput = {
    airportCode: string
    name: string
    country: string
    city: string
    timezone: string
    latitude?: number | null
    longitude?: number | null
    altitude?: number | null
    departFlights?: flightUncheckedCreateNestedManyWithoutDepartAirportInput
    arriveFlights?: flightUncheckedCreateNestedManyWithoutArriveAirportInput
  }

  export type airportUpdateInput = {
    airportCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableIntFieldUpdateOperationsInput | number | null
    departFlights?: flightUpdateManyWithoutDepartAirportNestedInput
    arriveFlights?: flightUpdateManyWithoutArriveAirportNestedInput
  }

  export type airportUncheckedUpdateInput = {
    airportCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableIntFieldUpdateOperationsInput | number | null
    departFlights?: flightUncheckedUpdateManyWithoutDepartAirportNestedInput
    arriveFlights?: flightUncheckedUpdateManyWithoutArriveAirportNestedInput
  }

  export type airportCreateManyInput = {
    airportCode: string
    name: string
    country: string
    city: string
    timezone: string
    latitude?: number | null
    longitude?: number | null
    altitude?: number | null
  }

  export type airportUpdateManyMutationInput = {
    airportCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type airportUncheckedUpdateManyInput = {
    airportCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bookingCreateInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    user: userCreateNestedOneWithoutBookingsInput
    bookingFlights?: booking_flightCreateNestedManyWithoutBookingInput
    passengerBookings?: passenger_bookingCreateNestedManyWithoutBookingInput
    tickets?: ticketCreateNestedManyWithoutBookingInput
    payment?: paymentCreateNestedOneWithoutBookingInput
  }

  export type bookingUncheckedCreateInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    userId: string
    bookingFlights?: booking_flightUncheckedCreateNestedManyWithoutBookingInput
    passengerBookings?: passenger_bookingUncheckedCreateNestedManyWithoutBookingInput
    tickets?: ticketUncheckedCreateNestedManyWithoutBookingInput
    payment?: paymentUncheckedCreateNestedOneWithoutBookingInput
  }

  export type bookingUpdateInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    user?: userUpdateOneRequiredWithoutBookingsNestedInput
    bookingFlights?: booking_flightUpdateManyWithoutBookingNestedInput
    passengerBookings?: passenger_bookingUpdateManyWithoutBookingNestedInput
    tickets?: ticketUpdateManyWithoutBookingNestedInput
    payment?: paymentUpdateOneWithoutBookingNestedInput
  }

  export type bookingUncheckedUpdateInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    bookingFlights?: booking_flightUncheckedUpdateManyWithoutBookingNestedInput
    passengerBookings?: passenger_bookingUncheckedUpdateManyWithoutBookingNestedInput
    tickets?: ticketUncheckedUpdateManyWithoutBookingNestedInput
    payment?: paymentUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type bookingCreateManyInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    userId: string
  }

  export type bookingUpdateManyMutationInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
  }

  export type bookingUncheckedUpdateManyInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type booking_flightCreateInput = {
    booking: bookingCreateNestedOneWithoutBookingFlightsInput
    flight: flightOperateCreateNestedOneWithoutBookingFlightsInput
  }

  export type booking_flightUncheckedCreateInput = {
    bookingId: string
    flightId: string
  }

  export type booking_flightUpdateInput = {
    booking?: bookingUpdateOneRequiredWithoutBookingFlightsNestedInput
    flight?: flightOperateUpdateOneRequiredWithoutBookingFlightsNestedInput
  }

  export type booking_flightUncheckedUpdateInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    flightId?: StringFieldUpdateOperationsInput | string
  }

  export type booking_flightCreateManyInput = {
    bookingId: string
    flightId: string
  }

  export type booking_flightUpdateManyMutationInput = {

  }

  export type booking_flightUncheckedUpdateManyInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    flightId?: StringFieldUpdateOperationsInput | string
  }

  export type flightCreateInput = {
    flightNum: string
    airline: airlineCreateNestedOneWithoutFlightInput
    departAirport: airportCreateNestedOneWithoutDepartFlightsInput
    arriveAirport: airportCreateNestedOneWithoutArriveFlightsInput
    flightOperates?: flightOperateCreateNestedManyWithoutFlightInput
    transitFrom?: transitCreateNestedManyWithoutFromInput
    transitTo?: transitCreateNestedManyWithoutToInput
  }

  export type flightUncheckedCreateInput = {
    flightNum: string
    airlineCode: string
    departAirportId: string
    arriveAirportId: string
    flightOperates?: flightOperateUncheckedCreateNestedManyWithoutFlightInput
    transitFrom?: transitUncheckedCreateNestedManyWithoutFromInput
    transitTo?: transitUncheckedCreateNestedManyWithoutToInput
  }

  export type flightUpdateInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airline?: airlineUpdateOneRequiredWithoutFlightNestedInput
    departAirport?: airportUpdateOneRequiredWithoutDepartFlightsNestedInput
    arriveAirport?: airportUpdateOneRequiredWithoutArriveFlightsNestedInput
    flightOperates?: flightOperateUpdateManyWithoutFlightNestedInput
    transitFrom?: transitUpdateManyWithoutFromNestedInput
    transitTo?: transitUpdateManyWithoutToNestedInput
  }

  export type flightUncheckedUpdateInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departAirportId?: StringFieldUpdateOperationsInput | string
    arriveAirportId?: StringFieldUpdateOperationsInput | string
    flightOperates?: flightOperateUncheckedUpdateManyWithoutFlightNestedInput
    transitFrom?: transitUncheckedUpdateManyWithoutFromNestedInput
    transitTo?: transitUncheckedUpdateManyWithoutToNestedInput
  }

  export type flightCreateManyInput = {
    flightNum: string
    airlineCode: string
    departAirportId: string
    arriveAirportId: string
  }

  export type flightUpdateManyMutationInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
  }

  export type flightUncheckedUpdateManyInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departAirportId?: StringFieldUpdateOperationsInput | string
    arriveAirportId?: StringFieldUpdateOperationsInput | string
  }

  export type flightOperateCreateInput = {
    flightId: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
    aircraft: aircraftCreateNestedOneWithoutFlightOperateInput
    flight: flightCreateNestedOneWithoutFlightOperatesInput
    bookingFlights?: booking_flightCreateNestedManyWithoutFlightInput
    tickets?: ticketCreateNestedManyWithoutFlightInput
  }

  export type flightOperateUncheckedCreateInput = {
    flightId: string
    flightNum: string
    airlineCode: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
    aircraftId: string
    bookingFlights?: booking_flightUncheckedCreateNestedManyWithoutFlightInput
    tickets?: ticketUncheckedCreateNestedManyWithoutFlightInput
  }

  export type flightOperateUpdateInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
    aircraft?: aircraftUpdateOneRequiredWithoutFlightOperateNestedInput
    flight?: flightUpdateOneRequiredWithoutFlightOperatesNestedInput
    bookingFlights?: booking_flightUpdateManyWithoutFlightNestedInput
    tickets?: ticketUpdateManyWithoutFlightNestedInput
  }

  export type flightOperateUncheckedUpdateInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    bookingFlights?: booking_flightUncheckedUpdateManyWithoutFlightNestedInput
    tickets?: ticketUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type flightOperateCreateManyInput = {
    flightId: string
    flightNum: string
    airlineCode: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
    aircraftId: string
  }

  export type flightOperateUpdateManyMutationInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
  }

  export type flightOperateUncheckedUpdateManyInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
  }

  export type passengerCreateInput = {
    passportNum: string
    passportCountry: string
    passportExpiry: Date | string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    ageRange: $Enums.AgeRange
    user: userCreateNestedOneWithoutPassengersInput
    passengerBookings?: passenger_bookingCreateNestedManyWithoutPassengerInput
    tickets?: ticketCreateNestedManyWithoutPassengerInput
  }

  export type passengerUncheckedCreateInput = {
    passportNum: string
    passportCountry: string
    passportExpiry: Date | string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    ageRange: $Enums.AgeRange
    userId: string
    passengerBookings?: passenger_bookingUncheckedCreateNestedManyWithoutPassengerInput
    tickets?: ticketUncheckedCreateNestedManyWithoutPassengerInput
  }

  export type passengerUpdateInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
    passportCountry?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    ageRange?: EnumAgeRangeFieldUpdateOperationsInput | $Enums.AgeRange
    user?: userUpdateOneRequiredWithoutPassengersNestedInput
    passengerBookings?: passenger_bookingUpdateManyWithoutPassengerNestedInput
    tickets?: ticketUpdateManyWithoutPassengerNestedInput
  }

  export type passengerUncheckedUpdateInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
    passportCountry?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    ageRange?: EnumAgeRangeFieldUpdateOperationsInput | $Enums.AgeRange
    userId?: StringFieldUpdateOperationsInput | string
    passengerBookings?: passenger_bookingUncheckedUpdateManyWithoutPassengerNestedInput
    tickets?: ticketUncheckedUpdateManyWithoutPassengerNestedInput
  }

  export type passengerCreateManyInput = {
    passportNum: string
    passportCountry: string
    passportExpiry: Date | string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    ageRange: $Enums.AgeRange
    userId: string
  }

  export type passengerUpdateManyMutationInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
    passportCountry?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    ageRange?: EnumAgeRangeFieldUpdateOperationsInput | $Enums.AgeRange
  }

  export type passengerUncheckedUpdateManyInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
    passportCountry?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    ageRange?: EnumAgeRangeFieldUpdateOperationsInput | $Enums.AgeRange
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type passenger_bookingCreateInput = {
    booking: bookingCreateNestedOneWithoutPassengerBookingsInput
    passenger: passengerCreateNestedOneWithoutPassengerBookingsInput
  }

  export type passenger_bookingUncheckedCreateInput = {
    bookingId: string
    passportNum: string
  }

  export type passenger_bookingUpdateInput = {
    booking?: bookingUpdateOneRequiredWithoutPassengerBookingsNestedInput
    passenger?: passengerUpdateOneRequiredWithoutPassengerBookingsNestedInput
  }

  export type passenger_bookingUncheckedUpdateInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    passportNum?: StringFieldUpdateOperationsInput | string
  }

  export type passenger_bookingCreateManyInput = {
    bookingId: string
    passportNum: string
  }

  export type passenger_bookingUpdateManyMutationInput = {

  }

  export type passenger_bookingUncheckedUpdateManyInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    passportNum?: StringFieldUpdateOperationsInput | string
  }

  export type paymentCreateInput = {
    paymentId: string
    amount?: number
    method: string
    paymentDate?: Date | string
    booking: bookingCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateInput = {
    paymentId: string
    amount?: number
    method: string
    paymentDate?: Date | string
    bookingId: string
  }

  export type paymentUpdateInput = {
    paymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: bookingUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateInput = {
    paymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingId?: StringFieldUpdateOperationsInput | string
  }

  export type paymentCreateManyInput = {
    paymentId: string
    amount?: number
    method: string
    paymentDate?: Date | string
    bookingId: string
  }

  export type paymentUpdateManyMutationInput = {
    paymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentUncheckedUpdateManyInput = {
    paymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingId?: StringFieldUpdateOperationsInput | string
  }

  export type aircraft_seatmapCreateInput = {
    aircraft: aircraftCreateNestedOneWithoutAircraftSeatmapInput
    seatmap: seatmap_infoCreateNestedOneWithoutAircraftInput
  }

  export type aircraft_seatmapUncheckedCreateInput = {
    aircraftId: string
    seatMapId: string
  }

  export type aircraft_seatmapUpdateInput = {
    aircraft?: aircraftUpdateOneRequiredWithoutAircraftSeatmapNestedInput
    seatmap?: seatmap_infoUpdateOneRequiredWithoutAircraftNestedInput
  }

  export type aircraft_seatmapUncheckedUpdateInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    seatMapId?: StringFieldUpdateOperationsInput | string
  }

  export type aircraft_seatmapCreateManyInput = {
    aircraftId: string
    seatMapId: string
  }

  export type aircraft_seatmapUpdateManyMutationInput = {

  }

  export type aircraft_seatmapUncheckedUpdateManyInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    seatMapId?: StringFieldUpdateOperationsInput | string
  }

  export type seatmap_infoCreateInput = {
    seatMapId: string
    airlineCode: string
    aircraftModel: string
    version: string
    seat?: seatCreateNestedManyWithoutSeatmapInput
    aircraft?: aircraft_seatmapCreateNestedManyWithoutSeatmapInput
  }

  export type seatmap_infoUncheckedCreateInput = {
    seatMapId: string
    airlineCode: string
    aircraftModel: string
    version: string
    seat?: seatUncheckedCreateNestedManyWithoutSeatmapInput
    aircraft?: aircraft_seatmapUncheckedCreateNestedManyWithoutSeatmapInput
  }

  export type seatmap_infoUpdateInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    aircraftModel?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    seat?: seatUpdateManyWithoutSeatmapNestedInput
    aircraft?: aircraft_seatmapUpdateManyWithoutSeatmapNestedInput
  }

  export type seatmap_infoUncheckedUpdateInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    aircraftModel?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    seat?: seatUncheckedUpdateManyWithoutSeatmapNestedInput
    aircraft?: aircraft_seatmapUncheckedUpdateManyWithoutSeatmapNestedInput
  }

  export type seatmap_infoCreateManyInput = {
    seatMapId: string
    airlineCode: string
    aircraftModel: string
    version: string
  }

  export type seatmap_infoUpdateManyMutationInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    aircraftModel?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type seatmap_infoUncheckedUpdateManyInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    aircraftModel?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type seatCreateInput = {
    seatId: string
    seatNum: string
    row?: number
    class?: $Enums.SeatClass
    price?: number
    features: string
    floor?: number
    tickets?: ticketCreateNestedManyWithoutSeatInput
    seatmap: seatmap_infoCreateNestedOneWithoutSeatInput
  }

  export type seatUncheckedCreateInput = {
    seatMapId: string
    seatId: string
    seatNum: string
    row?: number
    class?: $Enums.SeatClass
    price?: number
    features: string
    floor?: number
    tickets?: ticketUncheckedCreateNestedManyWithoutSeatInput
  }

  export type seatUpdateInput = {
    seatId?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
    row?: IntFieldUpdateOperationsInput | number
    class?: EnumSeatClassFieldUpdateOperationsInput | $Enums.SeatClass
    price?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    tickets?: ticketUpdateManyWithoutSeatNestedInput
    seatmap?: seatmap_infoUpdateOneRequiredWithoutSeatNestedInput
  }

  export type seatUncheckedUpdateInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
    row?: IntFieldUpdateOperationsInput | number
    class?: EnumSeatClassFieldUpdateOperationsInput | $Enums.SeatClass
    price?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    tickets?: ticketUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type seatCreateManyInput = {
    seatMapId: string
    seatId: string
    seatNum: string
    row?: number
    class?: $Enums.SeatClass
    price?: number
    features: string
    floor?: number
  }

  export type seatUpdateManyMutationInput = {
    seatId?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
    row?: IntFieldUpdateOperationsInput | number
    class?: EnumSeatClassFieldUpdateOperationsInput | $Enums.SeatClass
    price?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
  }

  export type seatUncheckedUpdateManyInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
    row?: IntFieldUpdateOperationsInput | number
    class?: EnumSeatClassFieldUpdateOperationsInput | $Enums.SeatClass
    price?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
  }

  export type ticketCreateInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    booking: bookingCreateNestedOneWithoutTicketsInput
    passenger: passengerCreateNestedOneWithoutTicketsInput
    flight: flightOperateCreateNestedOneWithoutTicketsInput
    seat: seatCreateNestedOneWithoutTicketsInput
  }

  export type ticketUncheckedCreateInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    bookingId: string
    flightId: string
    passportNum: string
    seatNum: string
  }

  export type ticketUpdateInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    booking?: bookingUpdateOneRequiredWithoutTicketsNestedInput
    passenger?: passengerUpdateOneRequiredWithoutTicketsNestedInput
    flight?: flightOperateUpdateOneRequiredWithoutTicketsNestedInput
    seat?: seatUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type ticketUncheckedUpdateInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    bookingId?: StringFieldUpdateOperationsInput | string
    flightId?: StringFieldUpdateOperationsInput | string
    passportNum?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
  }

  export type ticketCreateManyInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    bookingId: string
    flightId: string
    passportNum: string
    seatNum: string
  }

  export type ticketUpdateManyMutationInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type ticketUncheckedUpdateManyInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    bookingId?: StringFieldUpdateOperationsInput | string
    flightId?: StringFieldUpdateOperationsInput | string
    passportNum?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
  }

  export type transitCreateInput = {
    from: flightCreateNestedOneWithoutTransitFromInput
    to: flightCreateNestedOneWithoutTransitToInput
  }

  export type transitUncheckedCreateInput = {
    flightNumFrom: string
    airlineCodeFrom: string
    flightNumTo: string
    airlineCodeTo: string
  }

  export type transitUpdateInput = {
    from?: flightUpdateOneRequiredWithoutTransitFromNestedInput
    to?: flightUpdateOneRequiredWithoutTransitToNestedInput
  }

  export type transitUncheckedUpdateInput = {
    flightNumFrom?: StringFieldUpdateOperationsInput | string
    airlineCodeFrom?: StringFieldUpdateOperationsInput | string
    flightNumTo?: StringFieldUpdateOperationsInput | string
    airlineCodeTo?: StringFieldUpdateOperationsInput | string
  }

  export type transitCreateManyInput = {
    flightNumFrom: string
    airlineCodeFrom: string
    flightNumTo: string
    airlineCodeTo: string
  }

  export type transitUpdateManyMutationInput = {

  }

  export type transitUncheckedUpdateManyInput = {
    flightNumFrom?: StringFieldUpdateOperationsInput | string
    airlineCodeFrom?: StringFieldUpdateOperationsInput | string
    flightNumTo?: StringFieldUpdateOperationsInput | string
    airlineCodeTo?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateInput = {
    uuid?: string
    password: string
    firstname: string
    lastname: string
    email: string
    phone: string
    registerDate?: Date | string
    bookings?: bookingCreateNestedManyWithoutUserInput
    passengers?: passengerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    uuid?: string
    password: string
    firstname: string
    lastname: string
    email: string
    phone: string
    registerDate?: Date | string
    bookings?: bookingUncheckedCreateNestedManyWithoutUserInput
    passengers?: passengerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    registerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingUpdateManyWithoutUserNestedInput
    passengers?: passengerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    registerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingUncheckedUpdateManyWithoutUserNestedInput
    passengers?: passengerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    uuid?: string
    password: string
    firstname: string
    lastname: string
    email: string
    phone: string
    registerDate?: Date | string
  }

  export type userUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    registerDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    registerDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.Permission[]
    notIn?: $Enums.Permission[]
    not?: NestedEnumPermissionFilter<$PrismaModel> | $Enums.Permission
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type adminOrderByRelevanceInput = {
    fields: adminOrderByRelevanceFieldEnum | adminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type adminCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    fullname?: SortOrder
    permission?: SortOrder
  }

  export type adminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    fullname?: SortOrder
    permission?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    fullname?: SortOrder
    permission?: SortOrder
  }

  export type adminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.Permission[]
    notIn?: $Enums.Permission[]
    not?: NestedEnumPermissionWithAggregatesFilter<$PrismaModel> | $Enums.Permission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionFilter<$PrismaModel>
    _max?: NestedEnumPermissionFilter<$PrismaModel>
  }

  export type AircraftListRelationFilter = {
    every?: aircraftWhereInput
    some?: aircraftWhereInput
    none?: aircraftWhereInput
  }

  export type AircraftCostListRelationFilter = {
    every?: aircraftCostWhereInput
    some?: aircraftCostWhereInput
    none?: aircraftCostWhereInput
  }

  export type FlightListRelationFilter = {
    every?: flightWhereInput
    some?: flightWhereInput
    none?: flightWhereInput
  }

  export type aircraftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type aircraftCostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type flightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type airlineOrderByRelevanceInput = {
    fields: airlineOrderByRelevanceFieldEnum | airlineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type airlineCountOrderByAggregateInput = {
    airlineCode?: SortOrder
    airlineName?: SortOrder
  }

  export type airlineMaxOrderByAggregateInput = {
    airlineCode?: SortOrder
    airlineName?: SortOrder
  }

  export type airlineMinOrderByAggregateInput = {
    airlineCode?: SortOrder
    airlineName?: SortOrder
  }

  export type AirlineScalarRelationFilter = {
    is?: airlineWhereInput
    isNot?: airlineWhereInput
  }

  export type FlightOperateListRelationFilter = {
    every?: flightOperateWhereInput
    some?: flightOperateWhereInput
    none?: flightOperateWhereInput
  }

  export type Aircraft_seatmapListRelationFilter = {
    every?: aircraft_seatmapWhereInput
    some?: aircraft_seatmapWhereInput
    none?: aircraft_seatmapWhereInput
  }

  export type flightOperateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type aircraft_seatmapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type aircraftOrderByRelevanceInput = {
    fields: aircraftOrderByRelevanceFieldEnum | aircraftOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type aircraftCountOrderByAggregateInput = {
    aircraftId?: SortOrder
    ownerAirlineCode?: SortOrder
    model?: SortOrder
  }

  export type aircraftMaxOrderByAggregateInput = {
    aircraftId?: SortOrder
    ownerAirlineCode?: SortOrder
    model?: SortOrder
  }

  export type aircraftMinOrderByAggregateInput = {
    aircraftId?: SortOrder
    ownerAirlineCode?: SortOrder
    model?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type aircraftCostOrderByRelevanceInput = {
    fields: aircraftCostOrderByRelevanceFieldEnum | aircraftCostOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type aircraftCostModelOwnerAirlineCodeCompoundUniqueInput = {
    model: string
    ownerAirlineCode: string
  }

  export type aircraftCostCountOrderByAggregateInput = {
    model?: SortOrder
    ownerAirlineCode?: SortOrder
    costPerMile?: SortOrder
  }

  export type aircraftCostAvgOrderByAggregateInput = {
    costPerMile?: SortOrder
  }

  export type aircraftCostMaxOrderByAggregateInput = {
    model?: SortOrder
    ownerAirlineCode?: SortOrder
    costPerMile?: SortOrder
  }

  export type aircraftCostMinOrderByAggregateInput = {
    model?: SortOrder
    ownerAirlineCode?: SortOrder
    costPerMile?: SortOrder
  }

  export type aircraftCostSumOrderByAggregateInput = {
    costPerMile?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type airportOrderByRelevanceInput = {
    fields: airportOrderByRelevanceFieldEnum | airportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type airportCountOrderByAggregateInput = {
    airportCode?: SortOrder
    name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    timezone?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    altitude?: SortOrder
  }

  export type airportAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    altitude?: SortOrder
  }

  export type airportMaxOrderByAggregateInput = {
    airportCode?: SortOrder
    name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    timezone?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    altitude?: SortOrder
  }

  export type airportMinOrderByAggregateInput = {
    airportCode?: SortOrder
    name?: SortOrder
    country?: SortOrder
    city?: SortOrder
    timezone?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    altitude?: SortOrder
  }

  export type airportSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    altitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type Booking_flightListRelationFilter = {
    every?: booking_flightWhereInput
    some?: booking_flightWhereInput
    none?: booking_flightWhereInput
  }

  export type Passenger_bookingListRelationFilter = {
    every?: passenger_bookingWhereInput
    some?: passenger_bookingWhereInput
    none?: passenger_bookingWhereInput
  }

  export type TicketListRelationFilter = {
    every?: ticketWhereInput
    some?: ticketWhereInput
    none?: ticketWhereInput
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: paymentWhereInput | null
    isNot?: paymentWhereInput | null
  }

  export type booking_flightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type passenger_bookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ticketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bookingOrderByRelevanceInput = {
    fields: bookingOrderByRelevanceFieldEnum | bookingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type bookingCountOrderByAggregateInput = {
    bookingId?: SortOrder
    bookingDate?: SortOrder
    status?: SortOrder
    userId?: SortOrder
  }

  export type bookingMaxOrderByAggregateInput = {
    bookingId?: SortOrder
    bookingDate?: SortOrder
    status?: SortOrder
    userId?: SortOrder
  }

  export type bookingMinOrderByAggregateInput = {
    bookingId?: SortOrder
    bookingDate?: SortOrder
    status?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type BookingScalarRelationFilter = {
    is?: bookingWhereInput
    isNot?: bookingWhereInput
  }

  export type FlightOperateScalarRelationFilter = {
    is?: flightOperateWhereInput
    isNot?: flightOperateWhereInput
  }

  export type booking_flightOrderByRelevanceInput = {
    fields: booking_flightOrderByRelevanceFieldEnum | booking_flightOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type booking_flightBookingIdFlightIdCompoundUniqueInput = {
    bookingId: string
    flightId: string
  }

  export type booking_flightCountOrderByAggregateInput = {
    bookingId?: SortOrder
    flightId?: SortOrder
  }

  export type booking_flightMaxOrderByAggregateInput = {
    bookingId?: SortOrder
    flightId?: SortOrder
  }

  export type booking_flightMinOrderByAggregateInput = {
    bookingId?: SortOrder
    flightId?: SortOrder
  }

  export type AirportScalarRelationFilter = {
    is?: airportWhereInput
    isNot?: airportWhereInput
  }

  export type TransitListRelationFilter = {
    every?: transitWhereInput
    some?: transitWhereInput
    none?: transitWhereInput
  }

  export type transitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type flightOrderByRelevanceInput = {
    fields: flightOrderByRelevanceFieldEnum | flightOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type flightFlightNumAirlineCodeCompoundUniqueInput = {
    flightNum: string
    airlineCode: string
  }

  export type flightCountOrderByAggregateInput = {
    flightNum?: SortOrder
    airlineCode?: SortOrder
    departAirportId?: SortOrder
    arriveAirportId?: SortOrder
  }

  export type flightMaxOrderByAggregateInput = {
    flightNum?: SortOrder
    airlineCode?: SortOrder
    departAirportId?: SortOrder
    arriveAirportId?: SortOrder
  }

  export type flightMinOrderByAggregateInput = {
    flightNum?: SortOrder
    airlineCode?: SortOrder
    departAirportId?: SortOrder
    arriveAirportId?: SortOrder
  }

  export type AircraftScalarRelationFilter = {
    is?: aircraftWhereInput
    isNot?: aircraftWhereInput
  }

  export type FlightScalarRelationFilter = {
    is?: flightWhereInput
    isNot?: flightWhereInput
  }

  export type flightOperateOrderByRelevanceInput = {
    fields: flightOperateOrderByRelevanceFieldEnum | flightOperateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type flightOperateFlightNumAirlineCodeDepartureTimeCompoundUniqueInput = {
    flightNum: string
    airlineCode: string
    departureTime: Date | string
  }

  export type flightOperateCountOrderByAggregateInput = {
    flightId?: SortOrder
    flightNum?: SortOrder
    airlineCode?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    departureGate?: SortOrder
    aircraftId?: SortOrder
  }

  export type flightOperateMaxOrderByAggregateInput = {
    flightId?: SortOrder
    flightNum?: SortOrder
    airlineCode?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    departureGate?: SortOrder
    aircraftId?: SortOrder
  }

  export type flightOperateMinOrderByAggregateInput = {
    flightId?: SortOrder
    flightNum?: SortOrder
    airlineCode?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    departureGate?: SortOrder
    aircraftId?: SortOrder
  }

  export type EnumAgeRangeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRange | EnumAgeRangeFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRange[]
    notIn?: $Enums.AgeRange[]
    not?: NestedEnumAgeRangeFilter<$PrismaModel> | $Enums.AgeRange
  }

  export type passengerOrderByRelevanceInput = {
    fields: passengerOrderByRelevanceFieldEnum | passengerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type passengerCountOrderByAggregateInput = {
    passportNum?: SortOrder
    passportCountry?: SortOrder
    passportExpiry?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    ageRange?: SortOrder
    userId?: SortOrder
  }

  export type passengerMaxOrderByAggregateInput = {
    passportNum?: SortOrder
    passportCountry?: SortOrder
    passportExpiry?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    ageRange?: SortOrder
    userId?: SortOrder
  }

  export type passengerMinOrderByAggregateInput = {
    passportNum?: SortOrder
    passportCountry?: SortOrder
    passportExpiry?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    ageRange?: SortOrder
    userId?: SortOrder
  }

  export type EnumAgeRangeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRange | EnumAgeRangeFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRange[]
    notIn?: $Enums.AgeRange[]
    not?: NestedEnumAgeRangeWithAggregatesFilter<$PrismaModel> | $Enums.AgeRange
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgeRangeFilter<$PrismaModel>
    _max?: NestedEnumAgeRangeFilter<$PrismaModel>
  }

  export type PassengerScalarRelationFilter = {
    is?: passengerWhereInput
    isNot?: passengerWhereInput
  }

  export type passenger_bookingOrderByRelevanceInput = {
    fields: passenger_bookingOrderByRelevanceFieldEnum | passenger_bookingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type passenger_bookingBookingIdPassportNumCompoundUniqueInput = {
    bookingId: string
    passportNum: string
  }

  export type passenger_bookingCountOrderByAggregateInput = {
    bookingId?: SortOrder
    passportNum?: SortOrder
  }

  export type passenger_bookingMaxOrderByAggregateInput = {
    bookingId?: SortOrder
    passportNum?: SortOrder
  }

  export type passenger_bookingMinOrderByAggregateInput = {
    bookingId?: SortOrder
    passportNum?: SortOrder
  }

  export type paymentOrderByRelevanceInput = {
    fields: paymentOrderByRelevanceFieldEnum | paymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type paymentCountOrderByAggregateInput = {
    paymentId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    paymentDate?: SortOrder
    bookingId?: SortOrder
  }

  export type paymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    paymentId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    paymentDate?: SortOrder
    bookingId?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    paymentId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    paymentDate?: SortOrder
    bookingId?: SortOrder
  }

  export type paymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Seatmap_infoScalarRelationFilter = {
    is?: seatmap_infoWhereInput
    isNot?: seatmap_infoWhereInput
  }

  export type aircraft_seatmapOrderByRelevanceInput = {
    fields: aircraft_seatmapOrderByRelevanceFieldEnum | aircraft_seatmapOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type aircraft_seatmapAircraftIdSeatMapIdCompoundUniqueInput = {
    aircraftId: string
    seatMapId: string
  }

  export type aircraft_seatmapCountOrderByAggregateInput = {
    aircraftId?: SortOrder
    seatMapId?: SortOrder
  }

  export type aircraft_seatmapMaxOrderByAggregateInput = {
    aircraftId?: SortOrder
    seatMapId?: SortOrder
  }

  export type aircraft_seatmapMinOrderByAggregateInput = {
    aircraftId?: SortOrder
    seatMapId?: SortOrder
  }

  export type SeatListRelationFilter = {
    every?: seatWhereInput
    some?: seatWhereInput
    none?: seatWhereInput
  }

  export type seatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type seatmap_infoOrderByRelevanceInput = {
    fields: seatmap_infoOrderByRelevanceFieldEnum | seatmap_infoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type seatmap_infoCountOrderByAggregateInput = {
    seatMapId?: SortOrder
    airlineCode?: SortOrder
    aircraftModel?: SortOrder
    version?: SortOrder
  }

  export type seatmap_infoMaxOrderByAggregateInput = {
    seatMapId?: SortOrder
    airlineCode?: SortOrder
    aircraftModel?: SortOrder
    version?: SortOrder
  }

  export type seatmap_infoMinOrderByAggregateInput = {
    seatMapId?: SortOrder
    airlineCode?: SortOrder
    aircraftModel?: SortOrder
    version?: SortOrder
  }

  export type EnumSeatClassFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatClass | EnumSeatClassFieldRefInput<$PrismaModel>
    in?: $Enums.SeatClass[]
    notIn?: $Enums.SeatClass[]
    not?: NestedEnumSeatClassFilter<$PrismaModel> | $Enums.SeatClass
  }

  export type seatOrderByRelevanceInput = {
    fields: seatOrderByRelevanceFieldEnum | seatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type seatSeatMapIdSeatIdCompoundUniqueInput = {
    seatMapId: string
    seatId: string
  }

  export type seatCountOrderByAggregateInput = {
    seatMapId?: SortOrder
    seatId?: SortOrder
    seatNum?: SortOrder
    row?: SortOrder
    class?: SortOrder
    price?: SortOrder
    features?: SortOrder
    floor?: SortOrder
  }

  export type seatAvgOrderByAggregateInput = {
    row?: SortOrder
    price?: SortOrder
    floor?: SortOrder
  }

  export type seatMaxOrderByAggregateInput = {
    seatMapId?: SortOrder
    seatId?: SortOrder
    seatNum?: SortOrder
    row?: SortOrder
    class?: SortOrder
    price?: SortOrder
    features?: SortOrder
    floor?: SortOrder
  }

  export type seatMinOrderByAggregateInput = {
    seatMapId?: SortOrder
    seatId?: SortOrder
    seatNum?: SortOrder
    row?: SortOrder
    class?: SortOrder
    price?: SortOrder
    features?: SortOrder
    floor?: SortOrder
  }

  export type seatSumOrderByAggregateInput = {
    row?: SortOrder
    price?: SortOrder
    floor?: SortOrder
  }

  export type EnumSeatClassWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatClass | EnumSeatClassFieldRefInput<$PrismaModel>
    in?: $Enums.SeatClass[]
    notIn?: $Enums.SeatClass[]
    not?: NestedEnumSeatClassWithAggregatesFilter<$PrismaModel> | $Enums.SeatClass
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeatClassFilter<$PrismaModel>
    _max?: NestedEnumSeatClassFilter<$PrismaModel>
  }

  export type EnumFarePackageFilter<$PrismaModel = never> = {
    equals?: $Enums.FarePackage | EnumFarePackageFieldRefInput<$PrismaModel>
    in?: $Enums.FarePackage[]
    notIn?: $Enums.FarePackage[]
    not?: NestedEnumFarePackageFilter<$PrismaModel> | $Enums.FarePackage
  }

  export type SeatScalarRelationFilter = {
    is?: seatWhereInput
    isNot?: seatWhereInput
  }

  export type ticketOrderByRelevanceInput = {
    fields: ticketOrderByRelevanceFieldEnum | ticketOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ticketCountOrderByAggregateInput = {
    ticketNum?: SortOrder
    farePackage?: SortOrder
    baggageAllowanceWeight?: SortOrder
    baggageAllowancePrice?: SortOrder
    mealSelection?: SortOrder
    mealPrice?: SortOrder
    ticketPrice?: SortOrder
    bookingId?: SortOrder
    flightId?: SortOrder
    passportNum?: SortOrder
    seatNum?: SortOrder
  }

  export type ticketAvgOrderByAggregateInput = {
    baggageAllowanceWeight?: SortOrder
    baggageAllowancePrice?: SortOrder
    mealPrice?: SortOrder
    ticketPrice?: SortOrder
  }

  export type ticketMaxOrderByAggregateInput = {
    ticketNum?: SortOrder
    farePackage?: SortOrder
    baggageAllowanceWeight?: SortOrder
    baggageAllowancePrice?: SortOrder
    mealSelection?: SortOrder
    mealPrice?: SortOrder
    ticketPrice?: SortOrder
    bookingId?: SortOrder
    flightId?: SortOrder
    passportNum?: SortOrder
    seatNum?: SortOrder
  }

  export type ticketMinOrderByAggregateInput = {
    ticketNum?: SortOrder
    farePackage?: SortOrder
    baggageAllowanceWeight?: SortOrder
    baggageAllowancePrice?: SortOrder
    mealSelection?: SortOrder
    mealPrice?: SortOrder
    ticketPrice?: SortOrder
    bookingId?: SortOrder
    flightId?: SortOrder
    passportNum?: SortOrder
    seatNum?: SortOrder
  }

  export type ticketSumOrderByAggregateInput = {
    baggageAllowanceWeight?: SortOrder
    baggageAllowancePrice?: SortOrder
    mealPrice?: SortOrder
    ticketPrice?: SortOrder
  }

  export type EnumFarePackageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FarePackage | EnumFarePackageFieldRefInput<$PrismaModel>
    in?: $Enums.FarePackage[]
    notIn?: $Enums.FarePackage[]
    not?: NestedEnumFarePackageWithAggregatesFilter<$PrismaModel> | $Enums.FarePackage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFarePackageFilter<$PrismaModel>
    _max?: NestedEnumFarePackageFilter<$PrismaModel>
  }

  export type transitOrderByRelevanceInput = {
    fields: transitOrderByRelevanceFieldEnum | transitOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type transitFlightNumFromAirlineCodeFromFlightNumToAirlineCodeToCompoundUniqueInput = {
    flightNumFrom: string
    airlineCodeFrom: string
    flightNumTo: string
    airlineCodeTo: string
  }

  export type transitCountOrderByAggregateInput = {
    flightNumFrom?: SortOrder
    airlineCodeFrom?: SortOrder
    flightNumTo?: SortOrder
    airlineCodeTo?: SortOrder
  }

  export type transitMaxOrderByAggregateInput = {
    flightNumFrom?: SortOrder
    airlineCodeFrom?: SortOrder
    flightNumTo?: SortOrder
    airlineCodeTo?: SortOrder
  }

  export type transitMinOrderByAggregateInput = {
    flightNumFrom?: SortOrder
    airlineCodeFrom?: SortOrder
    flightNumTo?: SortOrder
    airlineCodeTo?: SortOrder
  }

  export type BookingListRelationFilter = {
    every?: bookingWhereInput
    some?: bookingWhereInput
    none?: bookingWhereInput
  }

  export type PassengerListRelationFilter = {
    every?: passengerWhereInput
    some?: passengerWhereInput
    none?: passengerWhereInput
  }

  export type bookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type passengerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    uuid?: SortOrder
    password?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    registerDate?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    uuid?: SortOrder
    password?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    registerDate?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    uuid?: SortOrder
    password?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    registerDate?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumPermissionFieldUpdateOperationsInput = {
    set?: $Enums.Permission
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type aircraftCreateNestedManyWithoutAirlineInput = {
    create?: XOR<aircraftCreateWithoutAirlineInput, aircraftUncheckedCreateWithoutAirlineInput> | aircraftCreateWithoutAirlineInput[] | aircraftUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: aircraftCreateOrConnectWithoutAirlineInput | aircraftCreateOrConnectWithoutAirlineInput[]
    createMany?: aircraftCreateManyAirlineInputEnvelope
    connect?: aircraftWhereUniqueInput | aircraftWhereUniqueInput[]
  }

  export type aircraftCostCreateNestedManyWithoutAirlineInput = {
    create?: XOR<aircraftCostCreateWithoutAirlineInput, aircraftCostUncheckedCreateWithoutAirlineInput> | aircraftCostCreateWithoutAirlineInput[] | aircraftCostUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: aircraftCostCreateOrConnectWithoutAirlineInput | aircraftCostCreateOrConnectWithoutAirlineInput[]
    createMany?: aircraftCostCreateManyAirlineInputEnvelope
    connect?: aircraftCostWhereUniqueInput | aircraftCostWhereUniqueInput[]
  }

  export type flightCreateNestedManyWithoutAirlineInput = {
    create?: XOR<flightCreateWithoutAirlineInput, flightUncheckedCreateWithoutAirlineInput> | flightCreateWithoutAirlineInput[] | flightUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: flightCreateOrConnectWithoutAirlineInput | flightCreateOrConnectWithoutAirlineInput[]
    createMany?: flightCreateManyAirlineInputEnvelope
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
  }

  export type aircraftUncheckedCreateNestedManyWithoutAirlineInput = {
    create?: XOR<aircraftCreateWithoutAirlineInput, aircraftUncheckedCreateWithoutAirlineInput> | aircraftCreateWithoutAirlineInput[] | aircraftUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: aircraftCreateOrConnectWithoutAirlineInput | aircraftCreateOrConnectWithoutAirlineInput[]
    createMany?: aircraftCreateManyAirlineInputEnvelope
    connect?: aircraftWhereUniqueInput | aircraftWhereUniqueInput[]
  }

  export type aircraftCostUncheckedCreateNestedManyWithoutAirlineInput = {
    create?: XOR<aircraftCostCreateWithoutAirlineInput, aircraftCostUncheckedCreateWithoutAirlineInput> | aircraftCostCreateWithoutAirlineInput[] | aircraftCostUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: aircraftCostCreateOrConnectWithoutAirlineInput | aircraftCostCreateOrConnectWithoutAirlineInput[]
    createMany?: aircraftCostCreateManyAirlineInputEnvelope
    connect?: aircraftCostWhereUniqueInput | aircraftCostWhereUniqueInput[]
  }

  export type flightUncheckedCreateNestedManyWithoutAirlineInput = {
    create?: XOR<flightCreateWithoutAirlineInput, flightUncheckedCreateWithoutAirlineInput> | flightCreateWithoutAirlineInput[] | flightUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: flightCreateOrConnectWithoutAirlineInput | flightCreateOrConnectWithoutAirlineInput[]
    createMany?: flightCreateManyAirlineInputEnvelope
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
  }

  export type aircraftUpdateManyWithoutAirlineNestedInput = {
    create?: XOR<aircraftCreateWithoutAirlineInput, aircraftUncheckedCreateWithoutAirlineInput> | aircraftCreateWithoutAirlineInput[] | aircraftUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: aircraftCreateOrConnectWithoutAirlineInput | aircraftCreateOrConnectWithoutAirlineInput[]
    upsert?: aircraftUpsertWithWhereUniqueWithoutAirlineInput | aircraftUpsertWithWhereUniqueWithoutAirlineInput[]
    createMany?: aircraftCreateManyAirlineInputEnvelope
    set?: aircraftWhereUniqueInput | aircraftWhereUniqueInput[]
    disconnect?: aircraftWhereUniqueInput | aircraftWhereUniqueInput[]
    delete?: aircraftWhereUniqueInput | aircraftWhereUniqueInput[]
    connect?: aircraftWhereUniqueInput | aircraftWhereUniqueInput[]
    update?: aircraftUpdateWithWhereUniqueWithoutAirlineInput | aircraftUpdateWithWhereUniqueWithoutAirlineInput[]
    updateMany?: aircraftUpdateManyWithWhereWithoutAirlineInput | aircraftUpdateManyWithWhereWithoutAirlineInput[]
    deleteMany?: aircraftScalarWhereInput | aircraftScalarWhereInput[]
  }

  export type aircraftCostUpdateManyWithoutAirlineNestedInput = {
    create?: XOR<aircraftCostCreateWithoutAirlineInput, aircraftCostUncheckedCreateWithoutAirlineInput> | aircraftCostCreateWithoutAirlineInput[] | aircraftCostUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: aircraftCostCreateOrConnectWithoutAirlineInput | aircraftCostCreateOrConnectWithoutAirlineInput[]
    upsert?: aircraftCostUpsertWithWhereUniqueWithoutAirlineInput | aircraftCostUpsertWithWhereUniqueWithoutAirlineInput[]
    createMany?: aircraftCostCreateManyAirlineInputEnvelope
    set?: aircraftCostWhereUniqueInput | aircraftCostWhereUniqueInput[]
    disconnect?: aircraftCostWhereUniqueInput | aircraftCostWhereUniqueInput[]
    delete?: aircraftCostWhereUniqueInput | aircraftCostWhereUniqueInput[]
    connect?: aircraftCostWhereUniqueInput | aircraftCostWhereUniqueInput[]
    update?: aircraftCostUpdateWithWhereUniqueWithoutAirlineInput | aircraftCostUpdateWithWhereUniqueWithoutAirlineInput[]
    updateMany?: aircraftCostUpdateManyWithWhereWithoutAirlineInput | aircraftCostUpdateManyWithWhereWithoutAirlineInput[]
    deleteMany?: aircraftCostScalarWhereInput | aircraftCostScalarWhereInput[]
  }

  export type flightUpdateManyWithoutAirlineNestedInput = {
    create?: XOR<flightCreateWithoutAirlineInput, flightUncheckedCreateWithoutAirlineInput> | flightCreateWithoutAirlineInput[] | flightUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: flightCreateOrConnectWithoutAirlineInput | flightCreateOrConnectWithoutAirlineInput[]
    upsert?: flightUpsertWithWhereUniqueWithoutAirlineInput | flightUpsertWithWhereUniqueWithoutAirlineInput[]
    createMany?: flightCreateManyAirlineInputEnvelope
    set?: flightWhereUniqueInput | flightWhereUniqueInput[]
    disconnect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    delete?: flightWhereUniqueInput | flightWhereUniqueInput[]
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    update?: flightUpdateWithWhereUniqueWithoutAirlineInput | flightUpdateWithWhereUniqueWithoutAirlineInput[]
    updateMany?: flightUpdateManyWithWhereWithoutAirlineInput | flightUpdateManyWithWhereWithoutAirlineInput[]
    deleteMany?: flightScalarWhereInput | flightScalarWhereInput[]
  }

  export type aircraftUncheckedUpdateManyWithoutAirlineNestedInput = {
    create?: XOR<aircraftCreateWithoutAirlineInput, aircraftUncheckedCreateWithoutAirlineInput> | aircraftCreateWithoutAirlineInput[] | aircraftUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: aircraftCreateOrConnectWithoutAirlineInput | aircraftCreateOrConnectWithoutAirlineInput[]
    upsert?: aircraftUpsertWithWhereUniqueWithoutAirlineInput | aircraftUpsertWithWhereUniqueWithoutAirlineInput[]
    createMany?: aircraftCreateManyAirlineInputEnvelope
    set?: aircraftWhereUniqueInput | aircraftWhereUniqueInput[]
    disconnect?: aircraftWhereUniqueInput | aircraftWhereUniqueInput[]
    delete?: aircraftWhereUniqueInput | aircraftWhereUniqueInput[]
    connect?: aircraftWhereUniqueInput | aircraftWhereUniqueInput[]
    update?: aircraftUpdateWithWhereUniqueWithoutAirlineInput | aircraftUpdateWithWhereUniqueWithoutAirlineInput[]
    updateMany?: aircraftUpdateManyWithWhereWithoutAirlineInput | aircraftUpdateManyWithWhereWithoutAirlineInput[]
    deleteMany?: aircraftScalarWhereInput | aircraftScalarWhereInput[]
  }

  export type aircraftCostUncheckedUpdateManyWithoutAirlineNestedInput = {
    create?: XOR<aircraftCostCreateWithoutAirlineInput, aircraftCostUncheckedCreateWithoutAirlineInput> | aircraftCostCreateWithoutAirlineInput[] | aircraftCostUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: aircraftCostCreateOrConnectWithoutAirlineInput | aircraftCostCreateOrConnectWithoutAirlineInput[]
    upsert?: aircraftCostUpsertWithWhereUniqueWithoutAirlineInput | aircraftCostUpsertWithWhereUniqueWithoutAirlineInput[]
    createMany?: aircraftCostCreateManyAirlineInputEnvelope
    set?: aircraftCostWhereUniqueInput | aircraftCostWhereUniqueInput[]
    disconnect?: aircraftCostWhereUniqueInput | aircraftCostWhereUniqueInput[]
    delete?: aircraftCostWhereUniqueInput | aircraftCostWhereUniqueInput[]
    connect?: aircraftCostWhereUniqueInput | aircraftCostWhereUniqueInput[]
    update?: aircraftCostUpdateWithWhereUniqueWithoutAirlineInput | aircraftCostUpdateWithWhereUniqueWithoutAirlineInput[]
    updateMany?: aircraftCostUpdateManyWithWhereWithoutAirlineInput | aircraftCostUpdateManyWithWhereWithoutAirlineInput[]
    deleteMany?: aircraftCostScalarWhereInput | aircraftCostScalarWhereInput[]
  }

  export type flightUncheckedUpdateManyWithoutAirlineNestedInput = {
    create?: XOR<flightCreateWithoutAirlineInput, flightUncheckedCreateWithoutAirlineInput> | flightCreateWithoutAirlineInput[] | flightUncheckedCreateWithoutAirlineInput[]
    connectOrCreate?: flightCreateOrConnectWithoutAirlineInput | flightCreateOrConnectWithoutAirlineInput[]
    upsert?: flightUpsertWithWhereUniqueWithoutAirlineInput | flightUpsertWithWhereUniqueWithoutAirlineInput[]
    createMany?: flightCreateManyAirlineInputEnvelope
    set?: flightWhereUniqueInput | flightWhereUniqueInput[]
    disconnect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    delete?: flightWhereUniqueInput | flightWhereUniqueInput[]
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    update?: flightUpdateWithWhereUniqueWithoutAirlineInput | flightUpdateWithWhereUniqueWithoutAirlineInput[]
    updateMany?: flightUpdateManyWithWhereWithoutAirlineInput | flightUpdateManyWithWhereWithoutAirlineInput[]
    deleteMany?: flightScalarWhereInput | flightScalarWhereInput[]
  }

  export type airlineCreateNestedOneWithoutAircraftInput = {
    create?: XOR<airlineCreateWithoutAircraftInput, airlineUncheckedCreateWithoutAircraftInput>
    connectOrCreate?: airlineCreateOrConnectWithoutAircraftInput
    connect?: airlineWhereUniqueInput
  }

  export type flightOperateCreateNestedManyWithoutAircraftInput = {
    create?: XOR<flightOperateCreateWithoutAircraftInput, flightOperateUncheckedCreateWithoutAircraftInput> | flightOperateCreateWithoutAircraftInput[] | flightOperateUncheckedCreateWithoutAircraftInput[]
    connectOrCreate?: flightOperateCreateOrConnectWithoutAircraftInput | flightOperateCreateOrConnectWithoutAircraftInput[]
    createMany?: flightOperateCreateManyAircraftInputEnvelope
    connect?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
  }

  export type aircraft_seatmapCreateNestedManyWithoutAircraftInput = {
    create?: XOR<aircraft_seatmapCreateWithoutAircraftInput, aircraft_seatmapUncheckedCreateWithoutAircraftInput> | aircraft_seatmapCreateWithoutAircraftInput[] | aircraft_seatmapUncheckedCreateWithoutAircraftInput[]
    connectOrCreate?: aircraft_seatmapCreateOrConnectWithoutAircraftInput | aircraft_seatmapCreateOrConnectWithoutAircraftInput[]
    createMany?: aircraft_seatmapCreateManyAircraftInputEnvelope
    connect?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
  }

  export type flightOperateUncheckedCreateNestedManyWithoutAircraftInput = {
    create?: XOR<flightOperateCreateWithoutAircraftInput, flightOperateUncheckedCreateWithoutAircraftInput> | flightOperateCreateWithoutAircraftInput[] | flightOperateUncheckedCreateWithoutAircraftInput[]
    connectOrCreate?: flightOperateCreateOrConnectWithoutAircraftInput | flightOperateCreateOrConnectWithoutAircraftInput[]
    createMany?: flightOperateCreateManyAircraftInputEnvelope
    connect?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
  }

  export type aircraft_seatmapUncheckedCreateNestedManyWithoutAircraftInput = {
    create?: XOR<aircraft_seatmapCreateWithoutAircraftInput, aircraft_seatmapUncheckedCreateWithoutAircraftInput> | aircraft_seatmapCreateWithoutAircraftInput[] | aircraft_seatmapUncheckedCreateWithoutAircraftInput[]
    connectOrCreate?: aircraft_seatmapCreateOrConnectWithoutAircraftInput | aircraft_seatmapCreateOrConnectWithoutAircraftInput[]
    createMany?: aircraft_seatmapCreateManyAircraftInputEnvelope
    connect?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
  }

  export type airlineUpdateOneRequiredWithoutAircraftNestedInput = {
    create?: XOR<airlineCreateWithoutAircraftInput, airlineUncheckedCreateWithoutAircraftInput>
    connectOrCreate?: airlineCreateOrConnectWithoutAircraftInput
    upsert?: airlineUpsertWithoutAircraftInput
    connect?: airlineWhereUniqueInput
    update?: XOR<XOR<airlineUpdateToOneWithWhereWithoutAircraftInput, airlineUpdateWithoutAircraftInput>, airlineUncheckedUpdateWithoutAircraftInput>
  }

  export type flightOperateUpdateManyWithoutAircraftNestedInput = {
    create?: XOR<flightOperateCreateWithoutAircraftInput, flightOperateUncheckedCreateWithoutAircraftInput> | flightOperateCreateWithoutAircraftInput[] | flightOperateUncheckedCreateWithoutAircraftInput[]
    connectOrCreate?: flightOperateCreateOrConnectWithoutAircraftInput | flightOperateCreateOrConnectWithoutAircraftInput[]
    upsert?: flightOperateUpsertWithWhereUniqueWithoutAircraftInput | flightOperateUpsertWithWhereUniqueWithoutAircraftInput[]
    createMany?: flightOperateCreateManyAircraftInputEnvelope
    set?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    disconnect?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    delete?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    connect?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    update?: flightOperateUpdateWithWhereUniqueWithoutAircraftInput | flightOperateUpdateWithWhereUniqueWithoutAircraftInput[]
    updateMany?: flightOperateUpdateManyWithWhereWithoutAircraftInput | flightOperateUpdateManyWithWhereWithoutAircraftInput[]
    deleteMany?: flightOperateScalarWhereInput | flightOperateScalarWhereInput[]
  }

  export type aircraft_seatmapUpdateManyWithoutAircraftNestedInput = {
    create?: XOR<aircraft_seatmapCreateWithoutAircraftInput, aircraft_seatmapUncheckedCreateWithoutAircraftInput> | aircraft_seatmapCreateWithoutAircraftInput[] | aircraft_seatmapUncheckedCreateWithoutAircraftInput[]
    connectOrCreate?: aircraft_seatmapCreateOrConnectWithoutAircraftInput | aircraft_seatmapCreateOrConnectWithoutAircraftInput[]
    upsert?: aircraft_seatmapUpsertWithWhereUniqueWithoutAircraftInput | aircraft_seatmapUpsertWithWhereUniqueWithoutAircraftInput[]
    createMany?: aircraft_seatmapCreateManyAircraftInputEnvelope
    set?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    disconnect?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    delete?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    connect?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    update?: aircraft_seatmapUpdateWithWhereUniqueWithoutAircraftInput | aircraft_seatmapUpdateWithWhereUniqueWithoutAircraftInput[]
    updateMany?: aircraft_seatmapUpdateManyWithWhereWithoutAircraftInput | aircraft_seatmapUpdateManyWithWhereWithoutAircraftInput[]
    deleteMany?: aircraft_seatmapScalarWhereInput | aircraft_seatmapScalarWhereInput[]
  }

  export type flightOperateUncheckedUpdateManyWithoutAircraftNestedInput = {
    create?: XOR<flightOperateCreateWithoutAircraftInput, flightOperateUncheckedCreateWithoutAircraftInput> | flightOperateCreateWithoutAircraftInput[] | flightOperateUncheckedCreateWithoutAircraftInput[]
    connectOrCreate?: flightOperateCreateOrConnectWithoutAircraftInput | flightOperateCreateOrConnectWithoutAircraftInput[]
    upsert?: flightOperateUpsertWithWhereUniqueWithoutAircraftInput | flightOperateUpsertWithWhereUniqueWithoutAircraftInput[]
    createMany?: flightOperateCreateManyAircraftInputEnvelope
    set?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    disconnect?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    delete?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    connect?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    update?: flightOperateUpdateWithWhereUniqueWithoutAircraftInput | flightOperateUpdateWithWhereUniqueWithoutAircraftInput[]
    updateMany?: flightOperateUpdateManyWithWhereWithoutAircraftInput | flightOperateUpdateManyWithWhereWithoutAircraftInput[]
    deleteMany?: flightOperateScalarWhereInput | flightOperateScalarWhereInput[]
  }

  export type aircraft_seatmapUncheckedUpdateManyWithoutAircraftNestedInput = {
    create?: XOR<aircraft_seatmapCreateWithoutAircraftInput, aircraft_seatmapUncheckedCreateWithoutAircraftInput> | aircraft_seatmapCreateWithoutAircraftInput[] | aircraft_seatmapUncheckedCreateWithoutAircraftInput[]
    connectOrCreate?: aircraft_seatmapCreateOrConnectWithoutAircraftInput | aircraft_seatmapCreateOrConnectWithoutAircraftInput[]
    upsert?: aircraft_seatmapUpsertWithWhereUniqueWithoutAircraftInput | aircraft_seatmapUpsertWithWhereUniqueWithoutAircraftInput[]
    createMany?: aircraft_seatmapCreateManyAircraftInputEnvelope
    set?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    disconnect?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    delete?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    connect?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    update?: aircraft_seatmapUpdateWithWhereUniqueWithoutAircraftInput | aircraft_seatmapUpdateWithWhereUniqueWithoutAircraftInput[]
    updateMany?: aircraft_seatmapUpdateManyWithWhereWithoutAircraftInput | aircraft_seatmapUpdateManyWithWhereWithoutAircraftInput[]
    deleteMany?: aircraft_seatmapScalarWhereInput | aircraft_seatmapScalarWhereInput[]
  }

  export type airlineCreateNestedOneWithoutAircraftCostInput = {
    create?: XOR<airlineCreateWithoutAircraftCostInput, airlineUncheckedCreateWithoutAircraftCostInput>
    connectOrCreate?: airlineCreateOrConnectWithoutAircraftCostInput
    connect?: airlineWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type airlineUpdateOneRequiredWithoutAircraftCostNestedInput = {
    create?: XOR<airlineCreateWithoutAircraftCostInput, airlineUncheckedCreateWithoutAircraftCostInput>
    connectOrCreate?: airlineCreateOrConnectWithoutAircraftCostInput
    upsert?: airlineUpsertWithoutAircraftCostInput
    connect?: airlineWhereUniqueInput
    update?: XOR<XOR<airlineUpdateToOneWithWhereWithoutAircraftCostInput, airlineUpdateWithoutAircraftCostInput>, airlineUncheckedUpdateWithoutAircraftCostInput>
  }

  export type flightCreateNestedManyWithoutDepartAirportInput = {
    create?: XOR<flightCreateWithoutDepartAirportInput, flightUncheckedCreateWithoutDepartAirportInput> | flightCreateWithoutDepartAirportInput[] | flightUncheckedCreateWithoutDepartAirportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutDepartAirportInput | flightCreateOrConnectWithoutDepartAirportInput[]
    createMany?: flightCreateManyDepartAirportInputEnvelope
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
  }

  export type flightCreateNestedManyWithoutArriveAirportInput = {
    create?: XOR<flightCreateWithoutArriveAirportInput, flightUncheckedCreateWithoutArriveAirportInput> | flightCreateWithoutArriveAirportInput[] | flightUncheckedCreateWithoutArriveAirportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutArriveAirportInput | flightCreateOrConnectWithoutArriveAirportInput[]
    createMany?: flightCreateManyArriveAirportInputEnvelope
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
  }

  export type flightUncheckedCreateNestedManyWithoutDepartAirportInput = {
    create?: XOR<flightCreateWithoutDepartAirportInput, flightUncheckedCreateWithoutDepartAirportInput> | flightCreateWithoutDepartAirportInput[] | flightUncheckedCreateWithoutDepartAirportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutDepartAirportInput | flightCreateOrConnectWithoutDepartAirportInput[]
    createMany?: flightCreateManyDepartAirportInputEnvelope
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
  }

  export type flightUncheckedCreateNestedManyWithoutArriveAirportInput = {
    create?: XOR<flightCreateWithoutArriveAirportInput, flightUncheckedCreateWithoutArriveAirportInput> | flightCreateWithoutArriveAirportInput[] | flightUncheckedCreateWithoutArriveAirportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutArriveAirportInput | flightCreateOrConnectWithoutArriveAirportInput[]
    createMany?: flightCreateManyArriveAirportInputEnvelope
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type flightUpdateManyWithoutDepartAirportNestedInput = {
    create?: XOR<flightCreateWithoutDepartAirportInput, flightUncheckedCreateWithoutDepartAirportInput> | flightCreateWithoutDepartAirportInput[] | flightUncheckedCreateWithoutDepartAirportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutDepartAirportInput | flightCreateOrConnectWithoutDepartAirportInput[]
    upsert?: flightUpsertWithWhereUniqueWithoutDepartAirportInput | flightUpsertWithWhereUniqueWithoutDepartAirportInput[]
    createMany?: flightCreateManyDepartAirportInputEnvelope
    set?: flightWhereUniqueInput | flightWhereUniqueInput[]
    disconnect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    delete?: flightWhereUniqueInput | flightWhereUniqueInput[]
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    update?: flightUpdateWithWhereUniqueWithoutDepartAirportInput | flightUpdateWithWhereUniqueWithoutDepartAirportInput[]
    updateMany?: flightUpdateManyWithWhereWithoutDepartAirportInput | flightUpdateManyWithWhereWithoutDepartAirportInput[]
    deleteMany?: flightScalarWhereInput | flightScalarWhereInput[]
  }

  export type flightUpdateManyWithoutArriveAirportNestedInput = {
    create?: XOR<flightCreateWithoutArriveAirportInput, flightUncheckedCreateWithoutArriveAirportInput> | flightCreateWithoutArriveAirportInput[] | flightUncheckedCreateWithoutArriveAirportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutArriveAirportInput | flightCreateOrConnectWithoutArriveAirportInput[]
    upsert?: flightUpsertWithWhereUniqueWithoutArriveAirportInput | flightUpsertWithWhereUniqueWithoutArriveAirportInput[]
    createMany?: flightCreateManyArriveAirportInputEnvelope
    set?: flightWhereUniqueInput | flightWhereUniqueInput[]
    disconnect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    delete?: flightWhereUniqueInput | flightWhereUniqueInput[]
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    update?: flightUpdateWithWhereUniqueWithoutArriveAirportInput | flightUpdateWithWhereUniqueWithoutArriveAirportInput[]
    updateMany?: flightUpdateManyWithWhereWithoutArriveAirportInput | flightUpdateManyWithWhereWithoutArriveAirportInput[]
    deleteMany?: flightScalarWhereInput | flightScalarWhereInput[]
  }

  export type flightUncheckedUpdateManyWithoutDepartAirportNestedInput = {
    create?: XOR<flightCreateWithoutDepartAirportInput, flightUncheckedCreateWithoutDepartAirportInput> | flightCreateWithoutDepartAirportInput[] | flightUncheckedCreateWithoutDepartAirportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutDepartAirportInput | flightCreateOrConnectWithoutDepartAirportInput[]
    upsert?: flightUpsertWithWhereUniqueWithoutDepartAirportInput | flightUpsertWithWhereUniqueWithoutDepartAirportInput[]
    createMany?: flightCreateManyDepartAirportInputEnvelope
    set?: flightWhereUniqueInput | flightWhereUniqueInput[]
    disconnect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    delete?: flightWhereUniqueInput | flightWhereUniqueInput[]
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    update?: flightUpdateWithWhereUniqueWithoutDepartAirportInput | flightUpdateWithWhereUniqueWithoutDepartAirportInput[]
    updateMany?: flightUpdateManyWithWhereWithoutDepartAirportInput | flightUpdateManyWithWhereWithoutDepartAirportInput[]
    deleteMany?: flightScalarWhereInput | flightScalarWhereInput[]
  }

  export type flightUncheckedUpdateManyWithoutArriveAirportNestedInput = {
    create?: XOR<flightCreateWithoutArriveAirportInput, flightUncheckedCreateWithoutArriveAirportInput> | flightCreateWithoutArriveAirportInput[] | flightUncheckedCreateWithoutArriveAirportInput[]
    connectOrCreate?: flightCreateOrConnectWithoutArriveAirportInput | flightCreateOrConnectWithoutArriveAirportInput[]
    upsert?: flightUpsertWithWhereUniqueWithoutArriveAirportInput | flightUpsertWithWhereUniqueWithoutArriveAirportInput[]
    createMany?: flightCreateManyArriveAirportInputEnvelope
    set?: flightWhereUniqueInput | flightWhereUniqueInput[]
    disconnect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    delete?: flightWhereUniqueInput | flightWhereUniqueInput[]
    connect?: flightWhereUniqueInput | flightWhereUniqueInput[]
    update?: flightUpdateWithWhereUniqueWithoutArriveAirportInput | flightUpdateWithWhereUniqueWithoutArriveAirportInput[]
    updateMany?: flightUpdateManyWithWhereWithoutArriveAirportInput | flightUpdateManyWithWhereWithoutArriveAirportInput[]
    deleteMany?: flightScalarWhereInput | flightScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutBookingsInput = {
    create?: XOR<userCreateWithoutBookingsInput, userUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: userCreateOrConnectWithoutBookingsInput
    connect?: userWhereUniqueInput
  }

  export type booking_flightCreateNestedManyWithoutBookingInput = {
    create?: XOR<booking_flightCreateWithoutBookingInput, booking_flightUncheckedCreateWithoutBookingInput> | booking_flightCreateWithoutBookingInput[] | booking_flightUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: booking_flightCreateOrConnectWithoutBookingInput | booking_flightCreateOrConnectWithoutBookingInput[]
    createMany?: booking_flightCreateManyBookingInputEnvelope
    connect?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
  }

  export type passenger_bookingCreateNestedManyWithoutBookingInput = {
    create?: XOR<passenger_bookingCreateWithoutBookingInput, passenger_bookingUncheckedCreateWithoutBookingInput> | passenger_bookingCreateWithoutBookingInput[] | passenger_bookingUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: passenger_bookingCreateOrConnectWithoutBookingInput | passenger_bookingCreateOrConnectWithoutBookingInput[]
    createMany?: passenger_bookingCreateManyBookingInputEnvelope
    connect?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
  }

  export type ticketCreateNestedManyWithoutBookingInput = {
    create?: XOR<ticketCreateWithoutBookingInput, ticketUncheckedCreateWithoutBookingInput> | ticketCreateWithoutBookingInput[] | ticketUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutBookingInput | ticketCreateOrConnectWithoutBookingInput[]
    createMany?: ticketCreateManyBookingInputEnvelope
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
  }

  export type paymentCreateNestedOneWithoutBookingInput = {
    create?: XOR<paymentCreateWithoutBookingInput, paymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: paymentCreateOrConnectWithoutBookingInput
    connect?: paymentWhereUniqueInput
  }

  export type booking_flightUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<booking_flightCreateWithoutBookingInput, booking_flightUncheckedCreateWithoutBookingInput> | booking_flightCreateWithoutBookingInput[] | booking_flightUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: booking_flightCreateOrConnectWithoutBookingInput | booking_flightCreateOrConnectWithoutBookingInput[]
    createMany?: booking_flightCreateManyBookingInputEnvelope
    connect?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
  }

  export type passenger_bookingUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<passenger_bookingCreateWithoutBookingInput, passenger_bookingUncheckedCreateWithoutBookingInput> | passenger_bookingCreateWithoutBookingInput[] | passenger_bookingUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: passenger_bookingCreateOrConnectWithoutBookingInput | passenger_bookingCreateOrConnectWithoutBookingInput[]
    createMany?: passenger_bookingCreateManyBookingInputEnvelope
    connect?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
  }

  export type ticketUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<ticketCreateWithoutBookingInput, ticketUncheckedCreateWithoutBookingInput> | ticketCreateWithoutBookingInput[] | ticketUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutBookingInput | ticketCreateOrConnectWithoutBookingInput[]
    createMany?: ticketCreateManyBookingInputEnvelope
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
  }

  export type paymentUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<paymentCreateWithoutBookingInput, paymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: paymentCreateOrConnectWithoutBookingInput
    connect?: paymentWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type userUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<userCreateWithoutBookingsInput, userUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: userCreateOrConnectWithoutBookingsInput
    upsert?: userUpsertWithoutBookingsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutBookingsInput, userUpdateWithoutBookingsInput>, userUncheckedUpdateWithoutBookingsInput>
  }

  export type booking_flightUpdateManyWithoutBookingNestedInput = {
    create?: XOR<booking_flightCreateWithoutBookingInput, booking_flightUncheckedCreateWithoutBookingInput> | booking_flightCreateWithoutBookingInput[] | booking_flightUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: booking_flightCreateOrConnectWithoutBookingInput | booking_flightCreateOrConnectWithoutBookingInput[]
    upsert?: booking_flightUpsertWithWhereUniqueWithoutBookingInput | booking_flightUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: booking_flightCreateManyBookingInputEnvelope
    set?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    disconnect?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    delete?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    connect?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    update?: booking_flightUpdateWithWhereUniqueWithoutBookingInput | booking_flightUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: booking_flightUpdateManyWithWhereWithoutBookingInput | booking_flightUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: booking_flightScalarWhereInput | booking_flightScalarWhereInput[]
  }

  export type passenger_bookingUpdateManyWithoutBookingNestedInput = {
    create?: XOR<passenger_bookingCreateWithoutBookingInput, passenger_bookingUncheckedCreateWithoutBookingInput> | passenger_bookingCreateWithoutBookingInput[] | passenger_bookingUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: passenger_bookingCreateOrConnectWithoutBookingInput | passenger_bookingCreateOrConnectWithoutBookingInput[]
    upsert?: passenger_bookingUpsertWithWhereUniqueWithoutBookingInput | passenger_bookingUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: passenger_bookingCreateManyBookingInputEnvelope
    set?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    disconnect?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    delete?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    connect?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    update?: passenger_bookingUpdateWithWhereUniqueWithoutBookingInput | passenger_bookingUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: passenger_bookingUpdateManyWithWhereWithoutBookingInput | passenger_bookingUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: passenger_bookingScalarWhereInput | passenger_bookingScalarWhereInput[]
  }

  export type ticketUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ticketCreateWithoutBookingInput, ticketUncheckedCreateWithoutBookingInput> | ticketCreateWithoutBookingInput[] | ticketUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutBookingInput | ticketCreateOrConnectWithoutBookingInput[]
    upsert?: ticketUpsertWithWhereUniqueWithoutBookingInput | ticketUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ticketCreateManyBookingInputEnvelope
    set?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    disconnect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    delete?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    update?: ticketUpdateWithWhereUniqueWithoutBookingInput | ticketUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ticketUpdateManyWithWhereWithoutBookingInput | ticketUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ticketScalarWhereInput | ticketScalarWhereInput[]
  }

  export type paymentUpdateOneWithoutBookingNestedInput = {
    create?: XOR<paymentCreateWithoutBookingInput, paymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: paymentCreateOrConnectWithoutBookingInput
    upsert?: paymentUpsertWithoutBookingInput
    disconnect?: paymentWhereInput | boolean
    delete?: paymentWhereInput | boolean
    connect?: paymentWhereUniqueInput
    update?: XOR<XOR<paymentUpdateToOneWithWhereWithoutBookingInput, paymentUpdateWithoutBookingInput>, paymentUncheckedUpdateWithoutBookingInput>
  }

  export type booking_flightUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<booking_flightCreateWithoutBookingInput, booking_flightUncheckedCreateWithoutBookingInput> | booking_flightCreateWithoutBookingInput[] | booking_flightUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: booking_flightCreateOrConnectWithoutBookingInput | booking_flightCreateOrConnectWithoutBookingInput[]
    upsert?: booking_flightUpsertWithWhereUniqueWithoutBookingInput | booking_flightUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: booking_flightCreateManyBookingInputEnvelope
    set?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    disconnect?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    delete?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    connect?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    update?: booking_flightUpdateWithWhereUniqueWithoutBookingInput | booking_flightUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: booking_flightUpdateManyWithWhereWithoutBookingInput | booking_flightUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: booking_flightScalarWhereInput | booking_flightScalarWhereInput[]
  }

  export type passenger_bookingUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<passenger_bookingCreateWithoutBookingInput, passenger_bookingUncheckedCreateWithoutBookingInput> | passenger_bookingCreateWithoutBookingInput[] | passenger_bookingUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: passenger_bookingCreateOrConnectWithoutBookingInput | passenger_bookingCreateOrConnectWithoutBookingInput[]
    upsert?: passenger_bookingUpsertWithWhereUniqueWithoutBookingInput | passenger_bookingUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: passenger_bookingCreateManyBookingInputEnvelope
    set?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    disconnect?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    delete?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    connect?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    update?: passenger_bookingUpdateWithWhereUniqueWithoutBookingInput | passenger_bookingUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: passenger_bookingUpdateManyWithWhereWithoutBookingInput | passenger_bookingUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: passenger_bookingScalarWhereInput | passenger_bookingScalarWhereInput[]
  }

  export type ticketUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ticketCreateWithoutBookingInput, ticketUncheckedCreateWithoutBookingInput> | ticketCreateWithoutBookingInput[] | ticketUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutBookingInput | ticketCreateOrConnectWithoutBookingInput[]
    upsert?: ticketUpsertWithWhereUniqueWithoutBookingInput | ticketUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ticketCreateManyBookingInputEnvelope
    set?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    disconnect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    delete?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    update?: ticketUpdateWithWhereUniqueWithoutBookingInput | ticketUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ticketUpdateManyWithWhereWithoutBookingInput | ticketUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ticketScalarWhereInput | ticketScalarWhereInput[]
  }

  export type paymentUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<paymentCreateWithoutBookingInput, paymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: paymentCreateOrConnectWithoutBookingInput
    upsert?: paymentUpsertWithoutBookingInput
    disconnect?: paymentWhereInput | boolean
    delete?: paymentWhereInput | boolean
    connect?: paymentWhereUniqueInput
    update?: XOR<XOR<paymentUpdateToOneWithWhereWithoutBookingInput, paymentUpdateWithoutBookingInput>, paymentUncheckedUpdateWithoutBookingInput>
  }

  export type bookingCreateNestedOneWithoutBookingFlightsInput = {
    create?: XOR<bookingCreateWithoutBookingFlightsInput, bookingUncheckedCreateWithoutBookingFlightsInput>
    connectOrCreate?: bookingCreateOrConnectWithoutBookingFlightsInput
    connect?: bookingWhereUniqueInput
  }

  export type flightOperateCreateNestedOneWithoutBookingFlightsInput = {
    create?: XOR<flightOperateCreateWithoutBookingFlightsInput, flightOperateUncheckedCreateWithoutBookingFlightsInput>
    connectOrCreate?: flightOperateCreateOrConnectWithoutBookingFlightsInput
    connect?: flightOperateWhereUniqueInput
  }

  export type bookingUpdateOneRequiredWithoutBookingFlightsNestedInput = {
    create?: XOR<bookingCreateWithoutBookingFlightsInput, bookingUncheckedCreateWithoutBookingFlightsInput>
    connectOrCreate?: bookingCreateOrConnectWithoutBookingFlightsInput
    upsert?: bookingUpsertWithoutBookingFlightsInput
    connect?: bookingWhereUniqueInput
    update?: XOR<XOR<bookingUpdateToOneWithWhereWithoutBookingFlightsInput, bookingUpdateWithoutBookingFlightsInput>, bookingUncheckedUpdateWithoutBookingFlightsInput>
  }

  export type flightOperateUpdateOneRequiredWithoutBookingFlightsNestedInput = {
    create?: XOR<flightOperateCreateWithoutBookingFlightsInput, flightOperateUncheckedCreateWithoutBookingFlightsInput>
    connectOrCreate?: flightOperateCreateOrConnectWithoutBookingFlightsInput
    upsert?: flightOperateUpsertWithoutBookingFlightsInput
    connect?: flightOperateWhereUniqueInput
    update?: XOR<XOR<flightOperateUpdateToOneWithWhereWithoutBookingFlightsInput, flightOperateUpdateWithoutBookingFlightsInput>, flightOperateUncheckedUpdateWithoutBookingFlightsInput>
  }

  export type airlineCreateNestedOneWithoutFlightInput = {
    create?: XOR<airlineCreateWithoutFlightInput, airlineUncheckedCreateWithoutFlightInput>
    connectOrCreate?: airlineCreateOrConnectWithoutFlightInput
    connect?: airlineWhereUniqueInput
  }

  export type airportCreateNestedOneWithoutDepartFlightsInput = {
    create?: XOR<airportCreateWithoutDepartFlightsInput, airportUncheckedCreateWithoutDepartFlightsInput>
    connectOrCreate?: airportCreateOrConnectWithoutDepartFlightsInput
    connect?: airportWhereUniqueInput
  }

  export type airportCreateNestedOneWithoutArriveFlightsInput = {
    create?: XOR<airportCreateWithoutArriveFlightsInput, airportUncheckedCreateWithoutArriveFlightsInput>
    connectOrCreate?: airportCreateOrConnectWithoutArriveFlightsInput
    connect?: airportWhereUniqueInput
  }

  export type flightOperateCreateNestedManyWithoutFlightInput = {
    create?: XOR<flightOperateCreateWithoutFlightInput, flightOperateUncheckedCreateWithoutFlightInput> | flightOperateCreateWithoutFlightInput[] | flightOperateUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: flightOperateCreateOrConnectWithoutFlightInput | flightOperateCreateOrConnectWithoutFlightInput[]
    createMany?: flightOperateCreateManyFlightInputEnvelope
    connect?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
  }

  export type transitCreateNestedManyWithoutFromInput = {
    create?: XOR<transitCreateWithoutFromInput, transitUncheckedCreateWithoutFromInput> | transitCreateWithoutFromInput[] | transitUncheckedCreateWithoutFromInput[]
    connectOrCreate?: transitCreateOrConnectWithoutFromInput | transitCreateOrConnectWithoutFromInput[]
    createMany?: transitCreateManyFromInputEnvelope
    connect?: transitWhereUniqueInput | transitWhereUniqueInput[]
  }

  export type transitCreateNestedManyWithoutToInput = {
    create?: XOR<transitCreateWithoutToInput, transitUncheckedCreateWithoutToInput> | transitCreateWithoutToInput[] | transitUncheckedCreateWithoutToInput[]
    connectOrCreate?: transitCreateOrConnectWithoutToInput | transitCreateOrConnectWithoutToInput[]
    createMany?: transitCreateManyToInputEnvelope
    connect?: transitWhereUniqueInput | transitWhereUniqueInput[]
  }

  export type flightOperateUncheckedCreateNestedManyWithoutFlightInput = {
    create?: XOR<flightOperateCreateWithoutFlightInput, flightOperateUncheckedCreateWithoutFlightInput> | flightOperateCreateWithoutFlightInput[] | flightOperateUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: flightOperateCreateOrConnectWithoutFlightInput | flightOperateCreateOrConnectWithoutFlightInput[]
    createMany?: flightOperateCreateManyFlightInputEnvelope
    connect?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
  }

  export type transitUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<transitCreateWithoutFromInput, transitUncheckedCreateWithoutFromInput> | transitCreateWithoutFromInput[] | transitUncheckedCreateWithoutFromInput[]
    connectOrCreate?: transitCreateOrConnectWithoutFromInput | transitCreateOrConnectWithoutFromInput[]
    createMany?: transitCreateManyFromInputEnvelope
    connect?: transitWhereUniqueInput | transitWhereUniqueInput[]
  }

  export type transitUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<transitCreateWithoutToInput, transitUncheckedCreateWithoutToInput> | transitCreateWithoutToInput[] | transitUncheckedCreateWithoutToInput[]
    connectOrCreate?: transitCreateOrConnectWithoutToInput | transitCreateOrConnectWithoutToInput[]
    createMany?: transitCreateManyToInputEnvelope
    connect?: transitWhereUniqueInput | transitWhereUniqueInput[]
  }

  export type airlineUpdateOneRequiredWithoutFlightNestedInput = {
    create?: XOR<airlineCreateWithoutFlightInput, airlineUncheckedCreateWithoutFlightInput>
    connectOrCreate?: airlineCreateOrConnectWithoutFlightInput
    upsert?: airlineUpsertWithoutFlightInput
    connect?: airlineWhereUniqueInput
    update?: XOR<XOR<airlineUpdateToOneWithWhereWithoutFlightInput, airlineUpdateWithoutFlightInput>, airlineUncheckedUpdateWithoutFlightInput>
  }

  export type airportUpdateOneRequiredWithoutDepartFlightsNestedInput = {
    create?: XOR<airportCreateWithoutDepartFlightsInput, airportUncheckedCreateWithoutDepartFlightsInput>
    connectOrCreate?: airportCreateOrConnectWithoutDepartFlightsInput
    upsert?: airportUpsertWithoutDepartFlightsInput
    connect?: airportWhereUniqueInput
    update?: XOR<XOR<airportUpdateToOneWithWhereWithoutDepartFlightsInput, airportUpdateWithoutDepartFlightsInput>, airportUncheckedUpdateWithoutDepartFlightsInput>
  }

  export type airportUpdateOneRequiredWithoutArriveFlightsNestedInput = {
    create?: XOR<airportCreateWithoutArriveFlightsInput, airportUncheckedCreateWithoutArriveFlightsInput>
    connectOrCreate?: airportCreateOrConnectWithoutArriveFlightsInput
    upsert?: airportUpsertWithoutArriveFlightsInput
    connect?: airportWhereUniqueInput
    update?: XOR<XOR<airportUpdateToOneWithWhereWithoutArriveFlightsInput, airportUpdateWithoutArriveFlightsInput>, airportUncheckedUpdateWithoutArriveFlightsInput>
  }

  export type flightOperateUpdateManyWithoutFlightNestedInput = {
    create?: XOR<flightOperateCreateWithoutFlightInput, flightOperateUncheckedCreateWithoutFlightInput> | flightOperateCreateWithoutFlightInput[] | flightOperateUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: flightOperateCreateOrConnectWithoutFlightInput | flightOperateCreateOrConnectWithoutFlightInput[]
    upsert?: flightOperateUpsertWithWhereUniqueWithoutFlightInput | flightOperateUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: flightOperateCreateManyFlightInputEnvelope
    set?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    disconnect?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    delete?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    connect?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    update?: flightOperateUpdateWithWhereUniqueWithoutFlightInput | flightOperateUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: flightOperateUpdateManyWithWhereWithoutFlightInput | flightOperateUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: flightOperateScalarWhereInput | flightOperateScalarWhereInput[]
  }

  export type transitUpdateManyWithoutFromNestedInput = {
    create?: XOR<transitCreateWithoutFromInput, transitUncheckedCreateWithoutFromInput> | transitCreateWithoutFromInput[] | transitUncheckedCreateWithoutFromInput[]
    connectOrCreate?: transitCreateOrConnectWithoutFromInput | transitCreateOrConnectWithoutFromInput[]
    upsert?: transitUpsertWithWhereUniqueWithoutFromInput | transitUpsertWithWhereUniqueWithoutFromInput[]
    createMany?: transitCreateManyFromInputEnvelope
    set?: transitWhereUniqueInput | transitWhereUniqueInput[]
    disconnect?: transitWhereUniqueInput | transitWhereUniqueInput[]
    delete?: transitWhereUniqueInput | transitWhereUniqueInput[]
    connect?: transitWhereUniqueInput | transitWhereUniqueInput[]
    update?: transitUpdateWithWhereUniqueWithoutFromInput | transitUpdateWithWhereUniqueWithoutFromInput[]
    updateMany?: transitUpdateManyWithWhereWithoutFromInput | transitUpdateManyWithWhereWithoutFromInput[]
    deleteMany?: transitScalarWhereInput | transitScalarWhereInput[]
  }

  export type transitUpdateManyWithoutToNestedInput = {
    create?: XOR<transitCreateWithoutToInput, transitUncheckedCreateWithoutToInput> | transitCreateWithoutToInput[] | transitUncheckedCreateWithoutToInput[]
    connectOrCreate?: transitCreateOrConnectWithoutToInput | transitCreateOrConnectWithoutToInput[]
    upsert?: transitUpsertWithWhereUniqueWithoutToInput | transitUpsertWithWhereUniqueWithoutToInput[]
    createMany?: transitCreateManyToInputEnvelope
    set?: transitWhereUniqueInput | transitWhereUniqueInput[]
    disconnect?: transitWhereUniqueInput | transitWhereUniqueInput[]
    delete?: transitWhereUniqueInput | transitWhereUniqueInput[]
    connect?: transitWhereUniqueInput | transitWhereUniqueInput[]
    update?: transitUpdateWithWhereUniqueWithoutToInput | transitUpdateWithWhereUniqueWithoutToInput[]
    updateMany?: transitUpdateManyWithWhereWithoutToInput | transitUpdateManyWithWhereWithoutToInput[]
    deleteMany?: transitScalarWhereInput | transitScalarWhereInput[]
  }

  export type flightOperateUncheckedUpdateManyWithoutFlightNestedInput = {
    create?: XOR<flightOperateCreateWithoutFlightInput, flightOperateUncheckedCreateWithoutFlightInput> | flightOperateCreateWithoutFlightInput[] | flightOperateUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: flightOperateCreateOrConnectWithoutFlightInput | flightOperateCreateOrConnectWithoutFlightInput[]
    upsert?: flightOperateUpsertWithWhereUniqueWithoutFlightInput | flightOperateUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: flightOperateCreateManyFlightInputEnvelope
    set?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    disconnect?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    delete?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    connect?: flightOperateWhereUniqueInput | flightOperateWhereUniqueInput[]
    update?: flightOperateUpdateWithWhereUniqueWithoutFlightInput | flightOperateUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: flightOperateUpdateManyWithWhereWithoutFlightInput | flightOperateUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: flightOperateScalarWhereInput | flightOperateScalarWhereInput[]
  }

  export type transitUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<transitCreateWithoutFromInput, transitUncheckedCreateWithoutFromInput> | transitCreateWithoutFromInput[] | transitUncheckedCreateWithoutFromInput[]
    connectOrCreate?: transitCreateOrConnectWithoutFromInput | transitCreateOrConnectWithoutFromInput[]
    upsert?: transitUpsertWithWhereUniqueWithoutFromInput | transitUpsertWithWhereUniqueWithoutFromInput[]
    createMany?: transitCreateManyFromInputEnvelope
    set?: transitWhereUniqueInput | transitWhereUniqueInput[]
    disconnect?: transitWhereUniqueInput | transitWhereUniqueInput[]
    delete?: transitWhereUniqueInput | transitWhereUniqueInput[]
    connect?: transitWhereUniqueInput | transitWhereUniqueInput[]
    update?: transitUpdateWithWhereUniqueWithoutFromInput | transitUpdateWithWhereUniqueWithoutFromInput[]
    updateMany?: transitUpdateManyWithWhereWithoutFromInput | transitUpdateManyWithWhereWithoutFromInput[]
    deleteMany?: transitScalarWhereInput | transitScalarWhereInput[]
  }

  export type transitUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<transitCreateWithoutToInput, transitUncheckedCreateWithoutToInput> | transitCreateWithoutToInput[] | transitUncheckedCreateWithoutToInput[]
    connectOrCreate?: transitCreateOrConnectWithoutToInput | transitCreateOrConnectWithoutToInput[]
    upsert?: transitUpsertWithWhereUniqueWithoutToInput | transitUpsertWithWhereUniqueWithoutToInput[]
    createMany?: transitCreateManyToInputEnvelope
    set?: transitWhereUniqueInput | transitWhereUniqueInput[]
    disconnect?: transitWhereUniqueInput | transitWhereUniqueInput[]
    delete?: transitWhereUniqueInput | transitWhereUniqueInput[]
    connect?: transitWhereUniqueInput | transitWhereUniqueInput[]
    update?: transitUpdateWithWhereUniqueWithoutToInput | transitUpdateWithWhereUniqueWithoutToInput[]
    updateMany?: transitUpdateManyWithWhereWithoutToInput | transitUpdateManyWithWhereWithoutToInput[]
    deleteMany?: transitScalarWhereInput | transitScalarWhereInput[]
  }

  export type aircraftCreateNestedOneWithoutFlightOperateInput = {
    create?: XOR<aircraftCreateWithoutFlightOperateInput, aircraftUncheckedCreateWithoutFlightOperateInput>
    connectOrCreate?: aircraftCreateOrConnectWithoutFlightOperateInput
    connect?: aircraftWhereUniqueInput
  }

  export type flightCreateNestedOneWithoutFlightOperatesInput = {
    create?: XOR<flightCreateWithoutFlightOperatesInput, flightUncheckedCreateWithoutFlightOperatesInput>
    connectOrCreate?: flightCreateOrConnectWithoutFlightOperatesInput
    connect?: flightWhereUniqueInput
  }

  export type booking_flightCreateNestedManyWithoutFlightInput = {
    create?: XOR<booking_flightCreateWithoutFlightInput, booking_flightUncheckedCreateWithoutFlightInput> | booking_flightCreateWithoutFlightInput[] | booking_flightUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: booking_flightCreateOrConnectWithoutFlightInput | booking_flightCreateOrConnectWithoutFlightInput[]
    createMany?: booking_flightCreateManyFlightInputEnvelope
    connect?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
  }

  export type ticketCreateNestedManyWithoutFlightInput = {
    create?: XOR<ticketCreateWithoutFlightInput, ticketUncheckedCreateWithoutFlightInput> | ticketCreateWithoutFlightInput[] | ticketUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutFlightInput | ticketCreateOrConnectWithoutFlightInput[]
    createMany?: ticketCreateManyFlightInputEnvelope
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
  }

  export type booking_flightUncheckedCreateNestedManyWithoutFlightInput = {
    create?: XOR<booking_flightCreateWithoutFlightInput, booking_flightUncheckedCreateWithoutFlightInput> | booking_flightCreateWithoutFlightInput[] | booking_flightUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: booking_flightCreateOrConnectWithoutFlightInput | booking_flightCreateOrConnectWithoutFlightInput[]
    createMany?: booking_flightCreateManyFlightInputEnvelope
    connect?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
  }

  export type ticketUncheckedCreateNestedManyWithoutFlightInput = {
    create?: XOR<ticketCreateWithoutFlightInput, ticketUncheckedCreateWithoutFlightInput> | ticketCreateWithoutFlightInput[] | ticketUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutFlightInput | ticketCreateOrConnectWithoutFlightInput[]
    createMany?: ticketCreateManyFlightInputEnvelope
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
  }

  export type aircraftUpdateOneRequiredWithoutFlightOperateNestedInput = {
    create?: XOR<aircraftCreateWithoutFlightOperateInput, aircraftUncheckedCreateWithoutFlightOperateInput>
    connectOrCreate?: aircraftCreateOrConnectWithoutFlightOperateInput
    upsert?: aircraftUpsertWithoutFlightOperateInput
    connect?: aircraftWhereUniqueInput
    update?: XOR<XOR<aircraftUpdateToOneWithWhereWithoutFlightOperateInput, aircraftUpdateWithoutFlightOperateInput>, aircraftUncheckedUpdateWithoutFlightOperateInput>
  }

  export type flightUpdateOneRequiredWithoutFlightOperatesNestedInput = {
    create?: XOR<flightCreateWithoutFlightOperatesInput, flightUncheckedCreateWithoutFlightOperatesInput>
    connectOrCreate?: flightCreateOrConnectWithoutFlightOperatesInput
    upsert?: flightUpsertWithoutFlightOperatesInput
    connect?: flightWhereUniqueInput
    update?: XOR<XOR<flightUpdateToOneWithWhereWithoutFlightOperatesInput, flightUpdateWithoutFlightOperatesInput>, flightUncheckedUpdateWithoutFlightOperatesInput>
  }

  export type booking_flightUpdateManyWithoutFlightNestedInput = {
    create?: XOR<booking_flightCreateWithoutFlightInput, booking_flightUncheckedCreateWithoutFlightInput> | booking_flightCreateWithoutFlightInput[] | booking_flightUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: booking_flightCreateOrConnectWithoutFlightInput | booking_flightCreateOrConnectWithoutFlightInput[]
    upsert?: booking_flightUpsertWithWhereUniqueWithoutFlightInput | booking_flightUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: booking_flightCreateManyFlightInputEnvelope
    set?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    disconnect?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    delete?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    connect?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    update?: booking_flightUpdateWithWhereUniqueWithoutFlightInput | booking_flightUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: booking_flightUpdateManyWithWhereWithoutFlightInput | booking_flightUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: booking_flightScalarWhereInput | booking_flightScalarWhereInput[]
  }

  export type ticketUpdateManyWithoutFlightNestedInput = {
    create?: XOR<ticketCreateWithoutFlightInput, ticketUncheckedCreateWithoutFlightInput> | ticketCreateWithoutFlightInput[] | ticketUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutFlightInput | ticketCreateOrConnectWithoutFlightInput[]
    upsert?: ticketUpsertWithWhereUniqueWithoutFlightInput | ticketUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: ticketCreateManyFlightInputEnvelope
    set?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    disconnect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    delete?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    update?: ticketUpdateWithWhereUniqueWithoutFlightInput | ticketUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: ticketUpdateManyWithWhereWithoutFlightInput | ticketUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: ticketScalarWhereInput | ticketScalarWhereInput[]
  }

  export type booking_flightUncheckedUpdateManyWithoutFlightNestedInput = {
    create?: XOR<booking_flightCreateWithoutFlightInput, booking_flightUncheckedCreateWithoutFlightInput> | booking_flightCreateWithoutFlightInput[] | booking_flightUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: booking_flightCreateOrConnectWithoutFlightInput | booking_flightCreateOrConnectWithoutFlightInput[]
    upsert?: booking_flightUpsertWithWhereUniqueWithoutFlightInput | booking_flightUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: booking_flightCreateManyFlightInputEnvelope
    set?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    disconnect?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    delete?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    connect?: booking_flightWhereUniqueInput | booking_flightWhereUniqueInput[]
    update?: booking_flightUpdateWithWhereUniqueWithoutFlightInput | booking_flightUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: booking_flightUpdateManyWithWhereWithoutFlightInput | booking_flightUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: booking_flightScalarWhereInput | booking_flightScalarWhereInput[]
  }

  export type ticketUncheckedUpdateManyWithoutFlightNestedInput = {
    create?: XOR<ticketCreateWithoutFlightInput, ticketUncheckedCreateWithoutFlightInput> | ticketCreateWithoutFlightInput[] | ticketUncheckedCreateWithoutFlightInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutFlightInput | ticketCreateOrConnectWithoutFlightInput[]
    upsert?: ticketUpsertWithWhereUniqueWithoutFlightInput | ticketUpsertWithWhereUniqueWithoutFlightInput[]
    createMany?: ticketCreateManyFlightInputEnvelope
    set?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    disconnect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    delete?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    update?: ticketUpdateWithWhereUniqueWithoutFlightInput | ticketUpdateWithWhereUniqueWithoutFlightInput[]
    updateMany?: ticketUpdateManyWithWhereWithoutFlightInput | ticketUpdateManyWithWhereWithoutFlightInput[]
    deleteMany?: ticketScalarWhereInput | ticketScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutPassengersInput = {
    create?: XOR<userCreateWithoutPassengersInput, userUncheckedCreateWithoutPassengersInput>
    connectOrCreate?: userCreateOrConnectWithoutPassengersInput
    connect?: userWhereUniqueInput
  }

  export type passenger_bookingCreateNestedManyWithoutPassengerInput = {
    create?: XOR<passenger_bookingCreateWithoutPassengerInput, passenger_bookingUncheckedCreateWithoutPassengerInput> | passenger_bookingCreateWithoutPassengerInput[] | passenger_bookingUncheckedCreateWithoutPassengerInput[]
    connectOrCreate?: passenger_bookingCreateOrConnectWithoutPassengerInput | passenger_bookingCreateOrConnectWithoutPassengerInput[]
    createMany?: passenger_bookingCreateManyPassengerInputEnvelope
    connect?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
  }

  export type ticketCreateNestedManyWithoutPassengerInput = {
    create?: XOR<ticketCreateWithoutPassengerInput, ticketUncheckedCreateWithoutPassengerInput> | ticketCreateWithoutPassengerInput[] | ticketUncheckedCreateWithoutPassengerInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutPassengerInput | ticketCreateOrConnectWithoutPassengerInput[]
    createMany?: ticketCreateManyPassengerInputEnvelope
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
  }

  export type passenger_bookingUncheckedCreateNestedManyWithoutPassengerInput = {
    create?: XOR<passenger_bookingCreateWithoutPassengerInput, passenger_bookingUncheckedCreateWithoutPassengerInput> | passenger_bookingCreateWithoutPassengerInput[] | passenger_bookingUncheckedCreateWithoutPassengerInput[]
    connectOrCreate?: passenger_bookingCreateOrConnectWithoutPassengerInput | passenger_bookingCreateOrConnectWithoutPassengerInput[]
    createMany?: passenger_bookingCreateManyPassengerInputEnvelope
    connect?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
  }

  export type ticketUncheckedCreateNestedManyWithoutPassengerInput = {
    create?: XOR<ticketCreateWithoutPassengerInput, ticketUncheckedCreateWithoutPassengerInput> | ticketCreateWithoutPassengerInput[] | ticketUncheckedCreateWithoutPassengerInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutPassengerInput | ticketCreateOrConnectWithoutPassengerInput[]
    createMany?: ticketCreateManyPassengerInputEnvelope
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
  }

  export type EnumAgeRangeFieldUpdateOperationsInput = {
    set?: $Enums.AgeRange
  }

  export type userUpdateOneRequiredWithoutPassengersNestedInput = {
    create?: XOR<userCreateWithoutPassengersInput, userUncheckedCreateWithoutPassengersInput>
    connectOrCreate?: userCreateOrConnectWithoutPassengersInput
    upsert?: userUpsertWithoutPassengersInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPassengersInput, userUpdateWithoutPassengersInput>, userUncheckedUpdateWithoutPassengersInput>
  }

  export type passenger_bookingUpdateManyWithoutPassengerNestedInput = {
    create?: XOR<passenger_bookingCreateWithoutPassengerInput, passenger_bookingUncheckedCreateWithoutPassengerInput> | passenger_bookingCreateWithoutPassengerInput[] | passenger_bookingUncheckedCreateWithoutPassengerInput[]
    connectOrCreate?: passenger_bookingCreateOrConnectWithoutPassengerInput | passenger_bookingCreateOrConnectWithoutPassengerInput[]
    upsert?: passenger_bookingUpsertWithWhereUniqueWithoutPassengerInput | passenger_bookingUpsertWithWhereUniqueWithoutPassengerInput[]
    createMany?: passenger_bookingCreateManyPassengerInputEnvelope
    set?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    disconnect?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    delete?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    connect?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    update?: passenger_bookingUpdateWithWhereUniqueWithoutPassengerInput | passenger_bookingUpdateWithWhereUniqueWithoutPassengerInput[]
    updateMany?: passenger_bookingUpdateManyWithWhereWithoutPassengerInput | passenger_bookingUpdateManyWithWhereWithoutPassengerInput[]
    deleteMany?: passenger_bookingScalarWhereInput | passenger_bookingScalarWhereInput[]
  }

  export type ticketUpdateManyWithoutPassengerNestedInput = {
    create?: XOR<ticketCreateWithoutPassengerInput, ticketUncheckedCreateWithoutPassengerInput> | ticketCreateWithoutPassengerInput[] | ticketUncheckedCreateWithoutPassengerInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutPassengerInput | ticketCreateOrConnectWithoutPassengerInput[]
    upsert?: ticketUpsertWithWhereUniqueWithoutPassengerInput | ticketUpsertWithWhereUniqueWithoutPassengerInput[]
    createMany?: ticketCreateManyPassengerInputEnvelope
    set?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    disconnect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    delete?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    update?: ticketUpdateWithWhereUniqueWithoutPassengerInput | ticketUpdateWithWhereUniqueWithoutPassengerInput[]
    updateMany?: ticketUpdateManyWithWhereWithoutPassengerInput | ticketUpdateManyWithWhereWithoutPassengerInput[]
    deleteMany?: ticketScalarWhereInput | ticketScalarWhereInput[]
  }

  export type passenger_bookingUncheckedUpdateManyWithoutPassengerNestedInput = {
    create?: XOR<passenger_bookingCreateWithoutPassengerInput, passenger_bookingUncheckedCreateWithoutPassengerInput> | passenger_bookingCreateWithoutPassengerInput[] | passenger_bookingUncheckedCreateWithoutPassengerInput[]
    connectOrCreate?: passenger_bookingCreateOrConnectWithoutPassengerInput | passenger_bookingCreateOrConnectWithoutPassengerInput[]
    upsert?: passenger_bookingUpsertWithWhereUniqueWithoutPassengerInput | passenger_bookingUpsertWithWhereUniqueWithoutPassengerInput[]
    createMany?: passenger_bookingCreateManyPassengerInputEnvelope
    set?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    disconnect?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    delete?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    connect?: passenger_bookingWhereUniqueInput | passenger_bookingWhereUniqueInput[]
    update?: passenger_bookingUpdateWithWhereUniqueWithoutPassengerInput | passenger_bookingUpdateWithWhereUniqueWithoutPassengerInput[]
    updateMany?: passenger_bookingUpdateManyWithWhereWithoutPassengerInput | passenger_bookingUpdateManyWithWhereWithoutPassengerInput[]
    deleteMany?: passenger_bookingScalarWhereInput | passenger_bookingScalarWhereInput[]
  }

  export type ticketUncheckedUpdateManyWithoutPassengerNestedInput = {
    create?: XOR<ticketCreateWithoutPassengerInput, ticketUncheckedCreateWithoutPassengerInput> | ticketCreateWithoutPassengerInput[] | ticketUncheckedCreateWithoutPassengerInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutPassengerInput | ticketCreateOrConnectWithoutPassengerInput[]
    upsert?: ticketUpsertWithWhereUniqueWithoutPassengerInput | ticketUpsertWithWhereUniqueWithoutPassengerInput[]
    createMany?: ticketCreateManyPassengerInputEnvelope
    set?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    disconnect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    delete?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    update?: ticketUpdateWithWhereUniqueWithoutPassengerInput | ticketUpdateWithWhereUniqueWithoutPassengerInput[]
    updateMany?: ticketUpdateManyWithWhereWithoutPassengerInput | ticketUpdateManyWithWhereWithoutPassengerInput[]
    deleteMany?: ticketScalarWhereInput | ticketScalarWhereInput[]
  }

  export type bookingCreateNestedOneWithoutPassengerBookingsInput = {
    create?: XOR<bookingCreateWithoutPassengerBookingsInput, bookingUncheckedCreateWithoutPassengerBookingsInput>
    connectOrCreate?: bookingCreateOrConnectWithoutPassengerBookingsInput
    connect?: bookingWhereUniqueInput
  }

  export type passengerCreateNestedOneWithoutPassengerBookingsInput = {
    create?: XOR<passengerCreateWithoutPassengerBookingsInput, passengerUncheckedCreateWithoutPassengerBookingsInput>
    connectOrCreate?: passengerCreateOrConnectWithoutPassengerBookingsInput
    connect?: passengerWhereUniqueInput
  }

  export type bookingUpdateOneRequiredWithoutPassengerBookingsNestedInput = {
    create?: XOR<bookingCreateWithoutPassengerBookingsInput, bookingUncheckedCreateWithoutPassengerBookingsInput>
    connectOrCreate?: bookingCreateOrConnectWithoutPassengerBookingsInput
    upsert?: bookingUpsertWithoutPassengerBookingsInput
    connect?: bookingWhereUniqueInput
    update?: XOR<XOR<bookingUpdateToOneWithWhereWithoutPassengerBookingsInput, bookingUpdateWithoutPassengerBookingsInput>, bookingUncheckedUpdateWithoutPassengerBookingsInput>
  }

  export type passengerUpdateOneRequiredWithoutPassengerBookingsNestedInput = {
    create?: XOR<passengerCreateWithoutPassengerBookingsInput, passengerUncheckedCreateWithoutPassengerBookingsInput>
    connectOrCreate?: passengerCreateOrConnectWithoutPassengerBookingsInput
    upsert?: passengerUpsertWithoutPassengerBookingsInput
    connect?: passengerWhereUniqueInput
    update?: XOR<XOR<passengerUpdateToOneWithWhereWithoutPassengerBookingsInput, passengerUpdateWithoutPassengerBookingsInput>, passengerUncheckedUpdateWithoutPassengerBookingsInput>
  }

  export type bookingCreateNestedOneWithoutPaymentInput = {
    create?: XOR<bookingCreateWithoutPaymentInput, bookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: bookingCreateOrConnectWithoutPaymentInput
    connect?: bookingWhereUniqueInput
  }

  export type bookingUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<bookingCreateWithoutPaymentInput, bookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: bookingCreateOrConnectWithoutPaymentInput
    upsert?: bookingUpsertWithoutPaymentInput
    connect?: bookingWhereUniqueInput
    update?: XOR<XOR<bookingUpdateToOneWithWhereWithoutPaymentInput, bookingUpdateWithoutPaymentInput>, bookingUncheckedUpdateWithoutPaymentInput>
  }

  export type aircraftCreateNestedOneWithoutAircraftSeatmapInput = {
    create?: XOR<aircraftCreateWithoutAircraftSeatmapInput, aircraftUncheckedCreateWithoutAircraftSeatmapInput>
    connectOrCreate?: aircraftCreateOrConnectWithoutAircraftSeatmapInput
    connect?: aircraftWhereUniqueInput
  }

  export type seatmap_infoCreateNestedOneWithoutAircraftInput = {
    create?: XOR<seatmap_infoCreateWithoutAircraftInput, seatmap_infoUncheckedCreateWithoutAircraftInput>
    connectOrCreate?: seatmap_infoCreateOrConnectWithoutAircraftInput
    connect?: seatmap_infoWhereUniqueInput
  }

  export type aircraftUpdateOneRequiredWithoutAircraftSeatmapNestedInput = {
    create?: XOR<aircraftCreateWithoutAircraftSeatmapInput, aircraftUncheckedCreateWithoutAircraftSeatmapInput>
    connectOrCreate?: aircraftCreateOrConnectWithoutAircraftSeatmapInput
    upsert?: aircraftUpsertWithoutAircraftSeatmapInput
    connect?: aircraftWhereUniqueInput
    update?: XOR<XOR<aircraftUpdateToOneWithWhereWithoutAircraftSeatmapInput, aircraftUpdateWithoutAircraftSeatmapInput>, aircraftUncheckedUpdateWithoutAircraftSeatmapInput>
  }

  export type seatmap_infoUpdateOneRequiredWithoutAircraftNestedInput = {
    create?: XOR<seatmap_infoCreateWithoutAircraftInput, seatmap_infoUncheckedCreateWithoutAircraftInput>
    connectOrCreate?: seatmap_infoCreateOrConnectWithoutAircraftInput
    upsert?: seatmap_infoUpsertWithoutAircraftInput
    connect?: seatmap_infoWhereUniqueInput
    update?: XOR<XOR<seatmap_infoUpdateToOneWithWhereWithoutAircraftInput, seatmap_infoUpdateWithoutAircraftInput>, seatmap_infoUncheckedUpdateWithoutAircraftInput>
  }

  export type seatCreateNestedManyWithoutSeatmapInput = {
    create?: XOR<seatCreateWithoutSeatmapInput, seatUncheckedCreateWithoutSeatmapInput> | seatCreateWithoutSeatmapInput[] | seatUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: seatCreateOrConnectWithoutSeatmapInput | seatCreateOrConnectWithoutSeatmapInput[]
    createMany?: seatCreateManySeatmapInputEnvelope
    connect?: seatWhereUniqueInput | seatWhereUniqueInput[]
  }

  export type aircraft_seatmapCreateNestedManyWithoutSeatmapInput = {
    create?: XOR<aircraft_seatmapCreateWithoutSeatmapInput, aircraft_seatmapUncheckedCreateWithoutSeatmapInput> | aircraft_seatmapCreateWithoutSeatmapInput[] | aircraft_seatmapUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: aircraft_seatmapCreateOrConnectWithoutSeatmapInput | aircraft_seatmapCreateOrConnectWithoutSeatmapInput[]
    createMany?: aircraft_seatmapCreateManySeatmapInputEnvelope
    connect?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
  }

  export type seatUncheckedCreateNestedManyWithoutSeatmapInput = {
    create?: XOR<seatCreateWithoutSeatmapInput, seatUncheckedCreateWithoutSeatmapInput> | seatCreateWithoutSeatmapInput[] | seatUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: seatCreateOrConnectWithoutSeatmapInput | seatCreateOrConnectWithoutSeatmapInput[]
    createMany?: seatCreateManySeatmapInputEnvelope
    connect?: seatWhereUniqueInput | seatWhereUniqueInput[]
  }

  export type aircraft_seatmapUncheckedCreateNestedManyWithoutSeatmapInput = {
    create?: XOR<aircraft_seatmapCreateWithoutSeatmapInput, aircraft_seatmapUncheckedCreateWithoutSeatmapInput> | aircraft_seatmapCreateWithoutSeatmapInput[] | aircraft_seatmapUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: aircraft_seatmapCreateOrConnectWithoutSeatmapInput | aircraft_seatmapCreateOrConnectWithoutSeatmapInput[]
    createMany?: aircraft_seatmapCreateManySeatmapInputEnvelope
    connect?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
  }

  export type seatUpdateManyWithoutSeatmapNestedInput = {
    create?: XOR<seatCreateWithoutSeatmapInput, seatUncheckedCreateWithoutSeatmapInput> | seatCreateWithoutSeatmapInput[] | seatUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: seatCreateOrConnectWithoutSeatmapInput | seatCreateOrConnectWithoutSeatmapInput[]
    upsert?: seatUpsertWithWhereUniqueWithoutSeatmapInput | seatUpsertWithWhereUniqueWithoutSeatmapInput[]
    createMany?: seatCreateManySeatmapInputEnvelope
    set?: seatWhereUniqueInput | seatWhereUniqueInput[]
    disconnect?: seatWhereUniqueInput | seatWhereUniqueInput[]
    delete?: seatWhereUniqueInput | seatWhereUniqueInput[]
    connect?: seatWhereUniqueInput | seatWhereUniqueInput[]
    update?: seatUpdateWithWhereUniqueWithoutSeatmapInput | seatUpdateWithWhereUniqueWithoutSeatmapInput[]
    updateMany?: seatUpdateManyWithWhereWithoutSeatmapInput | seatUpdateManyWithWhereWithoutSeatmapInput[]
    deleteMany?: seatScalarWhereInput | seatScalarWhereInput[]
  }

  export type aircraft_seatmapUpdateManyWithoutSeatmapNestedInput = {
    create?: XOR<aircraft_seatmapCreateWithoutSeatmapInput, aircraft_seatmapUncheckedCreateWithoutSeatmapInput> | aircraft_seatmapCreateWithoutSeatmapInput[] | aircraft_seatmapUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: aircraft_seatmapCreateOrConnectWithoutSeatmapInput | aircraft_seatmapCreateOrConnectWithoutSeatmapInput[]
    upsert?: aircraft_seatmapUpsertWithWhereUniqueWithoutSeatmapInput | aircraft_seatmapUpsertWithWhereUniqueWithoutSeatmapInput[]
    createMany?: aircraft_seatmapCreateManySeatmapInputEnvelope
    set?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    disconnect?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    delete?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    connect?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    update?: aircraft_seatmapUpdateWithWhereUniqueWithoutSeatmapInput | aircraft_seatmapUpdateWithWhereUniqueWithoutSeatmapInput[]
    updateMany?: aircraft_seatmapUpdateManyWithWhereWithoutSeatmapInput | aircraft_seatmapUpdateManyWithWhereWithoutSeatmapInput[]
    deleteMany?: aircraft_seatmapScalarWhereInput | aircraft_seatmapScalarWhereInput[]
  }

  export type seatUncheckedUpdateManyWithoutSeatmapNestedInput = {
    create?: XOR<seatCreateWithoutSeatmapInput, seatUncheckedCreateWithoutSeatmapInput> | seatCreateWithoutSeatmapInput[] | seatUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: seatCreateOrConnectWithoutSeatmapInput | seatCreateOrConnectWithoutSeatmapInput[]
    upsert?: seatUpsertWithWhereUniqueWithoutSeatmapInput | seatUpsertWithWhereUniqueWithoutSeatmapInput[]
    createMany?: seatCreateManySeatmapInputEnvelope
    set?: seatWhereUniqueInput | seatWhereUniqueInput[]
    disconnect?: seatWhereUniqueInput | seatWhereUniqueInput[]
    delete?: seatWhereUniqueInput | seatWhereUniqueInput[]
    connect?: seatWhereUniqueInput | seatWhereUniqueInput[]
    update?: seatUpdateWithWhereUniqueWithoutSeatmapInput | seatUpdateWithWhereUniqueWithoutSeatmapInput[]
    updateMany?: seatUpdateManyWithWhereWithoutSeatmapInput | seatUpdateManyWithWhereWithoutSeatmapInput[]
    deleteMany?: seatScalarWhereInput | seatScalarWhereInput[]
  }

  export type aircraft_seatmapUncheckedUpdateManyWithoutSeatmapNestedInput = {
    create?: XOR<aircraft_seatmapCreateWithoutSeatmapInput, aircraft_seatmapUncheckedCreateWithoutSeatmapInput> | aircraft_seatmapCreateWithoutSeatmapInput[] | aircraft_seatmapUncheckedCreateWithoutSeatmapInput[]
    connectOrCreate?: aircraft_seatmapCreateOrConnectWithoutSeatmapInput | aircraft_seatmapCreateOrConnectWithoutSeatmapInput[]
    upsert?: aircraft_seatmapUpsertWithWhereUniqueWithoutSeatmapInput | aircraft_seatmapUpsertWithWhereUniqueWithoutSeatmapInput[]
    createMany?: aircraft_seatmapCreateManySeatmapInputEnvelope
    set?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    disconnect?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    delete?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    connect?: aircraft_seatmapWhereUniqueInput | aircraft_seatmapWhereUniqueInput[]
    update?: aircraft_seatmapUpdateWithWhereUniqueWithoutSeatmapInput | aircraft_seatmapUpdateWithWhereUniqueWithoutSeatmapInput[]
    updateMany?: aircraft_seatmapUpdateManyWithWhereWithoutSeatmapInput | aircraft_seatmapUpdateManyWithWhereWithoutSeatmapInput[]
    deleteMany?: aircraft_seatmapScalarWhereInput | aircraft_seatmapScalarWhereInput[]
  }

  export type ticketCreateNestedManyWithoutSeatInput = {
    create?: XOR<ticketCreateWithoutSeatInput, ticketUncheckedCreateWithoutSeatInput> | ticketCreateWithoutSeatInput[] | ticketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutSeatInput | ticketCreateOrConnectWithoutSeatInput[]
    createMany?: ticketCreateManySeatInputEnvelope
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
  }

  export type seatmap_infoCreateNestedOneWithoutSeatInput = {
    create?: XOR<seatmap_infoCreateWithoutSeatInput, seatmap_infoUncheckedCreateWithoutSeatInput>
    connectOrCreate?: seatmap_infoCreateOrConnectWithoutSeatInput
    connect?: seatmap_infoWhereUniqueInput
  }

  export type ticketUncheckedCreateNestedManyWithoutSeatInput = {
    create?: XOR<ticketCreateWithoutSeatInput, ticketUncheckedCreateWithoutSeatInput> | ticketCreateWithoutSeatInput[] | ticketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutSeatInput | ticketCreateOrConnectWithoutSeatInput[]
    createMany?: ticketCreateManySeatInputEnvelope
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
  }

  export type EnumSeatClassFieldUpdateOperationsInput = {
    set?: $Enums.SeatClass
  }

  export type ticketUpdateManyWithoutSeatNestedInput = {
    create?: XOR<ticketCreateWithoutSeatInput, ticketUncheckedCreateWithoutSeatInput> | ticketCreateWithoutSeatInput[] | ticketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutSeatInput | ticketCreateOrConnectWithoutSeatInput[]
    upsert?: ticketUpsertWithWhereUniqueWithoutSeatInput | ticketUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: ticketCreateManySeatInputEnvelope
    set?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    disconnect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    delete?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    update?: ticketUpdateWithWhereUniqueWithoutSeatInput | ticketUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: ticketUpdateManyWithWhereWithoutSeatInput | ticketUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: ticketScalarWhereInput | ticketScalarWhereInput[]
  }

  export type seatmap_infoUpdateOneRequiredWithoutSeatNestedInput = {
    create?: XOR<seatmap_infoCreateWithoutSeatInput, seatmap_infoUncheckedCreateWithoutSeatInput>
    connectOrCreate?: seatmap_infoCreateOrConnectWithoutSeatInput
    upsert?: seatmap_infoUpsertWithoutSeatInput
    connect?: seatmap_infoWhereUniqueInput
    update?: XOR<XOR<seatmap_infoUpdateToOneWithWhereWithoutSeatInput, seatmap_infoUpdateWithoutSeatInput>, seatmap_infoUncheckedUpdateWithoutSeatInput>
  }

  export type ticketUncheckedUpdateManyWithoutSeatNestedInput = {
    create?: XOR<ticketCreateWithoutSeatInput, ticketUncheckedCreateWithoutSeatInput> | ticketCreateWithoutSeatInput[] | ticketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: ticketCreateOrConnectWithoutSeatInput | ticketCreateOrConnectWithoutSeatInput[]
    upsert?: ticketUpsertWithWhereUniqueWithoutSeatInput | ticketUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: ticketCreateManySeatInputEnvelope
    set?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    disconnect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    delete?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    connect?: ticketWhereUniqueInput | ticketWhereUniqueInput[]
    update?: ticketUpdateWithWhereUniqueWithoutSeatInput | ticketUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: ticketUpdateManyWithWhereWithoutSeatInput | ticketUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: ticketScalarWhereInput | ticketScalarWhereInput[]
  }

  export type bookingCreateNestedOneWithoutTicketsInput = {
    create?: XOR<bookingCreateWithoutTicketsInput, bookingUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: bookingCreateOrConnectWithoutTicketsInput
    connect?: bookingWhereUniqueInput
  }

  export type passengerCreateNestedOneWithoutTicketsInput = {
    create?: XOR<passengerCreateWithoutTicketsInput, passengerUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: passengerCreateOrConnectWithoutTicketsInput
    connect?: passengerWhereUniqueInput
  }

  export type flightOperateCreateNestedOneWithoutTicketsInput = {
    create?: XOR<flightOperateCreateWithoutTicketsInput, flightOperateUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: flightOperateCreateOrConnectWithoutTicketsInput
    connect?: flightOperateWhereUniqueInput
  }

  export type seatCreateNestedOneWithoutTicketsInput = {
    create?: XOR<seatCreateWithoutTicketsInput, seatUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: seatCreateOrConnectWithoutTicketsInput
    connect?: seatWhereUniqueInput
  }

  export type EnumFarePackageFieldUpdateOperationsInput = {
    set?: $Enums.FarePackage
  }

  export type bookingUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<bookingCreateWithoutTicketsInput, bookingUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: bookingCreateOrConnectWithoutTicketsInput
    upsert?: bookingUpsertWithoutTicketsInput
    connect?: bookingWhereUniqueInput
    update?: XOR<XOR<bookingUpdateToOneWithWhereWithoutTicketsInput, bookingUpdateWithoutTicketsInput>, bookingUncheckedUpdateWithoutTicketsInput>
  }

  export type passengerUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<passengerCreateWithoutTicketsInput, passengerUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: passengerCreateOrConnectWithoutTicketsInput
    upsert?: passengerUpsertWithoutTicketsInput
    connect?: passengerWhereUniqueInput
    update?: XOR<XOR<passengerUpdateToOneWithWhereWithoutTicketsInput, passengerUpdateWithoutTicketsInput>, passengerUncheckedUpdateWithoutTicketsInput>
  }

  export type flightOperateUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<flightOperateCreateWithoutTicketsInput, flightOperateUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: flightOperateCreateOrConnectWithoutTicketsInput
    upsert?: flightOperateUpsertWithoutTicketsInput
    connect?: flightOperateWhereUniqueInput
    update?: XOR<XOR<flightOperateUpdateToOneWithWhereWithoutTicketsInput, flightOperateUpdateWithoutTicketsInput>, flightOperateUncheckedUpdateWithoutTicketsInput>
  }

  export type seatUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<seatCreateWithoutTicketsInput, seatUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: seatCreateOrConnectWithoutTicketsInput
    upsert?: seatUpsertWithoutTicketsInput
    connect?: seatWhereUniqueInput
    update?: XOR<XOR<seatUpdateToOneWithWhereWithoutTicketsInput, seatUpdateWithoutTicketsInput>, seatUncheckedUpdateWithoutTicketsInput>
  }

  export type flightCreateNestedOneWithoutTransitFromInput = {
    create?: XOR<flightCreateWithoutTransitFromInput, flightUncheckedCreateWithoutTransitFromInput>
    connectOrCreate?: flightCreateOrConnectWithoutTransitFromInput
    connect?: flightWhereUniqueInput
  }

  export type flightCreateNestedOneWithoutTransitToInput = {
    create?: XOR<flightCreateWithoutTransitToInput, flightUncheckedCreateWithoutTransitToInput>
    connectOrCreate?: flightCreateOrConnectWithoutTransitToInput
    connect?: flightWhereUniqueInput
  }

  export type flightUpdateOneRequiredWithoutTransitFromNestedInput = {
    create?: XOR<flightCreateWithoutTransitFromInput, flightUncheckedCreateWithoutTransitFromInput>
    connectOrCreate?: flightCreateOrConnectWithoutTransitFromInput
    upsert?: flightUpsertWithoutTransitFromInput
    connect?: flightWhereUniqueInput
    update?: XOR<XOR<flightUpdateToOneWithWhereWithoutTransitFromInput, flightUpdateWithoutTransitFromInput>, flightUncheckedUpdateWithoutTransitFromInput>
  }

  export type flightUpdateOneRequiredWithoutTransitToNestedInput = {
    create?: XOR<flightCreateWithoutTransitToInput, flightUncheckedCreateWithoutTransitToInput>
    connectOrCreate?: flightCreateOrConnectWithoutTransitToInput
    upsert?: flightUpsertWithoutTransitToInput
    connect?: flightWhereUniqueInput
    update?: XOR<XOR<flightUpdateToOneWithWhereWithoutTransitToInput, flightUpdateWithoutTransitToInput>, flightUncheckedUpdateWithoutTransitToInput>
  }

  export type bookingCreateNestedManyWithoutUserInput = {
    create?: XOR<bookingCreateWithoutUserInput, bookingUncheckedCreateWithoutUserInput> | bookingCreateWithoutUserInput[] | bookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bookingCreateOrConnectWithoutUserInput | bookingCreateOrConnectWithoutUserInput[]
    createMany?: bookingCreateManyUserInputEnvelope
    connect?: bookingWhereUniqueInput | bookingWhereUniqueInput[]
  }

  export type passengerCreateNestedManyWithoutUserInput = {
    create?: XOR<passengerCreateWithoutUserInput, passengerUncheckedCreateWithoutUserInput> | passengerCreateWithoutUserInput[] | passengerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: passengerCreateOrConnectWithoutUserInput | passengerCreateOrConnectWithoutUserInput[]
    createMany?: passengerCreateManyUserInputEnvelope
    connect?: passengerWhereUniqueInput | passengerWhereUniqueInput[]
  }

  export type bookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<bookingCreateWithoutUserInput, bookingUncheckedCreateWithoutUserInput> | bookingCreateWithoutUserInput[] | bookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bookingCreateOrConnectWithoutUserInput | bookingCreateOrConnectWithoutUserInput[]
    createMany?: bookingCreateManyUserInputEnvelope
    connect?: bookingWhereUniqueInput | bookingWhereUniqueInput[]
  }

  export type passengerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<passengerCreateWithoutUserInput, passengerUncheckedCreateWithoutUserInput> | passengerCreateWithoutUserInput[] | passengerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: passengerCreateOrConnectWithoutUserInput | passengerCreateOrConnectWithoutUserInput[]
    createMany?: passengerCreateManyUserInputEnvelope
    connect?: passengerWhereUniqueInput | passengerWhereUniqueInput[]
  }

  export type bookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<bookingCreateWithoutUserInput, bookingUncheckedCreateWithoutUserInput> | bookingCreateWithoutUserInput[] | bookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bookingCreateOrConnectWithoutUserInput | bookingCreateOrConnectWithoutUserInput[]
    upsert?: bookingUpsertWithWhereUniqueWithoutUserInput | bookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: bookingCreateManyUserInputEnvelope
    set?: bookingWhereUniqueInput | bookingWhereUniqueInput[]
    disconnect?: bookingWhereUniqueInput | bookingWhereUniqueInput[]
    delete?: bookingWhereUniqueInput | bookingWhereUniqueInput[]
    connect?: bookingWhereUniqueInput | bookingWhereUniqueInput[]
    update?: bookingUpdateWithWhereUniqueWithoutUserInput | bookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: bookingUpdateManyWithWhereWithoutUserInput | bookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: bookingScalarWhereInput | bookingScalarWhereInput[]
  }

  export type passengerUpdateManyWithoutUserNestedInput = {
    create?: XOR<passengerCreateWithoutUserInput, passengerUncheckedCreateWithoutUserInput> | passengerCreateWithoutUserInput[] | passengerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: passengerCreateOrConnectWithoutUserInput | passengerCreateOrConnectWithoutUserInput[]
    upsert?: passengerUpsertWithWhereUniqueWithoutUserInput | passengerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: passengerCreateManyUserInputEnvelope
    set?: passengerWhereUniqueInput | passengerWhereUniqueInput[]
    disconnect?: passengerWhereUniqueInput | passengerWhereUniqueInput[]
    delete?: passengerWhereUniqueInput | passengerWhereUniqueInput[]
    connect?: passengerWhereUniqueInput | passengerWhereUniqueInput[]
    update?: passengerUpdateWithWhereUniqueWithoutUserInput | passengerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: passengerUpdateManyWithWhereWithoutUserInput | passengerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: passengerScalarWhereInput | passengerScalarWhereInput[]
  }

  export type bookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<bookingCreateWithoutUserInput, bookingUncheckedCreateWithoutUserInput> | bookingCreateWithoutUserInput[] | bookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bookingCreateOrConnectWithoutUserInput | bookingCreateOrConnectWithoutUserInput[]
    upsert?: bookingUpsertWithWhereUniqueWithoutUserInput | bookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: bookingCreateManyUserInputEnvelope
    set?: bookingWhereUniqueInput | bookingWhereUniqueInput[]
    disconnect?: bookingWhereUniqueInput | bookingWhereUniqueInput[]
    delete?: bookingWhereUniqueInput | bookingWhereUniqueInput[]
    connect?: bookingWhereUniqueInput | bookingWhereUniqueInput[]
    update?: bookingUpdateWithWhereUniqueWithoutUserInput | bookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: bookingUpdateManyWithWhereWithoutUserInput | bookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: bookingScalarWhereInput | bookingScalarWhereInput[]
  }

  export type passengerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<passengerCreateWithoutUserInput, passengerUncheckedCreateWithoutUserInput> | passengerCreateWithoutUserInput[] | passengerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: passengerCreateOrConnectWithoutUserInput | passengerCreateOrConnectWithoutUserInput[]
    upsert?: passengerUpsertWithWhereUniqueWithoutUserInput | passengerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: passengerCreateManyUserInputEnvelope
    set?: passengerWhereUniqueInput | passengerWhereUniqueInput[]
    disconnect?: passengerWhereUniqueInput | passengerWhereUniqueInput[]
    delete?: passengerWhereUniqueInput | passengerWhereUniqueInput[]
    connect?: passengerWhereUniqueInput | passengerWhereUniqueInput[]
    update?: passengerUpdateWithWhereUniqueWithoutUserInput | passengerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: passengerUpdateManyWithWhereWithoutUserInput | passengerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: passengerScalarWhereInput | passengerScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.Permission[]
    notIn?: $Enums.Permission[]
    not?: NestedEnumPermissionFilter<$PrismaModel> | $Enums.Permission
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.Permission[]
    notIn?: $Enums.Permission[]
    not?: NestedEnumPermissionWithAggregatesFilter<$PrismaModel> | $Enums.Permission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionFilter<$PrismaModel>
    _max?: NestedEnumPermissionFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumAgeRangeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRange | EnumAgeRangeFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRange[]
    notIn?: $Enums.AgeRange[]
    not?: NestedEnumAgeRangeFilter<$PrismaModel> | $Enums.AgeRange
  }

  export type NestedEnumAgeRangeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRange | EnumAgeRangeFieldRefInput<$PrismaModel>
    in?: $Enums.AgeRange[]
    notIn?: $Enums.AgeRange[]
    not?: NestedEnumAgeRangeWithAggregatesFilter<$PrismaModel> | $Enums.AgeRange
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgeRangeFilter<$PrismaModel>
    _max?: NestedEnumAgeRangeFilter<$PrismaModel>
  }

  export type NestedEnumSeatClassFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatClass | EnumSeatClassFieldRefInput<$PrismaModel>
    in?: $Enums.SeatClass[]
    notIn?: $Enums.SeatClass[]
    not?: NestedEnumSeatClassFilter<$PrismaModel> | $Enums.SeatClass
  }

  export type NestedEnumSeatClassWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatClass | EnumSeatClassFieldRefInput<$PrismaModel>
    in?: $Enums.SeatClass[]
    notIn?: $Enums.SeatClass[]
    not?: NestedEnumSeatClassWithAggregatesFilter<$PrismaModel> | $Enums.SeatClass
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeatClassFilter<$PrismaModel>
    _max?: NestedEnumSeatClassFilter<$PrismaModel>
  }

  export type NestedEnumFarePackageFilter<$PrismaModel = never> = {
    equals?: $Enums.FarePackage | EnumFarePackageFieldRefInput<$PrismaModel>
    in?: $Enums.FarePackage[]
    notIn?: $Enums.FarePackage[]
    not?: NestedEnumFarePackageFilter<$PrismaModel> | $Enums.FarePackage
  }

  export type NestedEnumFarePackageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FarePackage | EnumFarePackageFieldRefInput<$PrismaModel>
    in?: $Enums.FarePackage[]
    notIn?: $Enums.FarePackage[]
    not?: NestedEnumFarePackageWithAggregatesFilter<$PrismaModel> | $Enums.FarePackage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFarePackageFilter<$PrismaModel>
    _max?: NestedEnumFarePackageFilter<$PrismaModel>
  }

  export type aircraftCreateWithoutAirlineInput = {
    aircraftId: string
    model: string
    flightOperate?: flightOperateCreateNestedManyWithoutAircraftInput
    aircraftSeatmap?: aircraft_seatmapCreateNestedManyWithoutAircraftInput
  }

  export type aircraftUncheckedCreateWithoutAirlineInput = {
    aircraftId: string
    model: string
    flightOperate?: flightOperateUncheckedCreateNestedManyWithoutAircraftInput
    aircraftSeatmap?: aircraft_seatmapUncheckedCreateNestedManyWithoutAircraftInput
  }

  export type aircraftCreateOrConnectWithoutAirlineInput = {
    where: aircraftWhereUniqueInput
    create: XOR<aircraftCreateWithoutAirlineInput, aircraftUncheckedCreateWithoutAirlineInput>
  }

  export type aircraftCreateManyAirlineInputEnvelope = {
    data: aircraftCreateManyAirlineInput | aircraftCreateManyAirlineInput[]
    skipDuplicates?: boolean
  }

  export type aircraftCostCreateWithoutAirlineInput = {
    model: string
    costPerMile: number
  }

  export type aircraftCostUncheckedCreateWithoutAirlineInput = {
    model: string
    costPerMile: number
  }

  export type aircraftCostCreateOrConnectWithoutAirlineInput = {
    where: aircraftCostWhereUniqueInput
    create: XOR<aircraftCostCreateWithoutAirlineInput, aircraftCostUncheckedCreateWithoutAirlineInput>
  }

  export type aircraftCostCreateManyAirlineInputEnvelope = {
    data: aircraftCostCreateManyAirlineInput | aircraftCostCreateManyAirlineInput[]
    skipDuplicates?: boolean
  }

  export type flightCreateWithoutAirlineInput = {
    flightNum: string
    departAirport: airportCreateNestedOneWithoutDepartFlightsInput
    arriveAirport: airportCreateNestedOneWithoutArriveFlightsInput
    flightOperates?: flightOperateCreateNestedManyWithoutFlightInput
    transitFrom?: transitCreateNestedManyWithoutFromInput
    transitTo?: transitCreateNestedManyWithoutToInput
  }

  export type flightUncheckedCreateWithoutAirlineInput = {
    flightNum: string
    departAirportId: string
    arriveAirportId: string
    flightOperates?: flightOperateUncheckedCreateNestedManyWithoutFlightInput
    transitFrom?: transitUncheckedCreateNestedManyWithoutFromInput
    transitTo?: transitUncheckedCreateNestedManyWithoutToInput
  }

  export type flightCreateOrConnectWithoutAirlineInput = {
    where: flightWhereUniqueInput
    create: XOR<flightCreateWithoutAirlineInput, flightUncheckedCreateWithoutAirlineInput>
  }

  export type flightCreateManyAirlineInputEnvelope = {
    data: flightCreateManyAirlineInput | flightCreateManyAirlineInput[]
    skipDuplicates?: boolean
  }

  export type aircraftUpsertWithWhereUniqueWithoutAirlineInput = {
    where: aircraftWhereUniqueInput
    update: XOR<aircraftUpdateWithoutAirlineInput, aircraftUncheckedUpdateWithoutAirlineInput>
    create: XOR<aircraftCreateWithoutAirlineInput, aircraftUncheckedCreateWithoutAirlineInput>
  }

  export type aircraftUpdateWithWhereUniqueWithoutAirlineInput = {
    where: aircraftWhereUniqueInput
    data: XOR<aircraftUpdateWithoutAirlineInput, aircraftUncheckedUpdateWithoutAirlineInput>
  }

  export type aircraftUpdateManyWithWhereWithoutAirlineInput = {
    where: aircraftScalarWhereInput
    data: XOR<aircraftUpdateManyMutationInput, aircraftUncheckedUpdateManyWithoutAirlineInput>
  }

  export type aircraftScalarWhereInput = {
    AND?: aircraftScalarWhereInput | aircraftScalarWhereInput[]
    OR?: aircraftScalarWhereInput[]
    NOT?: aircraftScalarWhereInput | aircraftScalarWhereInput[]
    aircraftId?: StringFilter<"aircraft"> | string
    ownerAirlineCode?: StringFilter<"aircraft"> | string
    model?: StringFilter<"aircraft"> | string
  }

  export type aircraftCostUpsertWithWhereUniqueWithoutAirlineInput = {
    where: aircraftCostWhereUniqueInput
    update: XOR<aircraftCostUpdateWithoutAirlineInput, aircraftCostUncheckedUpdateWithoutAirlineInput>
    create: XOR<aircraftCostCreateWithoutAirlineInput, aircraftCostUncheckedCreateWithoutAirlineInput>
  }

  export type aircraftCostUpdateWithWhereUniqueWithoutAirlineInput = {
    where: aircraftCostWhereUniqueInput
    data: XOR<aircraftCostUpdateWithoutAirlineInput, aircraftCostUncheckedUpdateWithoutAirlineInput>
  }

  export type aircraftCostUpdateManyWithWhereWithoutAirlineInput = {
    where: aircraftCostScalarWhereInput
    data: XOR<aircraftCostUpdateManyMutationInput, aircraftCostUncheckedUpdateManyWithoutAirlineInput>
  }

  export type aircraftCostScalarWhereInput = {
    AND?: aircraftCostScalarWhereInput | aircraftCostScalarWhereInput[]
    OR?: aircraftCostScalarWhereInput[]
    NOT?: aircraftCostScalarWhereInput | aircraftCostScalarWhereInput[]
    model?: StringFilter<"aircraftCost"> | string
    ownerAirlineCode?: StringFilter<"aircraftCost"> | string
    costPerMile?: FloatFilter<"aircraftCost"> | number
  }

  export type flightUpsertWithWhereUniqueWithoutAirlineInput = {
    where: flightWhereUniqueInput
    update: XOR<flightUpdateWithoutAirlineInput, flightUncheckedUpdateWithoutAirlineInput>
    create: XOR<flightCreateWithoutAirlineInput, flightUncheckedCreateWithoutAirlineInput>
  }

  export type flightUpdateWithWhereUniqueWithoutAirlineInput = {
    where: flightWhereUniqueInput
    data: XOR<flightUpdateWithoutAirlineInput, flightUncheckedUpdateWithoutAirlineInput>
  }

  export type flightUpdateManyWithWhereWithoutAirlineInput = {
    where: flightScalarWhereInput
    data: XOR<flightUpdateManyMutationInput, flightUncheckedUpdateManyWithoutAirlineInput>
  }

  export type flightScalarWhereInput = {
    AND?: flightScalarWhereInput | flightScalarWhereInput[]
    OR?: flightScalarWhereInput[]
    NOT?: flightScalarWhereInput | flightScalarWhereInput[]
    flightNum?: StringFilter<"flight"> | string
    airlineCode?: StringFilter<"flight"> | string
    departAirportId?: StringFilter<"flight"> | string
    arriveAirportId?: StringFilter<"flight"> | string
  }

  export type airlineCreateWithoutAircraftInput = {
    airlineCode: string
    airlineName: string
    aircraftCost?: aircraftCostCreateNestedManyWithoutAirlineInput
    flight?: flightCreateNestedManyWithoutAirlineInput
  }

  export type airlineUncheckedCreateWithoutAircraftInput = {
    airlineCode: string
    airlineName: string
    aircraftCost?: aircraftCostUncheckedCreateNestedManyWithoutAirlineInput
    flight?: flightUncheckedCreateNestedManyWithoutAirlineInput
  }

  export type airlineCreateOrConnectWithoutAircraftInput = {
    where: airlineWhereUniqueInput
    create: XOR<airlineCreateWithoutAircraftInput, airlineUncheckedCreateWithoutAircraftInput>
  }

  export type flightOperateCreateWithoutAircraftInput = {
    flightId: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
    flight: flightCreateNestedOneWithoutFlightOperatesInput
    bookingFlights?: booking_flightCreateNestedManyWithoutFlightInput
    tickets?: ticketCreateNestedManyWithoutFlightInput
  }

  export type flightOperateUncheckedCreateWithoutAircraftInput = {
    flightId: string
    flightNum: string
    airlineCode: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
    bookingFlights?: booking_flightUncheckedCreateNestedManyWithoutFlightInput
    tickets?: ticketUncheckedCreateNestedManyWithoutFlightInput
  }

  export type flightOperateCreateOrConnectWithoutAircraftInput = {
    where: flightOperateWhereUniqueInput
    create: XOR<flightOperateCreateWithoutAircraftInput, flightOperateUncheckedCreateWithoutAircraftInput>
  }

  export type flightOperateCreateManyAircraftInputEnvelope = {
    data: flightOperateCreateManyAircraftInput | flightOperateCreateManyAircraftInput[]
    skipDuplicates?: boolean
  }

  export type aircraft_seatmapCreateWithoutAircraftInput = {
    seatmap: seatmap_infoCreateNestedOneWithoutAircraftInput
  }

  export type aircraft_seatmapUncheckedCreateWithoutAircraftInput = {
    seatMapId: string
  }

  export type aircraft_seatmapCreateOrConnectWithoutAircraftInput = {
    where: aircraft_seatmapWhereUniqueInput
    create: XOR<aircraft_seatmapCreateWithoutAircraftInput, aircraft_seatmapUncheckedCreateWithoutAircraftInput>
  }

  export type aircraft_seatmapCreateManyAircraftInputEnvelope = {
    data: aircraft_seatmapCreateManyAircraftInput | aircraft_seatmapCreateManyAircraftInput[]
    skipDuplicates?: boolean
  }

  export type airlineUpsertWithoutAircraftInput = {
    update: XOR<airlineUpdateWithoutAircraftInput, airlineUncheckedUpdateWithoutAircraftInput>
    create: XOR<airlineCreateWithoutAircraftInput, airlineUncheckedCreateWithoutAircraftInput>
    where?: airlineWhereInput
  }

  export type airlineUpdateToOneWithWhereWithoutAircraftInput = {
    where?: airlineWhereInput
    data: XOR<airlineUpdateWithoutAircraftInput, airlineUncheckedUpdateWithoutAircraftInput>
  }

  export type airlineUpdateWithoutAircraftInput = {
    airlineCode?: StringFieldUpdateOperationsInput | string
    airlineName?: StringFieldUpdateOperationsInput | string
    aircraftCost?: aircraftCostUpdateManyWithoutAirlineNestedInput
    flight?: flightUpdateManyWithoutAirlineNestedInput
  }

  export type airlineUncheckedUpdateWithoutAircraftInput = {
    airlineCode?: StringFieldUpdateOperationsInput | string
    airlineName?: StringFieldUpdateOperationsInput | string
    aircraftCost?: aircraftCostUncheckedUpdateManyWithoutAirlineNestedInput
    flight?: flightUncheckedUpdateManyWithoutAirlineNestedInput
  }

  export type flightOperateUpsertWithWhereUniqueWithoutAircraftInput = {
    where: flightOperateWhereUniqueInput
    update: XOR<flightOperateUpdateWithoutAircraftInput, flightOperateUncheckedUpdateWithoutAircraftInput>
    create: XOR<flightOperateCreateWithoutAircraftInput, flightOperateUncheckedCreateWithoutAircraftInput>
  }

  export type flightOperateUpdateWithWhereUniqueWithoutAircraftInput = {
    where: flightOperateWhereUniqueInput
    data: XOR<flightOperateUpdateWithoutAircraftInput, flightOperateUncheckedUpdateWithoutAircraftInput>
  }

  export type flightOperateUpdateManyWithWhereWithoutAircraftInput = {
    where: flightOperateScalarWhereInput
    data: XOR<flightOperateUpdateManyMutationInput, flightOperateUncheckedUpdateManyWithoutAircraftInput>
  }

  export type flightOperateScalarWhereInput = {
    AND?: flightOperateScalarWhereInput | flightOperateScalarWhereInput[]
    OR?: flightOperateScalarWhereInput[]
    NOT?: flightOperateScalarWhereInput | flightOperateScalarWhereInput[]
    flightId?: StringFilter<"flightOperate"> | string
    flightNum?: StringFilter<"flightOperate"> | string
    airlineCode?: StringFilter<"flightOperate"> | string
    departureTime?: DateTimeFilter<"flightOperate"> | Date | string
    arrivalTime?: DateTimeFilter<"flightOperate"> | Date | string
    departureGate?: StringFilter<"flightOperate"> | string
    aircraftId?: StringFilter<"flightOperate"> | string
  }

  export type aircraft_seatmapUpsertWithWhereUniqueWithoutAircraftInput = {
    where: aircraft_seatmapWhereUniqueInput
    update: XOR<aircraft_seatmapUpdateWithoutAircraftInput, aircraft_seatmapUncheckedUpdateWithoutAircraftInput>
    create: XOR<aircraft_seatmapCreateWithoutAircraftInput, aircraft_seatmapUncheckedCreateWithoutAircraftInput>
  }

  export type aircraft_seatmapUpdateWithWhereUniqueWithoutAircraftInput = {
    where: aircraft_seatmapWhereUniqueInput
    data: XOR<aircraft_seatmapUpdateWithoutAircraftInput, aircraft_seatmapUncheckedUpdateWithoutAircraftInput>
  }

  export type aircraft_seatmapUpdateManyWithWhereWithoutAircraftInput = {
    where: aircraft_seatmapScalarWhereInput
    data: XOR<aircraft_seatmapUpdateManyMutationInput, aircraft_seatmapUncheckedUpdateManyWithoutAircraftInput>
  }

  export type aircraft_seatmapScalarWhereInput = {
    AND?: aircraft_seatmapScalarWhereInput | aircraft_seatmapScalarWhereInput[]
    OR?: aircraft_seatmapScalarWhereInput[]
    NOT?: aircraft_seatmapScalarWhereInput | aircraft_seatmapScalarWhereInput[]
    aircraftId?: StringFilter<"aircraft_seatmap"> | string
    seatMapId?: StringFilter<"aircraft_seatmap"> | string
  }

  export type airlineCreateWithoutAircraftCostInput = {
    airlineCode: string
    airlineName: string
    aircraft?: aircraftCreateNestedManyWithoutAirlineInput
    flight?: flightCreateNestedManyWithoutAirlineInput
  }

  export type airlineUncheckedCreateWithoutAircraftCostInput = {
    airlineCode: string
    airlineName: string
    aircraft?: aircraftUncheckedCreateNestedManyWithoutAirlineInput
    flight?: flightUncheckedCreateNestedManyWithoutAirlineInput
  }

  export type airlineCreateOrConnectWithoutAircraftCostInput = {
    where: airlineWhereUniqueInput
    create: XOR<airlineCreateWithoutAircraftCostInput, airlineUncheckedCreateWithoutAircraftCostInput>
  }

  export type airlineUpsertWithoutAircraftCostInput = {
    update: XOR<airlineUpdateWithoutAircraftCostInput, airlineUncheckedUpdateWithoutAircraftCostInput>
    create: XOR<airlineCreateWithoutAircraftCostInput, airlineUncheckedCreateWithoutAircraftCostInput>
    where?: airlineWhereInput
  }

  export type airlineUpdateToOneWithWhereWithoutAircraftCostInput = {
    where?: airlineWhereInput
    data: XOR<airlineUpdateWithoutAircraftCostInput, airlineUncheckedUpdateWithoutAircraftCostInput>
  }

  export type airlineUpdateWithoutAircraftCostInput = {
    airlineCode?: StringFieldUpdateOperationsInput | string
    airlineName?: StringFieldUpdateOperationsInput | string
    aircraft?: aircraftUpdateManyWithoutAirlineNestedInput
    flight?: flightUpdateManyWithoutAirlineNestedInput
  }

  export type airlineUncheckedUpdateWithoutAircraftCostInput = {
    airlineCode?: StringFieldUpdateOperationsInput | string
    airlineName?: StringFieldUpdateOperationsInput | string
    aircraft?: aircraftUncheckedUpdateManyWithoutAirlineNestedInput
    flight?: flightUncheckedUpdateManyWithoutAirlineNestedInput
  }

  export type flightCreateWithoutDepartAirportInput = {
    flightNum: string
    airline: airlineCreateNestedOneWithoutFlightInput
    arriveAirport: airportCreateNestedOneWithoutArriveFlightsInput
    flightOperates?: flightOperateCreateNestedManyWithoutFlightInput
    transitFrom?: transitCreateNestedManyWithoutFromInput
    transitTo?: transitCreateNestedManyWithoutToInput
  }

  export type flightUncheckedCreateWithoutDepartAirportInput = {
    flightNum: string
    airlineCode: string
    arriveAirportId: string
    flightOperates?: flightOperateUncheckedCreateNestedManyWithoutFlightInput
    transitFrom?: transitUncheckedCreateNestedManyWithoutFromInput
    transitTo?: transitUncheckedCreateNestedManyWithoutToInput
  }

  export type flightCreateOrConnectWithoutDepartAirportInput = {
    where: flightWhereUniqueInput
    create: XOR<flightCreateWithoutDepartAirportInput, flightUncheckedCreateWithoutDepartAirportInput>
  }

  export type flightCreateManyDepartAirportInputEnvelope = {
    data: flightCreateManyDepartAirportInput | flightCreateManyDepartAirportInput[]
    skipDuplicates?: boolean
  }

  export type flightCreateWithoutArriveAirportInput = {
    flightNum: string
    airline: airlineCreateNestedOneWithoutFlightInput
    departAirport: airportCreateNestedOneWithoutDepartFlightsInput
    flightOperates?: flightOperateCreateNestedManyWithoutFlightInput
    transitFrom?: transitCreateNestedManyWithoutFromInput
    transitTo?: transitCreateNestedManyWithoutToInput
  }

  export type flightUncheckedCreateWithoutArriveAirportInput = {
    flightNum: string
    airlineCode: string
    departAirportId: string
    flightOperates?: flightOperateUncheckedCreateNestedManyWithoutFlightInput
    transitFrom?: transitUncheckedCreateNestedManyWithoutFromInput
    transitTo?: transitUncheckedCreateNestedManyWithoutToInput
  }

  export type flightCreateOrConnectWithoutArriveAirportInput = {
    where: flightWhereUniqueInput
    create: XOR<flightCreateWithoutArriveAirportInput, flightUncheckedCreateWithoutArriveAirportInput>
  }

  export type flightCreateManyArriveAirportInputEnvelope = {
    data: flightCreateManyArriveAirportInput | flightCreateManyArriveAirportInput[]
    skipDuplicates?: boolean
  }

  export type flightUpsertWithWhereUniqueWithoutDepartAirportInput = {
    where: flightWhereUniqueInput
    update: XOR<flightUpdateWithoutDepartAirportInput, flightUncheckedUpdateWithoutDepartAirportInput>
    create: XOR<flightCreateWithoutDepartAirportInput, flightUncheckedCreateWithoutDepartAirportInput>
  }

  export type flightUpdateWithWhereUniqueWithoutDepartAirportInput = {
    where: flightWhereUniqueInput
    data: XOR<flightUpdateWithoutDepartAirportInput, flightUncheckedUpdateWithoutDepartAirportInput>
  }

  export type flightUpdateManyWithWhereWithoutDepartAirportInput = {
    where: flightScalarWhereInput
    data: XOR<flightUpdateManyMutationInput, flightUncheckedUpdateManyWithoutDepartAirportInput>
  }

  export type flightUpsertWithWhereUniqueWithoutArriveAirportInput = {
    where: flightWhereUniqueInput
    update: XOR<flightUpdateWithoutArriveAirportInput, flightUncheckedUpdateWithoutArriveAirportInput>
    create: XOR<flightCreateWithoutArriveAirportInput, flightUncheckedCreateWithoutArriveAirportInput>
  }

  export type flightUpdateWithWhereUniqueWithoutArriveAirportInput = {
    where: flightWhereUniqueInput
    data: XOR<flightUpdateWithoutArriveAirportInput, flightUncheckedUpdateWithoutArriveAirportInput>
  }

  export type flightUpdateManyWithWhereWithoutArriveAirportInput = {
    where: flightScalarWhereInput
    data: XOR<flightUpdateManyMutationInput, flightUncheckedUpdateManyWithoutArriveAirportInput>
  }

  export type userCreateWithoutBookingsInput = {
    uuid?: string
    password: string
    firstname: string
    lastname: string
    email: string
    phone: string
    registerDate?: Date | string
    passengers?: passengerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutBookingsInput = {
    uuid?: string
    password: string
    firstname: string
    lastname: string
    email: string
    phone: string
    registerDate?: Date | string
    passengers?: passengerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutBookingsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutBookingsInput, userUncheckedCreateWithoutBookingsInput>
  }

  export type booking_flightCreateWithoutBookingInput = {
    flight: flightOperateCreateNestedOneWithoutBookingFlightsInput
  }

  export type booking_flightUncheckedCreateWithoutBookingInput = {
    flightId: string
  }

  export type booking_flightCreateOrConnectWithoutBookingInput = {
    where: booking_flightWhereUniqueInput
    create: XOR<booking_flightCreateWithoutBookingInput, booking_flightUncheckedCreateWithoutBookingInput>
  }

  export type booking_flightCreateManyBookingInputEnvelope = {
    data: booking_flightCreateManyBookingInput | booking_flightCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type passenger_bookingCreateWithoutBookingInput = {
    passenger: passengerCreateNestedOneWithoutPassengerBookingsInput
  }

  export type passenger_bookingUncheckedCreateWithoutBookingInput = {
    passportNum: string
  }

  export type passenger_bookingCreateOrConnectWithoutBookingInput = {
    where: passenger_bookingWhereUniqueInput
    create: XOR<passenger_bookingCreateWithoutBookingInput, passenger_bookingUncheckedCreateWithoutBookingInput>
  }

  export type passenger_bookingCreateManyBookingInputEnvelope = {
    data: passenger_bookingCreateManyBookingInput | passenger_bookingCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type ticketCreateWithoutBookingInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    passenger: passengerCreateNestedOneWithoutTicketsInput
    flight: flightOperateCreateNestedOneWithoutTicketsInput
    seat: seatCreateNestedOneWithoutTicketsInput
  }

  export type ticketUncheckedCreateWithoutBookingInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    flightId: string
    passportNum: string
    seatNum: string
  }

  export type ticketCreateOrConnectWithoutBookingInput = {
    where: ticketWhereUniqueInput
    create: XOR<ticketCreateWithoutBookingInput, ticketUncheckedCreateWithoutBookingInput>
  }

  export type ticketCreateManyBookingInputEnvelope = {
    data: ticketCreateManyBookingInput | ticketCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type paymentCreateWithoutBookingInput = {
    paymentId: string
    amount?: number
    method: string
    paymentDate?: Date | string
  }

  export type paymentUncheckedCreateWithoutBookingInput = {
    paymentId: string
    amount?: number
    method: string
    paymentDate?: Date | string
  }

  export type paymentCreateOrConnectWithoutBookingInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutBookingInput, paymentUncheckedCreateWithoutBookingInput>
  }

  export type userUpsertWithoutBookingsInput = {
    update: XOR<userUpdateWithoutBookingsInput, userUncheckedUpdateWithoutBookingsInput>
    create: XOR<userCreateWithoutBookingsInput, userUncheckedCreateWithoutBookingsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutBookingsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutBookingsInput, userUncheckedUpdateWithoutBookingsInput>
  }

  export type userUpdateWithoutBookingsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    registerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    passengers?: passengerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutBookingsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    registerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    passengers?: passengerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type booking_flightUpsertWithWhereUniqueWithoutBookingInput = {
    where: booking_flightWhereUniqueInput
    update: XOR<booking_flightUpdateWithoutBookingInput, booking_flightUncheckedUpdateWithoutBookingInput>
    create: XOR<booking_flightCreateWithoutBookingInput, booking_flightUncheckedCreateWithoutBookingInput>
  }

  export type booking_flightUpdateWithWhereUniqueWithoutBookingInput = {
    where: booking_flightWhereUniqueInput
    data: XOR<booking_flightUpdateWithoutBookingInput, booking_flightUncheckedUpdateWithoutBookingInput>
  }

  export type booking_flightUpdateManyWithWhereWithoutBookingInput = {
    where: booking_flightScalarWhereInput
    data: XOR<booking_flightUpdateManyMutationInput, booking_flightUncheckedUpdateManyWithoutBookingInput>
  }

  export type booking_flightScalarWhereInput = {
    AND?: booking_flightScalarWhereInput | booking_flightScalarWhereInput[]
    OR?: booking_flightScalarWhereInput[]
    NOT?: booking_flightScalarWhereInput | booking_flightScalarWhereInput[]
    bookingId?: StringFilter<"booking_flight"> | string
    flightId?: StringFilter<"booking_flight"> | string
  }

  export type passenger_bookingUpsertWithWhereUniqueWithoutBookingInput = {
    where: passenger_bookingWhereUniqueInput
    update: XOR<passenger_bookingUpdateWithoutBookingInput, passenger_bookingUncheckedUpdateWithoutBookingInput>
    create: XOR<passenger_bookingCreateWithoutBookingInput, passenger_bookingUncheckedCreateWithoutBookingInput>
  }

  export type passenger_bookingUpdateWithWhereUniqueWithoutBookingInput = {
    where: passenger_bookingWhereUniqueInput
    data: XOR<passenger_bookingUpdateWithoutBookingInput, passenger_bookingUncheckedUpdateWithoutBookingInput>
  }

  export type passenger_bookingUpdateManyWithWhereWithoutBookingInput = {
    where: passenger_bookingScalarWhereInput
    data: XOR<passenger_bookingUpdateManyMutationInput, passenger_bookingUncheckedUpdateManyWithoutBookingInput>
  }

  export type passenger_bookingScalarWhereInput = {
    AND?: passenger_bookingScalarWhereInput | passenger_bookingScalarWhereInput[]
    OR?: passenger_bookingScalarWhereInput[]
    NOT?: passenger_bookingScalarWhereInput | passenger_bookingScalarWhereInput[]
    bookingId?: StringFilter<"passenger_booking"> | string
    passportNum?: StringFilter<"passenger_booking"> | string
  }

  export type ticketUpsertWithWhereUniqueWithoutBookingInput = {
    where: ticketWhereUniqueInput
    update: XOR<ticketUpdateWithoutBookingInput, ticketUncheckedUpdateWithoutBookingInput>
    create: XOR<ticketCreateWithoutBookingInput, ticketUncheckedCreateWithoutBookingInput>
  }

  export type ticketUpdateWithWhereUniqueWithoutBookingInput = {
    where: ticketWhereUniqueInput
    data: XOR<ticketUpdateWithoutBookingInput, ticketUncheckedUpdateWithoutBookingInput>
  }

  export type ticketUpdateManyWithWhereWithoutBookingInput = {
    where: ticketScalarWhereInput
    data: XOR<ticketUpdateManyMutationInput, ticketUncheckedUpdateManyWithoutBookingInput>
  }

  export type ticketScalarWhereInput = {
    AND?: ticketScalarWhereInput | ticketScalarWhereInput[]
    OR?: ticketScalarWhereInput[]
    NOT?: ticketScalarWhereInput | ticketScalarWhereInput[]
    ticketNum?: StringFilter<"ticket"> | string
    farePackage?: EnumFarePackageFilter<"ticket"> | $Enums.FarePackage
    baggageAllowanceWeight?: IntFilter<"ticket"> | number
    baggageAllowancePrice?: FloatFilter<"ticket"> | number
    mealSelection?: StringFilter<"ticket"> | string
    mealPrice?: FloatFilter<"ticket"> | number
    ticketPrice?: FloatFilter<"ticket"> | number
    bookingId?: StringFilter<"ticket"> | string
    flightId?: StringFilter<"ticket"> | string
    passportNum?: StringFilter<"ticket"> | string
    seatNum?: StringFilter<"ticket"> | string
  }

  export type paymentUpsertWithoutBookingInput = {
    update: XOR<paymentUpdateWithoutBookingInput, paymentUncheckedUpdateWithoutBookingInput>
    create: XOR<paymentCreateWithoutBookingInput, paymentUncheckedCreateWithoutBookingInput>
    where?: paymentWhereInput
  }

  export type paymentUpdateToOneWithWhereWithoutBookingInput = {
    where?: paymentWhereInput
    data: XOR<paymentUpdateWithoutBookingInput, paymentUncheckedUpdateWithoutBookingInput>
  }

  export type paymentUpdateWithoutBookingInput = {
    paymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentUncheckedUpdateWithoutBookingInput = {
    paymentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookingCreateWithoutBookingFlightsInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    user: userCreateNestedOneWithoutBookingsInput
    passengerBookings?: passenger_bookingCreateNestedManyWithoutBookingInput
    tickets?: ticketCreateNestedManyWithoutBookingInput
    payment?: paymentCreateNestedOneWithoutBookingInput
  }

  export type bookingUncheckedCreateWithoutBookingFlightsInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    userId: string
    passengerBookings?: passenger_bookingUncheckedCreateNestedManyWithoutBookingInput
    tickets?: ticketUncheckedCreateNestedManyWithoutBookingInput
    payment?: paymentUncheckedCreateNestedOneWithoutBookingInput
  }

  export type bookingCreateOrConnectWithoutBookingFlightsInput = {
    where: bookingWhereUniqueInput
    create: XOR<bookingCreateWithoutBookingFlightsInput, bookingUncheckedCreateWithoutBookingFlightsInput>
  }

  export type flightOperateCreateWithoutBookingFlightsInput = {
    flightId: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
    aircraft: aircraftCreateNestedOneWithoutFlightOperateInput
    flight: flightCreateNestedOneWithoutFlightOperatesInput
    tickets?: ticketCreateNestedManyWithoutFlightInput
  }

  export type flightOperateUncheckedCreateWithoutBookingFlightsInput = {
    flightId: string
    flightNum: string
    airlineCode: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
    aircraftId: string
    tickets?: ticketUncheckedCreateNestedManyWithoutFlightInput
  }

  export type flightOperateCreateOrConnectWithoutBookingFlightsInput = {
    where: flightOperateWhereUniqueInput
    create: XOR<flightOperateCreateWithoutBookingFlightsInput, flightOperateUncheckedCreateWithoutBookingFlightsInput>
  }

  export type bookingUpsertWithoutBookingFlightsInput = {
    update: XOR<bookingUpdateWithoutBookingFlightsInput, bookingUncheckedUpdateWithoutBookingFlightsInput>
    create: XOR<bookingCreateWithoutBookingFlightsInput, bookingUncheckedCreateWithoutBookingFlightsInput>
    where?: bookingWhereInput
  }

  export type bookingUpdateToOneWithWhereWithoutBookingFlightsInput = {
    where?: bookingWhereInput
    data: XOR<bookingUpdateWithoutBookingFlightsInput, bookingUncheckedUpdateWithoutBookingFlightsInput>
  }

  export type bookingUpdateWithoutBookingFlightsInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    user?: userUpdateOneRequiredWithoutBookingsNestedInput
    passengerBookings?: passenger_bookingUpdateManyWithoutBookingNestedInput
    tickets?: ticketUpdateManyWithoutBookingNestedInput
    payment?: paymentUpdateOneWithoutBookingNestedInput
  }

  export type bookingUncheckedUpdateWithoutBookingFlightsInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    passengerBookings?: passenger_bookingUncheckedUpdateManyWithoutBookingNestedInput
    tickets?: ticketUncheckedUpdateManyWithoutBookingNestedInput
    payment?: paymentUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type flightOperateUpsertWithoutBookingFlightsInput = {
    update: XOR<flightOperateUpdateWithoutBookingFlightsInput, flightOperateUncheckedUpdateWithoutBookingFlightsInput>
    create: XOR<flightOperateCreateWithoutBookingFlightsInput, flightOperateUncheckedCreateWithoutBookingFlightsInput>
    where?: flightOperateWhereInput
  }

  export type flightOperateUpdateToOneWithWhereWithoutBookingFlightsInput = {
    where?: flightOperateWhereInput
    data: XOR<flightOperateUpdateWithoutBookingFlightsInput, flightOperateUncheckedUpdateWithoutBookingFlightsInput>
  }

  export type flightOperateUpdateWithoutBookingFlightsInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
    aircraft?: aircraftUpdateOneRequiredWithoutFlightOperateNestedInput
    flight?: flightUpdateOneRequiredWithoutFlightOperatesNestedInput
    tickets?: ticketUpdateManyWithoutFlightNestedInput
  }

  export type flightOperateUncheckedUpdateWithoutBookingFlightsInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    tickets?: ticketUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type airlineCreateWithoutFlightInput = {
    airlineCode: string
    airlineName: string
    aircraft?: aircraftCreateNestedManyWithoutAirlineInput
    aircraftCost?: aircraftCostCreateNestedManyWithoutAirlineInput
  }

  export type airlineUncheckedCreateWithoutFlightInput = {
    airlineCode: string
    airlineName: string
    aircraft?: aircraftUncheckedCreateNestedManyWithoutAirlineInput
    aircraftCost?: aircraftCostUncheckedCreateNestedManyWithoutAirlineInput
  }

  export type airlineCreateOrConnectWithoutFlightInput = {
    where: airlineWhereUniqueInput
    create: XOR<airlineCreateWithoutFlightInput, airlineUncheckedCreateWithoutFlightInput>
  }

  export type airportCreateWithoutDepartFlightsInput = {
    airportCode: string
    name: string
    country: string
    city: string
    timezone: string
    latitude?: number | null
    longitude?: number | null
    altitude?: number | null
    arriveFlights?: flightCreateNestedManyWithoutArriveAirportInput
  }

  export type airportUncheckedCreateWithoutDepartFlightsInput = {
    airportCode: string
    name: string
    country: string
    city: string
    timezone: string
    latitude?: number | null
    longitude?: number | null
    altitude?: number | null
    arriveFlights?: flightUncheckedCreateNestedManyWithoutArriveAirportInput
  }

  export type airportCreateOrConnectWithoutDepartFlightsInput = {
    where: airportWhereUniqueInput
    create: XOR<airportCreateWithoutDepartFlightsInput, airportUncheckedCreateWithoutDepartFlightsInput>
  }

  export type airportCreateWithoutArriveFlightsInput = {
    airportCode: string
    name: string
    country: string
    city: string
    timezone: string
    latitude?: number | null
    longitude?: number | null
    altitude?: number | null
    departFlights?: flightCreateNestedManyWithoutDepartAirportInput
  }

  export type airportUncheckedCreateWithoutArriveFlightsInput = {
    airportCode: string
    name: string
    country: string
    city: string
    timezone: string
    latitude?: number | null
    longitude?: number | null
    altitude?: number | null
    departFlights?: flightUncheckedCreateNestedManyWithoutDepartAirportInput
  }

  export type airportCreateOrConnectWithoutArriveFlightsInput = {
    where: airportWhereUniqueInput
    create: XOR<airportCreateWithoutArriveFlightsInput, airportUncheckedCreateWithoutArriveFlightsInput>
  }

  export type flightOperateCreateWithoutFlightInput = {
    flightId: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
    aircraft: aircraftCreateNestedOneWithoutFlightOperateInput
    bookingFlights?: booking_flightCreateNestedManyWithoutFlightInput
    tickets?: ticketCreateNestedManyWithoutFlightInput
  }

  export type flightOperateUncheckedCreateWithoutFlightInput = {
    flightId: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
    aircraftId: string
    bookingFlights?: booking_flightUncheckedCreateNestedManyWithoutFlightInput
    tickets?: ticketUncheckedCreateNestedManyWithoutFlightInput
  }

  export type flightOperateCreateOrConnectWithoutFlightInput = {
    where: flightOperateWhereUniqueInput
    create: XOR<flightOperateCreateWithoutFlightInput, flightOperateUncheckedCreateWithoutFlightInput>
  }

  export type flightOperateCreateManyFlightInputEnvelope = {
    data: flightOperateCreateManyFlightInput | flightOperateCreateManyFlightInput[]
    skipDuplicates?: boolean
  }

  export type transitCreateWithoutFromInput = {
    to: flightCreateNestedOneWithoutTransitToInput
  }

  export type transitUncheckedCreateWithoutFromInput = {
    flightNumTo: string
    airlineCodeTo: string
  }

  export type transitCreateOrConnectWithoutFromInput = {
    where: transitWhereUniqueInput
    create: XOR<transitCreateWithoutFromInput, transitUncheckedCreateWithoutFromInput>
  }

  export type transitCreateManyFromInputEnvelope = {
    data: transitCreateManyFromInput | transitCreateManyFromInput[]
    skipDuplicates?: boolean
  }

  export type transitCreateWithoutToInput = {
    from: flightCreateNestedOneWithoutTransitFromInput
  }

  export type transitUncheckedCreateWithoutToInput = {
    flightNumFrom: string
    airlineCodeFrom: string
  }

  export type transitCreateOrConnectWithoutToInput = {
    where: transitWhereUniqueInput
    create: XOR<transitCreateWithoutToInput, transitUncheckedCreateWithoutToInput>
  }

  export type transitCreateManyToInputEnvelope = {
    data: transitCreateManyToInput | transitCreateManyToInput[]
    skipDuplicates?: boolean
  }

  export type airlineUpsertWithoutFlightInput = {
    update: XOR<airlineUpdateWithoutFlightInput, airlineUncheckedUpdateWithoutFlightInput>
    create: XOR<airlineCreateWithoutFlightInput, airlineUncheckedCreateWithoutFlightInput>
    where?: airlineWhereInput
  }

  export type airlineUpdateToOneWithWhereWithoutFlightInput = {
    where?: airlineWhereInput
    data: XOR<airlineUpdateWithoutFlightInput, airlineUncheckedUpdateWithoutFlightInput>
  }

  export type airlineUpdateWithoutFlightInput = {
    airlineCode?: StringFieldUpdateOperationsInput | string
    airlineName?: StringFieldUpdateOperationsInput | string
    aircraft?: aircraftUpdateManyWithoutAirlineNestedInput
    aircraftCost?: aircraftCostUpdateManyWithoutAirlineNestedInput
  }

  export type airlineUncheckedUpdateWithoutFlightInput = {
    airlineCode?: StringFieldUpdateOperationsInput | string
    airlineName?: StringFieldUpdateOperationsInput | string
    aircraft?: aircraftUncheckedUpdateManyWithoutAirlineNestedInput
    aircraftCost?: aircraftCostUncheckedUpdateManyWithoutAirlineNestedInput
  }

  export type airportUpsertWithoutDepartFlightsInput = {
    update: XOR<airportUpdateWithoutDepartFlightsInput, airportUncheckedUpdateWithoutDepartFlightsInput>
    create: XOR<airportCreateWithoutDepartFlightsInput, airportUncheckedCreateWithoutDepartFlightsInput>
    where?: airportWhereInput
  }

  export type airportUpdateToOneWithWhereWithoutDepartFlightsInput = {
    where?: airportWhereInput
    data: XOR<airportUpdateWithoutDepartFlightsInput, airportUncheckedUpdateWithoutDepartFlightsInput>
  }

  export type airportUpdateWithoutDepartFlightsInput = {
    airportCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableIntFieldUpdateOperationsInput | number | null
    arriveFlights?: flightUpdateManyWithoutArriveAirportNestedInput
  }

  export type airportUncheckedUpdateWithoutDepartFlightsInput = {
    airportCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableIntFieldUpdateOperationsInput | number | null
    arriveFlights?: flightUncheckedUpdateManyWithoutArriveAirportNestedInput
  }

  export type airportUpsertWithoutArriveFlightsInput = {
    update: XOR<airportUpdateWithoutArriveFlightsInput, airportUncheckedUpdateWithoutArriveFlightsInput>
    create: XOR<airportCreateWithoutArriveFlightsInput, airportUncheckedCreateWithoutArriveFlightsInput>
    where?: airportWhereInput
  }

  export type airportUpdateToOneWithWhereWithoutArriveFlightsInput = {
    where?: airportWhereInput
    data: XOR<airportUpdateWithoutArriveFlightsInput, airportUncheckedUpdateWithoutArriveFlightsInput>
  }

  export type airportUpdateWithoutArriveFlightsInput = {
    airportCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableIntFieldUpdateOperationsInput | number | null
    departFlights?: flightUpdateManyWithoutDepartAirportNestedInput
  }

  export type airportUncheckedUpdateWithoutArriveFlightsInput = {
    airportCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableIntFieldUpdateOperationsInput | number | null
    departFlights?: flightUncheckedUpdateManyWithoutDepartAirportNestedInput
  }

  export type flightOperateUpsertWithWhereUniqueWithoutFlightInput = {
    where: flightOperateWhereUniqueInput
    update: XOR<flightOperateUpdateWithoutFlightInput, flightOperateUncheckedUpdateWithoutFlightInput>
    create: XOR<flightOperateCreateWithoutFlightInput, flightOperateUncheckedCreateWithoutFlightInput>
  }

  export type flightOperateUpdateWithWhereUniqueWithoutFlightInput = {
    where: flightOperateWhereUniqueInput
    data: XOR<flightOperateUpdateWithoutFlightInput, flightOperateUncheckedUpdateWithoutFlightInput>
  }

  export type flightOperateUpdateManyWithWhereWithoutFlightInput = {
    where: flightOperateScalarWhereInput
    data: XOR<flightOperateUpdateManyMutationInput, flightOperateUncheckedUpdateManyWithoutFlightInput>
  }

  export type transitUpsertWithWhereUniqueWithoutFromInput = {
    where: transitWhereUniqueInput
    update: XOR<transitUpdateWithoutFromInput, transitUncheckedUpdateWithoutFromInput>
    create: XOR<transitCreateWithoutFromInput, transitUncheckedCreateWithoutFromInput>
  }

  export type transitUpdateWithWhereUniqueWithoutFromInput = {
    where: transitWhereUniqueInput
    data: XOR<transitUpdateWithoutFromInput, transitUncheckedUpdateWithoutFromInput>
  }

  export type transitUpdateManyWithWhereWithoutFromInput = {
    where: transitScalarWhereInput
    data: XOR<transitUpdateManyMutationInput, transitUncheckedUpdateManyWithoutFromInput>
  }

  export type transitScalarWhereInput = {
    AND?: transitScalarWhereInput | transitScalarWhereInput[]
    OR?: transitScalarWhereInput[]
    NOT?: transitScalarWhereInput | transitScalarWhereInput[]
    flightNumFrom?: StringFilter<"transit"> | string
    airlineCodeFrom?: StringFilter<"transit"> | string
    flightNumTo?: StringFilter<"transit"> | string
    airlineCodeTo?: StringFilter<"transit"> | string
  }

  export type transitUpsertWithWhereUniqueWithoutToInput = {
    where: transitWhereUniqueInput
    update: XOR<transitUpdateWithoutToInput, transitUncheckedUpdateWithoutToInput>
    create: XOR<transitCreateWithoutToInput, transitUncheckedCreateWithoutToInput>
  }

  export type transitUpdateWithWhereUniqueWithoutToInput = {
    where: transitWhereUniqueInput
    data: XOR<transitUpdateWithoutToInput, transitUncheckedUpdateWithoutToInput>
  }

  export type transitUpdateManyWithWhereWithoutToInput = {
    where: transitScalarWhereInput
    data: XOR<transitUpdateManyMutationInput, transitUncheckedUpdateManyWithoutToInput>
  }

  export type aircraftCreateWithoutFlightOperateInput = {
    aircraftId: string
    model: string
    airline: airlineCreateNestedOneWithoutAircraftInput
    aircraftSeatmap?: aircraft_seatmapCreateNestedManyWithoutAircraftInput
  }

  export type aircraftUncheckedCreateWithoutFlightOperateInput = {
    aircraftId: string
    ownerAirlineCode: string
    model: string
    aircraftSeatmap?: aircraft_seatmapUncheckedCreateNestedManyWithoutAircraftInput
  }

  export type aircraftCreateOrConnectWithoutFlightOperateInput = {
    where: aircraftWhereUniqueInput
    create: XOR<aircraftCreateWithoutFlightOperateInput, aircraftUncheckedCreateWithoutFlightOperateInput>
  }

  export type flightCreateWithoutFlightOperatesInput = {
    flightNum: string
    airline: airlineCreateNestedOneWithoutFlightInput
    departAirport: airportCreateNestedOneWithoutDepartFlightsInput
    arriveAirport: airportCreateNestedOneWithoutArriveFlightsInput
    transitFrom?: transitCreateNestedManyWithoutFromInput
    transitTo?: transitCreateNestedManyWithoutToInput
  }

  export type flightUncheckedCreateWithoutFlightOperatesInput = {
    flightNum: string
    airlineCode: string
    departAirportId: string
    arriveAirportId: string
    transitFrom?: transitUncheckedCreateNestedManyWithoutFromInput
    transitTo?: transitUncheckedCreateNestedManyWithoutToInput
  }

  export type flightCreateOrConnectWithoutFlightOperatesInput = {
    where: flightWhereUniqueInput
    create: XOR<flightCreateWithoutFlightOperatesInput, flightUncheckedCreateWithoutFlightOperatesInput>
  }

  export type booking_flightCreateWithoutFlightInput = {
    booking: bookingCreateNestedOneWithoutBookingFlightsInput
  }

  export type booking_flightUncheckedCreateWithoutFlightInput = {
    bookingId: string
  }

  export type booking_flightCreateOrConnectWithoutFlightInput = {
    where: booking_flightWhereUniqueInput
    create: XOR<booking_flightCreateWithoutFlightInput, booking_flightUncheckedCreateWithoutFlightInput>
  }

  export type booking_flightCreateManyFlightInputEnvelope = {
    data: booking_flightCreateManyFlightInput | booking_flightCreateManyFlightInput[]
    skipDuplicates?: boolean
  }

  export type ticketCreateWithoutFlightInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    booking: bookingCreateNestedOneWithoutTicketsInput
    passenger: passengerCreateNestedOneWithoutTicketsInput
    seat: seatCreateNestedOneWithoutTicketsInput
  }

  export type ticketUncheckedCreateWithoutFlightInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    bookingId: string
    passportNum: string
    seatNum: string
  }

  export type ticketCreateOrConnectWithoutFlightInput = {
    where: ticketWhereUniqueInput
    create: XOR<ticketCreateWithoutFlightInput, ticketUncheckedCreateWithoutFlightInput>
  }

  export type ticketCreateManyFlightInputEnvelope = {
    data: ticketCreateManyFlightInput | ticketCreateManyFlightInput[]
    skipDuplicates?: boolean
  }

  export type aircraftUpsertWithoutFlightOperateInput = {
    update: XOR<aircraftUpdateWithoutFlightOperateInput, aircraftUncheckedUpdateWithoutFlightOperateInput>
    create: XOR<aircraftCreateWithoutFlightOperateInput, aircraftUncheckedCreateWithoutFlightOperateInput>
    where?: aircraftWhereInput
  }

  export type aircraftUpdateToOneWithWhereWithoutFlightOperateInput = {
    where?: aircraftWhereInput
    data: XOR<aircraftUpdateWithoutFlightOperateInput, aircraftUncheckedUpdateWithoutFlightOperateInput>
  }

  export type aircraftUpdateWithoutFlightOperateInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    airline?: airlineUpdateOneRequiredWithoutAircraftNestedInput
    aircraftSeatmap?: aircraft_seatmapUpdateManyWithoutAircraftNestedInput
  }

  export type aircraftUncheckedUpdateWithoutFlightOperateInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    ownerAirlineCode?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    aircraftSeatmap?: aircraft_seatmapUncheckedUpdateManyWithoutAircraftNestedInput
  }

  export type flightUpsertWithoutFlightOperatesInput = {
    update: XOR<flightUpdateWithoutFlightOperatesInput, flightUncheckedUpdateWithoutFlightOperatesInput>
    create: XOR<flightCreateWithoutFlightOperatesInput, flightUncheckedCreateWithoutFlightOperatesInput>
    where?: flightWhereInput
  }

  export type flightUpdateToOneWithWhereWithoutFlightOperatesInput = {
    where?: flightWhereInput
    data: XOR<flightUpdateWithoutFlightOperatesInput, flightUncheckedUpdateWithoutFlightOperatesInput>
  }

  export type flightUpdateWithoutFlightOperatesInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airline?: airlineUpdateOneRequiredWithoutFlightNestedInput
    departAirport?: airportUpdateOneRequiredWithoutDepartFlightsNestedInput
    arriveAirport?: airportUpdateOneRequiredWithoutArriveFlightsNestedInput
    transitFrom?: transitUpdateManyWithoutFromNestedInput
    transitTo?: transitUpdateManyWithoutToNestedInput
  }

  export type flightUncheckedUpdateWithoutFlightOperatesInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departAirportId?: StringFieldUpdateOperationsInput | string
    arriveAirportId?: StringFieldUpdateOperationsInput | string
    transitFrom?: transitUncheckedUpdateManyWithoutFromNestedInput
    transitTo?: transitUncheckedUpdateManyWithoutToNestedInput
  }

  export type booking_flightUpsertWithWhereUniqueWithoutFlightInput = {
    where: booking_flightWhereUniqueInput
    update: XOR<booking_flightUpdateWithoutFlightInput, booking_flightUncheckedUpdateWithoutFlightInput>
    create: XOR<booking_flightCreateWithoutFlightInput, booking_flightUncheckedCreateWithoutFlightInput>
  }

  export type booking_flightUpdateWithWhereUniqueWithoutFlightInput = {
    where: booking_flightWhereUniqueInput
    data: XOR<booking_flightUpdateWithoutFlightInput, booking_flightUncheckedUpdateWithoutFlightInput>
  }

  export type booking_flightUpdateManyWithWhereWithoutFlightInput = {
    where: booking_flightScalarWhereInput
    data: XOR<booking_flightUpdateManyMutationInput, booking_flightUncheckedUpdateManyWithoutFlightInput>
  }

  export type ticketUpsertWithWhereUniqueWithoutFlightInput = {
    where: ticketWhereUniqueInput
    update: XOR<ticketUpdateWithoutFlightInput, ticketUncheckedUpdateWithoutFlightInput>
    create: XOR<ticketCreateWithoutFlightInput, ticketUncheckedCreateWithoutFlightInput>
  }

  export type ticketUpdateWithWhereUniqueWithoutFlightInput = {
    where: ticketWhereUniqueInput
    data: XOR<ticketUpdateWithoutFlightInput, ticketUncheckedUpdateWithoutFlightInput>
  }

  export type ticketUpdateManyWithWhereWithoutFlightInput = {
    where: ticketScalarWhereInput
    data: XOR<ticketUpdateManyMutationInput, ticketUncheckedUpdateManyWithoutFlightInput>
  }

  export type userCreateWithoutPassengersInput = {
    uuid?: string
    password: string
    firstname: string
    lastname: string
    email: string
    phone: string
    registerDate?: Date | string
    bookings?: bookingCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPassengersInput = {
    uuid?: string
    password: string
    firstname: string
    lastname: string
    email: string
    phone: string
    registerDate?: Date | string
    bookings?: bookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPassengersInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPassengersInput, userUncheckedCreateWithoutPassengersInput>
  }

  export type passenger_bookingCreateWithoutPassengerInput = {
    booking: bookingCreateNestedOneWithoutPassengerBookingsInput
  }

  export type passenger_bookingUncheckedCreateWithoutPassengerInput = {
    bookingId: string
  }

  export type passenger_bookingCreateOrConnectWithoutPassengerInput = {
    where: passenger_bookingWhereUniqueInput
    create: XOR<passenger_bookingCreateWithoutPassengerInput, passenger_bookingUncheckedCreateWithoutPassengerInput>
  }

  export type passenger_bookingCreateManyPassengerInputEnvelope = {
    data: passenger_bookingCreateManyPassengerInput | passenger_bookingCreateManyPassengerInput[]
    skipDuplicates?: boolean
  }

  export type ticketCreateWithoutPassengerInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    booking: bookingCreateNestedOneWithoutTicketsInput
    flight: flightOperateCreateNestedOneWithoutTicketsInput
    seat: seatCreateNestedOneWithoutTicketsInput
  }

  export type ticketUncheckedCreateWithoutPassengerInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    bookingId: string
    flightId: string
    seatNum: string
  }

  export type ticketCreateOrConnectWithoutPassengerInput = {
    where: ticketWhereUniqueInput
    create: XOR<ticketCreateWithoutPassengerInput, ticketUncheckedCreateWithoutPassengerInput>
  }

  export type ticketCreateManyPassengerInputEnvelope = {
    data: ticketCreateManyPassengerInput | ticketCreateManyPassengerInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutPassengersInput = {
    update: XOR<userUpdateWithoutPassengersInput, userUncheckedUpdateWithoutPassengersInput>
    create: XOR<userCreateWithoutPassengersInput, userUncheckedCreateWithoutPassengersInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPassengersInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPassengersInput, userUncheckedUpdateWithoutPassengersInput>
  }

  export type userUpdateWithoutPassengersInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    registerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPassengersInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    registerDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type passenger_bookingUpsertWithWhereUniqueWithoutPassengerInput = {
    where: passenger_bookingWhereUniqueInput
    update: XOR<passenger_bookingUpdateWithoutPassengerInput, passenger_bookingUncheckedUpdateWithoutPassengerInput>
    create: XOR<passenger_bookingCreateWithoutPassengerInput, passenger_bookingUncheckedCreateWithoutPassengerInput>
  }

  export type passenger_bookingUpdateWithWhereUniqueWithoutPassengerInput = {
    where: passenger_bookingWhereUniqueInput
    data: XOR<passenger_bookingUpdateWithoutPassengerInput, passenger_bookingUncheckedUpdateWithoutPassengerInput>
  }

  export type passenger_bookingUpdateManyWithWhereWithoutPassengerInput = {
    where: passenger_bookingScalarWhereInput
    data: XOR<passenger_bookingUpdateManyMutationInput, passenger_bookingUncheckedUpdateManyWithoutPassengerInput>
  }

  export type ticketUpsertWithWhereUniqueWithoutPassengerInput = {
    where: ticketWhereUniqueInput
    update: XOR<ticketUpdateWithoutPassengerInput, ticketUncheckedUpdateWithoutPassengerInput>
    create: XOR<ticketCreateWithoutPassengerInput, ticketUncheckedCreateWithoutPassengerInput>
  }

  export type ticketUpdateWithWhereUniqueWithoutPassengerInput = {
    where: ticketWhereUniqueInput
    data: XOR<ticketUpdateWithoutPassengerInput, ticketUncheckedUpdateWithoutPassengerInput>
  }

  export type ticketUpdateManyWithWhereWithoutPassengerInput = {
    where: ticketScalarWhereInput
    data: XOR<ticketUpdateManyMutationInput, ticketUncheckedUpdateManyWithoutPassengerInput>
  }

  export type bookingCreateWithoutPassengerBookingsInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    user: userCreateNestedOneWithoutBookingsInput
    bookingFlights?: booking_flightCreateNestedManyWithoutBookingInput
    tickets?: ticketCreateNestedManyWithoutBookingInput
    payment?: paymentCreateNestedOneWithoutBookingInput
  }

  export type bookingUncheckedCreateWithoutPassengerBookingsInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    userId: string
    bookingFlights?: booking_flightUncheckedCreateNestedManyWithoutBookingInput
    tickets?: ticketUncheckedCreateNestedManyWithoutBookingInput
    payment?: paymentUncheckedCreateNestedOneWithoutBookingInput
  }

  export type bookingCreateOrConnectWithoutPassengerBookingsInput = {
    where: bookingWhereUniqueInput
    create: XOR<bookingCreateWithoutPassengerBookingsInput, bookingUncheckedCreateWithoutPassengerBookingsInput>
  }

  export type passengerCreateWithoutPassengerBookingsInput = {
    passportNum: string
    passportCountry: string
    passportExpiry: Date | string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    ageRange: $Enums.AgeRange
    user: userCreateNestedOneWithoutPassengersInput
    tickets?: ticketCreateNestedManyWithoutPassengerInput
  }

  export type passengerUncheckedCreateWithoutPassengerBookingsInput = {
    passportNum: string
    passportCountry: string
    passportExpiry: Date | string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    ageRange: $Enums.AgeRange
    userId: string
    tickets?: ticketUncheckedCreateNestedManyWithoutPassengerInput
  }

  export type passengerCreateOrConnectWithoutPassengerBookingsInput = {
    where: passengerWhereUniqueInput
    create: XOR<passengerCreateWithoutPassengerBookingsInput, passengerUncheckedCreateWithoutPassengerBookingsInput>
  }

  export type bookingUpsertWithoutPassengerBookingsInput = {
    update: XOR<bookingUpdateWithoutPassengerBookingsInput, bookingUncheckedUpdateWithoutPassengerBookingsInput>
    create: XOR<bookingCreateWithoutPassengerBookingsInput, bookingUncheckedCreateWithoutPassengerBookingsInput>
    where?: bookingWhereInput
  }

  export type bookingUpdateToOneWithWhereWithoutPassengerBookingsInput = {
    where?: bookingWhereInput
    data: XOR<bookingUpdateWithoutPassengerBookingsInput, bookingUncheckedUpdateWithoutPassengerBookingsInput>
  }

  export type bookingUpdateWithoutPassengerBookingsInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    user?: userUpdateOneRequiredWithoutBookingsNestedInput
    bookingFlights?: booking_flightUpdateManyWithoutBookingNestedInput
    tickets?: ticketUpdateManyWithoutBookingNestedInput
    payment?: paymentUpdateOneWithoutBookingNestedInput
  }

  export type bookingUncheckedUpdateWithoutPassengerBookingsInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    bookingFlights?: booking_flightUncheckedUpdateManyWithoutBookingNestedInput
    tickets?: ticketUncheckedUpdateManyWithoutBookingNestedInput
    payment?: paymentUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type passengerUpsertWithoutPassengerBookingsInput = {
    update: XOR<passengerUpdateWithoutPassengerBookingsInput, passengerUncheckedUpdateWithoutPassengerBookingsInput>
    create: XOR<passengerCreateWithoutPassengerBookingsInput, passengerUncheckedCreateWithoutPassengerBookingsInput>
    where?: passengerWhereInput
  }

  export type passengerUpdateToOneWithWhereWithoutPassengerBookingsInput = {
    where?: passengerWhereInput
    data: XOR<passengerUpdateWithoutPassengerBookingsInput, passengerUncheckedUpdateWithoutPassengerBookingsInput>
  }

  export type passengerUpdateWithoutPassengerBookingsInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
    passportCountry?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    ageRange?: EnumAgeRangeFieldUpdateOperationsInput | $Enums.AgeRange
    user?: userUpdateOneRequiredWithoutPassengersNestedInput
    tickets?: ticketUpdateManyWithoutPassengerNestedInput
  }

  export type passengerUncheckedUpdateWithoutPassengerBookingsInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
    passportCountry?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    ageRange?: EnumAgeRangeFieldUpdateOperationsInput | $Enums.AgeRange
    userId?: StringFieldUpdateOperationsInput | string
    tickets?: ticketUncheckedUpdateManyWithoutPassengerNestedInput
  }

  export type bookingCreateWithoutPaymentInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    user: userCreateNestedOneWithoutBookingsInput
    bookingFlights?: booking_flightCreateNestedManyWithoutBookingInput
    passengerBookings?: passenger_bookingCreateNestedManyWithoutBookingInput
    tickets?: ticketCreateNestedManyWithoutBookingInput
  }

  export type bookingUncheckedCreateWithoutPaymentInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    userId: string
    bookingFlights?: booking_flightUncheckedCreateNestedManyWithoutBookingInput
    passengerBookings?: passenger_bookingUncheckedCreateNestedManyWithoutBookingInput
    tickets?: ticketUncheckedCreateNestedManyWithoutBookingInput
  }

  export type bookingCreateOrConnectWithoutPaymentInput = {
    where: bookingWhereUniqueInput
    create: XOR<bookingCreateWithoutPaymentInput, bookingUncheckedCreateWithoutPaymentInput>
  }

  export type bookingUpsertWithoutPaymentInput = {
    update: XOR<bookingUpdateWithoutPaymentInput, bookingUncheckedUpdateWithoutPaymentInput>
    create: XOR<bookingCreateWithoutPaymentInput, bookingUncheckedCreateWithoutPaymentInput>
    where?: bookingWhereInput
  }

  export type bookingUpdateToOneWithWhereWithoutPaymentInput = {
    where?: bookingWhereInput
    data: XOR<bookingUpdateWithoutPaymentInput, bookingUncheckedUpdateWithoutPaymentInput>
  }

  export type bookingUpdateWithoutPaymentInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    user?: userUpdateOneRequiredWithoutBookingsNestedInput
    bookingFlights?: booking_flightUpdateManyWithoutBookingNestedInput
    passengerBookings?: passenger_bookingUpdateManyWithoutBookingNestedInput
    tickets?: ticketUpdateManyWithoutBookingNestedInput
  }

  export type bookingUncheckedUpdateWithoutPaymentInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    bookingFlights?: booking_flightUncheckedUpdateManyWithoutBookingNestedInput
    passengerBookings?: passenger_bookingUncheckedUpdateManyWithoutBookingNestedInput
    tickets?: ticketUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type aircraftCreateWithoutAircraftSeatmapInput = {
    aircraftId: string
    model: string
    airline: airlineCreateNestedOneWithoutAircraftInput
    flightOperate?: flightOperateCreateNestedManyWithoutAircraftInput
  }

  export type aircraftUncheckedCreateWithoutAircraftSeatmapInput = {
    aircraftId: string
    ownerAirlineCode: string
    model: string
    flightOperate?: flightOperateUncheckedCreateNestedManyWithoutAircraftInput
  }

  export type aircraftCreateOrConnectWithoutAircraftSeatmapInput = {
    where: aircraftWhereUniqueInput
    create: XOR<aircraftCreateWithoutAircraftSeatmapInput, aircraftUncheckedCreateWithoutAircraftSeatmapInput>
  }

  export type seatmap_infoCreateWithoutAircraftInput = {
    seatMapId: string
    airlineCode: string
    aircraftModel: string
    version: string
    seat?: seatCreateNestedManyWithoutSeatmapInput
  }

  export type seatmap_infoUncheckedCreateWithoutAircraftInput = {
    seatMapId: string
    airlineCode: string
    aircraftModel: string
    version: string
    seat?: seatUncheckedCreateNestedManyWithoutSeatmapInput
  }

  export type seatmap_infoCreateOrConnectWithoutAircraftInput = {
    where: seatmap_infoWhereUniqueInput
    create: XOR<seatmap_infoCreateWithoutAircraftInput, seatmap_infoUncheckedCreateWithoutAircraftInput>
  }

  export type aircraftUpsertWithoutAircraftSeatmapInput = {
    update: XOR<aircraftUpdateWithoutAircraftSeatmapInput, aircraftUncheckedUpdateWithoutAircraftSeatmapInput>
    create: XOR<aircraftCreateWithoutAircraftSeatmapInput, aircraftUncheckedCreateWithoutAircraftSeatmapInput>
    where?: aircraftWhereInput
  }

  export type aircraftUpdateToOneWithWhereWithoutAircraftSeatmapInput = {
    where?: aircraftWhereInput
    data: XOR<aircraftUpdateWithoutAircraftSeatmapInput, aircraftUncheckedUpdateWithoutAircraftSeatmapInput>
  }

  export type aircraftUpdateWithoutAircraftSeatmapInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    airline?: airlineUpdateOneRequiredWithoutAircraftNestedInput
    flightOperate?: flightOperateUpdateManyWithoutAircraftNestedInput
  }

  export type aircraftUncheckedUpdateWithoutAircraftSeatmapInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    ownerAirlineCode?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    flightOperate?: flightOperateUncheckedUpdateManyWithoutAircraftNestedInput
  }

  export type seatmap_infoUpsertWithoutAircraftInput = {
    update: XOR<seatmap_infoUpdateWithoutAircraftInput, seatmap_infoUncheckedUpdateWithoutAircraftInput>
    create: XOR<seatmap_infoCreateWithoutAircraftInput, seatmap_infoUncheckedCreateWithoutAircraftInput>
    where?: seatmap_infoWhereInput
  }

  export type seatmap_infoUpdateToOneWithWhereWithoutAircraftInput = {
    where?: seatmap_infoWhereInput
    data: XOR<seatmap_infoUpdateWithoutAircraftInput, seatmap_infoUncheckedUpdateWithoutAircraftInput>
  }

  export type seatmap_infoUpdateWithoutAircraftInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    aircraftModel?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    seat?: seatUpdateManyWithoutSeatmapNestedInput
  }

  export type seatmap_infoUncheckedUpdateWithoutAircraftInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    aircraftModel?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    seat?: seatUncheckedUpdateManyWithoutSeatmapNestedInput
  }

  export type seatCreateWithoutSeatmapInput = {
    seatId: string
    seatNum: string
    row?: number
    class?: $Enums.SeatClass
    price?: number
    features: string
    floor?: number
    tickets?: ticketCreateNestedManyWithoutSeatInput
  }

  export type seatUncheckedCreateWithoutSeatmapInput = {
    seatId: string
    seatNum: string
    row?: number
    class?: $Enums.SeatClass
    price?: number
    features: string
    floor?: number
    tickets?: ticketUncheckedCreateNestedManyWithoutSeatInput
  }

  export type seatCreateOrConnectWithoutSeatmapInput = {
    where: seatWhereUniqueInput
    create: XOR<seatCreateWithoutSeatmapInput, seatUncheckedCreateWithoutSeatmapInput>
  }

  export type seatCreateManySeatmapInputEnvelope = {
    data: seatCreateManySeatmapInput | seatCreateManySeatmapInput[]
    skipDuplicates?: boolean
  }

  export type aircraft_seatmapCreateWithoutSeatmapInput = {
    aircraft: aircraftCreateNestedOneWithoutAircraftSeatmapInput
  }

  export type aircraft_seatmapUncheckedCreateWithoutSeatmapInput = {
    aircraftId: string
  }

  export type aircraft_seatmapCreateOrConnectWithoutSeatmapInput = {
    where: aircraft_seatmapWhereUniqueInput
    create: XOR<aircraft_seatmapCreateWithoutSeatmapInput, aircraft_seatmapUncheckedCreateWithoutSeatmapInput>
  }

  export type aircraft_seatmapCreateManySeatmapInputEnvelope = {
    data: aircraft_seatmapCreateManySeatmapInput | aircraft_seatmapCreateManySeatmapInput[]
    skipDuplicates?: boolean
  }

  export type seatUpsertWithWhereUniqueWithoutSeatmapInput = {
    where: seatWhereUniqueInput
    update: XOR<seatUpdateWithoutSeatmapInput, seatUncheckedUpdateWithoutSeatmapInput>
    create: XOR<seatCreateWithoutSeatmapInput, seatUncheckedCreateWithoutSeatmapInput>
  }

  export type seatUpdateWithWhereUniqueWithoutSeatmapInput = {
    where: seatWhereUniqueInput
    data: XOR<seatUpdateWithoutSeatmapInput, seatUncheckedUpdateWithoutSeatmapInput>
  }

  export type seatUpdateManyWithWhereWithoutSeatmapInput = {
    where: seatScalarWhereInput
    data: XOR<seatUpdateManyMutationInput, seatUncheckedUpdateManyWithoutSeatmapInput>
  }

  export type seatScalarWhereInput = {
    AND?: seatScalarWhereInput | seatScalarWhereInput[]
    OR?: seatScalarWhereInput[]
    NOT?: seatScalarWhereInput | seatScalarWhereInput[]
    seatMapId?: StringFilter<"seat"> | string
    seatId?: StringFilter<"seat"> | string
    seatNum?: StringFilter<"seat"> | string
    row?: IntFilter<"seat"> | number
    class?: EnumSeatClassFilter<"seat"> | $Enums.SeatClass
    price?: FloatFilter<"seat"> | number
    features?: StringFilter<"seat"> | string
    floor?: IntFilter<"seat"> | number
  }

  export type aircraft_seatmapUpsertWithWhereUniqueWithoutSeatmapInput = {
    where: aircraft_seatmapWhereUniqueInput
    update: XOR<aircraft_seatmapUpdateWithoutSeatmapInput, aircraft_seatmapUncheckedUpdateWithoutSeatmapInput>
    create: XOR<aircraft_seatmapCreateWithoutSeatmapInput, aircraft_seatmapUncheckedCreateWithoutSeatmapInput>
  }

  export type aircraft_seatmapUpdateWithWhereUniqueWithoutSeatmapInput = {
    where: aircraft_seatmapWhereUniqueInput
    data: XOR<aircraft_seatmapUpdateWithoutSeatmapInput, aircraft_seatmapUncheckedUpdateWithoutSeatmapInput>
  }

  export type aircraft_seatmapUpdateManyWithWhereWithoutSeatmapInput = {
    where: aircraft_seatmapScalarWhereInput
    data: XOR<aircraft_seatmapUpdateManyMutationInput, aircraft_seatmapUncheckedUpdateManyWithoutSeatmapInput>
  }

  export type ticketCreateWithoutSeatInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    booking: bookingCreateNestedOneWithoutTicketsInput
    passenger: passengerCreateNestedOneWithoutTicketsInput
    flight: flightOperateCreateNestedOneWithoutTicketsInput
  }

  export type ticketUncheckedCreateWithoutSeatInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    bookingId: string
    flightId: string
    passportNum: string
  }

  export type ticketCreateOrConnectWithoutSeatInput = {
    where: ticketWhereUniqueInput
    create: XOR<ticketCreateWithoutSeatInput, ticketUncheckedCreateWithoutSeatInput>
  }

  export type ticketCreateManySeatInputEnvelope = {
    data: ticketCreateManySeatInput | ticketCreateManySeatInput[]
    skipDuplicates?: boolean
  }

  export type seatmap_infoCreateWithoutSeatInput = {
    seatMapId: string
    airlineCode: string
    aircraftModel: string
    version: string
    aircraft?: aircraft_seatmapCreateNestedManyWithoutSeatmapInput
  }

  export type seatmap_infoUncheckedCreateWithoutSeatInput = {
    seatMapId: string
    airlineCode: string
    aircraftModel: string
    version: string
    aircraft?: aircraft_seatmapUncheckedCreateNestedManyWithoutSeatmapInput
  }

  export type seatmap_infoCreateOrConnectWithoutSeatInput = {
    where: seatmap_infoWhereUniqueInput
    create: XOR<seatmap_infoCreateWithoutSeatInput, seatmap_infoUncheckedCreateWithoutSeatInput>
  }

  export type ticketUpsertWithWhereUniqueWithoutSeatInput = {
    where: ticketWhereUniqueInput
    update: XOR<ticketUpdateWithoutSeatInput, ticketUncheckedUpdateWithoutSeatInput>
    create: XOR<ticketCreateWithoutSeatInput, ticketUncheckedCreateWithoutSeatInput>
  }

  export type ticketUpdateWithWhereUniqueWithoutSeatInput = {
    where: ticketWhereUniqueInput
    data: XOR<ticketUpdateWithoutSeatInput, ticketUncheckedUpdateWithoutSeatInput>
  }

  export type ticketUpdateManyWithWhereWithoutSeatInput = {
    where: ticketScalarWhereInput
    data: XOR<ticketUpdateManyMutationInput, ticketUncheckedUpdateManyWithoutSeatInput>
  }

  export type seatmap_infoUpsertWithoutSeatInput = {
    update: XOR<seatmap_infoUpdateWithoutSeatInput, seatmap_infoUncheckedUpdateWithoutSeatInput>
    create: XOR<seatmap_infoCreateWithoutSeatInput, seatmap_infoUncheckedCreateWithoutSeatInput>
    where?: seatmap_infoWhereInput
  }

  export type seatmap_infoUpdateToOneWithWhereWithoutSeatInput = {
    where?: seatmap_infoWhereInput
    data: XOR<seatmap_infoUpdateWithoutSeatInput, seatmap_infoUncheckedUpdateWithoutSeatInput>
  }

  export type seatmap_infoUpdateWithoutSeatInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    aircraftModel?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    aircraft?: aircraft_seatmapUpdateManyWithoutSeatmapNestedInput
  }

  export type seatmap_infoUncheckedUpdateWithoutSeatInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    aircraftModel?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    aircraft?: aircraft_seatmapUncheckedUpdateManyWithoutSeatmapNestedInput
  }

  export type bookingCreateWithoutTicketsInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    user: userCreateNestedOneWithoutBookingsInput
    bookingFlights?: booking_flightCreateNestedManyWithoutBookingInput
    passengerBookings?: passenger_bookingCreateNestedManyWithoutBookingInput
    payment?: paymentCreateNestedOneWithoutBookingInput
  }

  export type bookingUncheckedCreateWithoutTicketsInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    userId: string
    bookingFlights?: booking_flightUncheckedCreateNestedManyWithoutBookingInput
    passengerBookings?: passenger_bookingUncheckedCreateNestedManyWithoutBookingInput
    payment?: paymentUncheckedCreateNestedOneWithoutBookingInput
  }

  export type bookingCreateOrConnectWithoutTicketsInput = {
    where: bookingWhereUniqueInput
    create: XOR<bookingCreateWithoutTicketsInput, bookingUncheckedCreateWithoutTicketsInput>
  }

  export type passengerCreateWithoutTicketsInput = {
    passportNum: string
    passportCountry: string
    passportExpiry: Date | string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    ageRange: $Enums.AgeRange
    user: userCreateNestedOneWithoutPassengersInput
    passengerBookings?: passenger_bookingCreateNestedManyWithoutPassengerInput
  }

  export type passengerUncheckedCreateWithoutTicketsInput = {
    passportNum: string
    passportCountry: string
    passportExpiry: Date | string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    ageRange: $Enums.AgeRange
    userId: string
    passengerBookings?: passenger_bookingUncheckedCreateNestedManyWithoutPassengerInput
  }

  export type passengerCreateOrConnectWithoutTicketsInput = {
    where: passengerWhereUniqueInput
    create: XOR<passengerCreateWithoutTicketsInput, passengerUncheckedCreateWithoutTicketsInput>
  }

  export type flightOperateCreateWithoutTicketsInput = {
    flightId: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
    aircraft: aircraftCreateNestedOneWithoutFlightOperateInput
    flight: flightCreateNestedOneWithoutFlightOperatesInput
    bookingFlights?: booking_flightCreateNestedManyWithoutFlightInput
  }

  export type flightOperateUncheckedCreateWithoutTicketsInput = {
    flightId: string
    flightNum: string
    airlineCode: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
    aircraftId: string
    bookingFlights?: booking_flightUncheckedCreateNestedManyWithoutFlightInput
  }

  export type flightOperateCreateOrConnectWithoutTicketsInput = {
    where: flightOperateWhereUniqueInput
    create: XOR<flightOperateCreateWithoutTicketsInput, flightOperateUncheckedCreateWithoutTicketsInput>
  }

  export type seatCreateWithoutTicketsInput = {
    seatId: string
    seatNum: string
    row?: number
    class?: $Enums.SeatClass
    price?: number
    features: string
    floor?: number
    seatmap: seatmap_infoCreateNestedOneWithoutSeatInput
  }

  export type seatUncheckedCreateWithoutTicketsInput = {
    seatMapId: string
    seatId: string
    seatNum: string
    row?: number
    class?: $Enums.SeatClass
    price?: number
    features: string
    floor?: number
  }

  export type seatCreateOrConnectWithoutTicketsInput = {
    where: seatWhereUniqueInput
    create: XOR<seatCreateWithoutTicketsInput, seatUncheckedCreateWithoutTicketsInput>
  }

  export type bookingUpsertWithoutTicketsInput = {
    update: XOR<bookingUpdateWithoutTicketsInput, bookingUncheckedUpdateWithoutTicketsInput>
    create: XOR<bookingCreateWithoutTicketsInput, bookingUncheckedCreateWithoutTicketsInput>
    where?: bookingWhereInput
  }

  export type bookingUpdateToOneWithWhereWithoutTicketsInput = {
    where?: bookingWhereInput
    data: XOR<bookingUpdateWithoutTicketsInput, bookingUncheckedUpdateWithoutTicketsInput>
  }

  export type bookingUpdateWithoutTicketsInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    user?: userUpdateOneRequiredWithoutBookingsNestedInput
    bookingFlights?: booking_flightUpdateManyWithoutBookingNestedInput
    passengerBookings?: passenger_bookingUpdateManyWithoutBookingNestedInput
    payment?: paymentUpdateOneWithoutBookingNestedInput
  }

  export type bookingUncheckedUpdateWithoutTicketsInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    bookingFlights?: booking_flightUncheckedUpdateManyWithoutBookingNestedInput
    passengerBookings?: passenger_bookingUncheckedUpdateManyWithoutBookingNestedInput
    payment?: paymentUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type passengerUpsertWithoutTicketsInput = {
    update: XOR<passengerUpdateWithoutTicketsInput, passengerUncheckedUpdateWithoutTicketsInput>
    create: XOR<passengerCreateWithoutTicketsInput, passengerUncheckedCreateWithoutTicketsInput>
    where?: passengerWhereInput
  }

  export type passengerUpdateToOneWithWhereWithoutTicketsInput = {
    where?: passengerWhereInput
    data: XOR<passengerUpdateWithoutTicketsInput, passengerUncheckedUpdateWithoutTicketsInput>
  }

  export type passengerUpdateWithoutTicketsInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
    passportCountry?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    ageRange?: EnumAgeRangeFieldUpdateOperationsInput | $Enums.AgeRange
    user?: userUpdateOneRequiredWithoutPassengersNestedInput
    passengerBookings?: passenger_bookingUpdateManyWithoutPassengerNestedInput
  }

  export type passengerUncheckedUpdateWithoutTicketsInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
    passportCountry?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    ageRange?: EnumAgeRangeFieldUpdateOperationsInput | $Enums.AgeRange
    userId?: StringFieldUpdateOperationsInput | string
    passengerBookings?: passenger_bookingUncheckedUpdateManyWithoutPassengerNestedInput
  }

  export type flightOperateUpsertWithoutTicketsInput = {
    update: XOR<flightOperateUpdateWithoutTicketsInput, flightOperateUncheckedUpdateWithoutTicketsInput>
    create: XOR<flightOperateCreateWithoutTicketsInput, flightOperateUncheckedCreateWithoutTicketsInput>
    where?: flightOperateWhereInput
  }

  export type flightOperateUpdateToOneWithWhereWithoutTicketsInput = {
    where?: flightOperateWhereInput
    data: XOR<flightOperateUpdateWithoutTicketsInput, flightOperateUncheckedUpdateWithoutTicketsInput>
  }

  export type flightOperateUpdateWithoutTicketsInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
    aircraft?: aircraftUpdateOneRequiredWithoutFlightOperateNestedInput
    flight?: flightUpdateOneRequiredWithoutFlightOperatesNestedInput
    bookingFlights?: booking_flightUpdateManyWithoutFlightNestedInput
  }

  export type flightOperateUncheckedUpdateWithoutTicketsInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    bookingFlights?: booking_flightUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type seatUpsertWithoutTicketsInput = {
    update: XOR<seatUpdateWithoutTicketsInput, seatUncheckedUpdateWithoutTicketsInput>
    create: XOR<seatCreateWithoutTicketsInput, seatUncheckedCreateWithoutTicketsInput>
    where?: seatWhereInput
  }

  export type seatUpdateToOneWithWhereWithoutTicketsInput = {
    where?: seatWhereInput
    data: XOR<seatUpdateWithoutTicketsInput, seatUncheckedUpdateWithoutTicketsInput>
  }

  export type seatUpdateWithoutTicketsInput = {
    seatId?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
    row?: IntFieldUpdateOperationsInput | number
    class?: EnumSeatClassFieldUpdateOperationsInput | $Enums.SeatClass
    price?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    seatmap?: seatmap_infoUpdateOneRequiredWithoutSeatNestedInput
  }

  export type seatUncheckedUpdateWithoutTicketsInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
    row?: IntFieldUpdateOperationsInput | number
    class?: EnumSeatClassFieldUpdateOperationsInput | $Enums.SeatClass
    price?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
  }

  export type flightCreateWithoutTransitFromInput = {
    flightNum: string
    airline: airlineCreateNestedOneWithoutFlightInput
    departAirport: airportCreateNestedOneWithoutDepartFlightsInput
    arriveAirport: airportCreateNestedOneWithoutArriveFlightsInput
    flightOperates?: flightOperateCreateNestedManyWithoutFlightInput
    transitTo?: transitCreateNestedManyWithoutToInput
  }

  export type flightUncheckedCreateWithoutTransitFromInput = {
    flightNum: string
    airlineCode: string
    departAirportId: string
    arriveAirportId: string
    flightOperates?: flightOperateUncheckedCreateNestedManyWithoutFlightInput
    transitTo?: transitUncheckedCreateNestedManyWithoutToInput
  }

  export type flightCreateOrConnectWithoutTransitFromInput = {
    where: flightWhereUniqueInput
    create: XOR<flightCreateWithoutTransitFromInput, flightUncheckedCreateWithoutTransitFromInput>
  }

  export type flightCreateWithoutTransitToInput = {
    flightNum: string
    airline: airlineCreateNestedOneWithoutFlightInput
    departAirport: airportCreateNestedOneWithoutDepartFlightsInput
    arriveAirport: airportCreateNestedOneWithoutArriveFlightsInput
    flightOperates?: flightOperateCreateNestedManyWithoutFlightInput
    transitFrom?: transitCreateNestedManyWithoutFromInput
  }

  export type flightUncheckedCreateWithoutTransitToInput = {
    flightNum: string
    airlineCode: string
    departAirportId: string
    arriveAirportId: string
    flightOperates?: flightOperateUncheckedCreateNestedManyWithoutFlightInput
    transitFrom?: transitUncheckedCreateNestedManyWithoutFromInput
  }

  export type flightCreateOrConnectWithoutTransitToInput = {
    where: flightWhereUniqueInput
    create: XOR<flightCreateWithoutTransitToInput, flightUncheckedCreateWithoutTransitToInput>
  }

  export type flightUpsertWithoutTransitFromInput = {
    update: XOR<flightUpdateWithoutTransitFromInput, flightUncheckedUpdateWithoutTransitFromInput>
    create: XOR<flightCreateWithoutTransitFromInput, flightUncheckedCreateWithoutTransitFromInput>
    where?: flightWhereInput
  }

  export type flightUpdateToOneWithWhereWithoutTransitFromInput = {
    where?: flightWhereInput
    data: XOR<flightUpdateWithoutTransitFromInput, flightUncheckedUpdateWithoutTransitFromInput>
  }

  export type flightUpdateWithoutTransitFromInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airline?: airlineUpdateOneRequiredWithoutFlightNestedInput
    departAirport?: airportUpdateOneRequiredWithoutDepartFlightsNestedInput
    arriveAirport?: airportUpdateOneRequiredWithoutArriveFlightsNestedInput
    flightOperates?: flightOperateUpdateManyWithoutFlightNestedInput
    transitTo?: transitUpdateManyWithoutToNestedInput
  }

  export type flightUncheckedUpdateWithoutTransitFromInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departAirportId?: StringFieldUpdateOperationsInput | string
    arriveAirportId?: StringFieldUpdateOperationsInput | string
    flightOperates?: flightOperateUncheckedUpdateManyWithoutFlightNestedInput
    transitTo?: transitUncheckedUpdateManyWithoutToNestedInput
  }

  export type flightUpsertWithoutTransitToInput = {
    update: XOR<flightUpdateWithoutTransitToInput, flightUncheckedUpdateWithoutTransitToInput>
    create: XOR<flightCreateWithoutTransitToInput, flightUncheckedCreateWithoutTransitToInput>
    where?: flightWhereInput
  }

  export type flightUpdateToOneWithWhereWithoutTransitToInput = {
    where?: flightWhereInput
    data: XOR<flightUpdateWithoutTransitToInput, flightUncheckedUpdateWithoutTransitToInput>
  }

  export type flightUpdateWithoutTransitToInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airline?: airlineUpdateOneRequiredWithoutFlightNestedInput
    departAirport?: airportUpdateOneRequiredWithoutDepartFlightsNestedInput
    arriveAirport?: airportUpdateOneRequiredWithoutArriveFlightsNestedInput
    flightOperates?: flightOperateUpdateManyWithoutFlightNestedInput
    transitFrom?: transitUpdateManyWithoutFromNestedInput
  }

  export type flightUncheckedUpdateWithoutTransitToInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departAirportId?: StringFieldUpdateOperationsInput | string
    arriveAirportId?: StringFieldUpdateOperationsInput | string
    flightOperates?: flightOperateUncheckedUpdateManyWithoutFlightNestedInput
    transitFrom?: transitUncheckedUpdateManyWithoutFromNestedInput
  }

  export type bookingCreateWithoutUserInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    bookingFlights?: booking_flightCreateNestedManyWithoutBookingInput
    passengerBookings?: passenger_bookingCreateNestedManyWithoutBookingInput
    tickets?: ticketCreateNestedManyWithoutBookingInput
    payment?: paymentCreateNestedOneWithoutBookingInput
  }

  export type bookingUncheckedCreateWithoutUserInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
    bookingFlights?: booking_flightUncheckedCreateNestedManyWithoutBookingInput
    passengerBookings?: passenger_bookingUncheckedCreateNestedManyWithoutBookingInput
    tickets?: ticketUncheckedCreateNestedManyWithoutBookingInput
    payment?: paymentUncheckedCreateNestedOneWithoutBookingInput
  }

  export type bookingCreateOrConnectWithoutUserInput = {
    where: bookingWhereUniqueInput
    create: XOR<bookingCreateWithoutUserInput, bookingUncheckedCreateWithoutUserInput>
  }

  export type bookingCreateManyUserInputEnvelope = {
    data: bookingCreateManyUserInput | bookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type passengerCreateWithoutUserInput = {
    passportNum: string
    passportCountry: string
    passportExpiry: Date | string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    ageRange: $Enums.AgeRange
    passengerBookings?: passenger_bookingCreateNestedManyWithoutPassengerInput
    tickets?: ticketCreateNestedManyWithoutPassengerInput
  }

  export type passengerUncheckedCreateWithoutUserInput = {
    passportNum: string
    passportCountry: string
    passportExpiry: Date | string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    ageRange: $Enums.AgeRange
    passengerBookings?: passenger_bookingUncheckedCreateNestedManyWithoutPassengerInput
    tickets?: ticketUncheckedCreateNestedManyWithoutPassengerInput
  }

  export type passengerCreateOrConnectWithoutUserInput = {
    where: passengerWhereUniqueInput
    create: XOR<passengerCreateWithoutUserInput, passengerUncheckedCreateWithoutUserInput>
  }

  export type passengerCreateManyUserInputEnvelope = {
    data: passengerCreateManyUserInput | passengerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type bookingUpsertWithWhereUniqueWithoutUserInput = {
    where: bookingWhereUniqueInput
    update: XOR<bookingUpdateWithoutUserInput, bookingUncheckedUpdateWithoutUserInput>
    create: XOR<bookingCreateWithoutUserInput, bookingUncheckedCreateWithoutUserInput>
  }

  export type bookingUpdateWithWhereUniqueWithoutUserInput = {
    where: bookingWhereUniqueInput
    data: XOR<bookingUpdateWithoutUserInput, bookingUncheckedUpdateWithoutUserInput>
  }

  export type bookingUpdateManyWithWhereWithoutUserInput = {
    where: bookingScalarWhereInput
    data: XOR<bookingUpdateManyMutationInput, bookingUncheckedUpdateManyWithoutUserInput>
  }

  export type bookingScalarWhereInput = {
    AND?: bookingScalarWhereInput | bookingScalarWhereInput[]
    OR?: bookingScalarWhereInput[]
    NOT?: bookingScalarWhereInput | bookingScalarWhereInput[]
    bookingId?: StringFilter<"booking"> | string
    bookingDate?: DateTimeFilter<"booking"> | Date | string
    status?: EnumBookingStatusFilter<"booking"> | $Enums.BookingStatus
    userId?: StringFilter<"booking"> | string
  }

  export type passengerUpsertWithWhereUniqueWithoutUserInput = {
    where: passengerWhereUniqueInput
    update: XOR<passengerUpdateWithoutUserInput, passengerUncheckedUpdateWithoutUserInput>
    create: XOR<passengerCreateWithoutUserInput, passengerUncheckedCreateWithoutUserInput>
  }

  export type passengerUpdateWithWhereUniqueWithoutUserInput = {
    where: passengerWhereUniqueInput
    data: XOR<passengerUpdateWithoutUserInput, passengerUncheckedUpdateWithoutUserInput>
  }

  export type passengerUpdateManyWithWhereWithoutUserInput = {
    where: passengerScalarWhereInput
    data: XOR<passengerUpdateManyMutationInput, passengerUncheckedUpdateManyWithoutUserInput>
  }

  export type passengerScalarWhereInput = {
    AND?: passengerScalarWhereInput | passengerScalarWhereInput[]
    OR?: passengerScalarWhereInput[]
    NOT?: passengerScalarWhereInput | passengerScalarWhereInput[]
    passportNum?: StringFilter<"passenger"> | string
    passportCountry?: StringFilter<"passenger"> | string
    passportExpiry?: DateTimeFilter<"passenger"> | Date | string
    firstName?: StringFilter<"passenger"> | string
    lastName?: StringFilter<"passenger"> | string
    dateOfBirth?: DateTimeFilter<"passenger"> | Date | string
    nationality?: StringFilter<"passenger"> | string
    ageRange?: EnumAgeRangeFilter<"passenger"> | $Enums.AgeRange
    userId?: StringFilter<"passenger"> | string
  }

  export type aircraftCreateManyAirlineInput = {
    aircraftId: string
    model: string
  }

  export type aircraftCostCreateManyAirlineInput = {
    model: string
    costPerMile: number
  }

  export type flightCreateManyAirlineInput = {
    flightNum: string
    departAirportId: string
    arriveAirportId: string
  }

  export type aircraftUpdateWithoutAirlineInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    flightOperate?: flightOperateUpdateManyWithoutAircraftNestedInput
    aircraftSeatmap?: aircraft_seatmapUpdateManyWithoutAircraftNestedInput
  }

  export type aircraftUncheckedUpdateWithoutAirlineInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    flightOperate?: flightOperateUncheckedUpdateManyWithoutAircraftNestedInput
    aircraftSeatmap?: aircraft_seatmapUncheckedUpdateManyWithoutAircraftNestedInput
  }

  export type aircraftUncheckedUpdateManyWithoutAirlineInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
  }

  export type aircraftCostUpdateWithoutAirlineInput = {
    model?: StringFieldUpdateOperationsInput | string
    costPerMile?: FloatFieldUpdateOperationsInput | number
  }

  export type aircraftCostUncheckedUpdateWithoutAirlineInput = {
    model?: StringFieldUpdateOperationsInput | string
    costPerMile?: FloatFieldUpdateOperationsInput | number
  }

  export type aircraftCostUncheckedUpdateManyWithoutAirlineInput = {
    model?: StringFieldUpdateOperationsInput | string
    costPerMile?: FloatFieldUpdateOperationsInput | number
  }

  export type flightUpdateWithoutAirlineInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    departAirport?: airportUpdateOneRequiredWithoutDepartFlightsNestedInput
    arriveAirport?: airportUpdateOneRequiredWithoutArriveFlightsNestedInput
    flightOperates?: flightOperateUpdateManyWithoutFlightNestedInput
    transitFrom?: transitUpdateManyWithoutFromNestedInput
    transitTo?: transitUpdateManyWithoutToNestedInput
  }

  export type flightUncheckedUpdateWithoutAirlineInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    departAirportId?: StringFieldUpdateOperationsInput | string
    arriveAirportId?: StringFieldUpdateOperationsInput | string
    flightOperates?: flightOperateUncheckedUpdateManyWithoutFlightNestedInput
    transitFrom?: transitUncheckedUpdateManyWithoutFromNestedInput
    transitTo?: transitUncheckedUpdateManyWithoutToNestedInput
  }

  export type flightUncheckedUpdateManyWithoutAirlineInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    departAirportId?: StringFieldUpdateOperationsInput | string
    arriveAirportId?: StringFieldUpdateOperationsInput | string
  }

  export type flightOperateCreateManyAircraftInput = {
    flightId: string
    flightNum: string
    airlineCode: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
  }

  export type aircraft_seatmapCreateManyAircraftInput = {
    seatMapId: string
  }

  export type flightOperateUpdateWithoutAircraftInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
    flight?: flightUpdateOneRequiredWithoutFlightOperatesNestedInput
    bookingFlights?: booking_flightUpdateManyWithoutFlightNestedInput
    tickets?: ticketUpdateManyWithoutFlightNestedInput
  }

  export type flightOperateUncheckedUpdateWithoutAircraftInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
    bookingFlights?: booking_flightUncheckedUpdateManyWithoutFlightNestedInput
    tickets?: ticketUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type flightOperateUncheckedUpdateManyWithoutAircraftInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
  }

  export type aircraft_seatmapUpdateWithoutAircraftInput = {
    seatmap?: seatmap_infoUpdateOneRequiredWithoutAircraftNestedInput
  }

  export type aircraft_seatmapUncheckedUpdateWithoutAircraftInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
  }

  export type aircraft_seatmapUncheckedUpdateManyWithoutAircraftInput = {
    seatMapId?: StringFieldUpdateOperationsInput | string
  }

  export type flightCreateManyDepartAirportInput = {
    flightNum: string
    airlineCode: string
    arriveAirportId: string
  }

  export type flightCreateManyArriveAirportInput = {
    flightNum: string
    airlineCode: string
    departAirportId: string
  }

  export type flightUpdateWithoutDepartAirportInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airline?: airlineUpdateOneRequiredWithoutFlightNestedInput
    arriveAirport?: airportUpdateOneRequiredWithoutArriveFlightsNestedInput
    flightOperates?: flightOperateUpdateManyWithoutFlightNestedInput
    transitFrom?: transitUpdateManyWithoutFromNestedInput
    transitTo?: transitUpdateManyWithoutToNestedInput
  }

  export type flightUncheckedUpdateWithoutDepartAirportInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    arriveAirportId?: StringFieldUpdateOperationsInput | string
    flightOperates?: flightOperateUncheckedUpdateManyWithoutFlightNestedInput
    transitFrom?: transitUncheckedUpdateManyWithoutFromNestedInput
    transitTo?: transitUncheckedUpdateManyWithoutToNestedInput
  }

  export type flightUncheckedUpdateManyWithoutDepartAirportInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    arriveAirportId?: StringFieldUpdateOperationsInput | string
  }

  export type flightUpdateWithoutArriveAirportInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airline?: airlineUpdateOneRequiredWithoutFlightNestedInput
    departAirport?: airportUpdateOneRequiredWithoutDepartFlightsNestedInput
    flightOperates?: flightOperateUpdateManyWithoutFlightNestedInput
    transitFrom?: transitUpdateManyWithoutFromNestedInput
    transitTo?: transitUpdateManyWithoutToNestedInput
  }

  export type flightUncheckedUpdateWithoutArriveAirportInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departAirportId?: StringFieldUpdateOperationsInput | string
    flightOperates?: flightOperateUncheckedUpdateManyWithoutFlightNestedInput
    transitFrom?: transitUncheckedUpdateManyWithoutFromNestedInput
    transitTo?: transitUncheckedUpdateManyWithoutToNestedInput
  }

  export type flightUncheckedUpdateManyWithoutArriveAirportInput = {
    flightNum?: StringFieldUpdateOperationsInput | string
    airlineCode?: StringFieldUpdateOperationsInput | string
    departAirportId?: StringFieldUpdateOperationsInput | string
  }

  export type booking_flightCreateManyBookingInput = {
    flightId: string
  }

  export type passenger_bookingCreateManyBookingInput = {
    passportNum: string
  }

  export type ticketCreateManyBookingInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    flightId: string
    passportNum: string
    seatNum: string
  }

  export type booking_flightUpdateWithoutBookingInput = {
    flight?: flightOperateUpdateOneRequiredWithoutBookingFlightsNestedInput
  }

  export type booking_flightUncheckedUpdateWithoutBookingInput = {
    flightId?: StringFieldUpdateOperationsInput | string
  }

  export type booking_flightUncheckedUpdateManyWithoutBookingInput = {
    flightId?: StringFieldUpdateOperationsInput | string
  }

  export type passenger_bookingUpdateWithoutBookingInput = {
    passenger?: passengerUpdateOneRequiredWithoutPassengerBookingsNestedInput
  }

  export type passenger_bookingUncheckedUpdateWithoutBookingInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
  }

  export type passenger_bookingUncheckedUpdateManyWithoutBookingInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
  }

  export type ticketUpdateWithoutBookingInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    passenger?: passengerUpdateOneRequiredWithoutTicketsNestedInput
    flight?: flightOperateUpdateOneRequiredWithoutTicketsNestedInput
    seat?: seatUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type ticketUncheckedUpdateWithoutBookingInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    flightId?: StringFieldUpdateOperationsInput | string
    passportNum?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
  }

  export type ticketUncheckedUpdateManyWithoutBookingInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    flightId?: StringFieldUpdateOperationsInput | string
    passportNum?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
  }

  export type flightOperateCreateManyFlightInput = {
    flightId: string
    departureTime: Date | string
    arrivalTime: Date | string
    departureGate: string
    aircraftId: string
  }

  export type transitCreateManyFromInput = {
    flightNumTo: string
    airlineCodeTo: string
  }

  export type transitCreateManyToInput = {
    flightNumFrom: string
    airlineCodeFrom: string
  }

  export type flightOperateUpdateWithoutFlightInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
    aircraft?: aircraftUpdateOneRequiredWithoutFlightOperateNestedInput
    bookingFlights?: booking_flightUpdateManyWithoutFlightNestedInput
    tickets?: ticketUpdateManyWithoutFlightNestedInput
  }

  export type flightOperateUncheckedUpdateWithoutFlightInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
    bookingFlights?: booking_flightUncheckedUpdateManyWithoutFlightNestedInput
    tickets?: ticketUncheckedUpdateManyWithoutFlightNestedInput
  }

  export type flightOperateUncheckedUpdateManyWithoutFlightInput = {
    flightId?: StringFieldUpdateOperationsInput | string
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureGate?: StringFieldUpdateOperationsInput | string
    aircraftId?: StringFieldUpdateOperationsInput | string
  }

  export type transitUpdateWithoutFromInput = {
    to?: flightUpdateOneRequiredWithoutTransitToNestedInput
  }

  export type transitUncheckedUpdateWithoutFromInput = {
    flightNumTo?: StringFieldUpdateOperationsInput | string
    airlineCodeTo?: StringFieldUpdateOperationsInput | string
  }

  export type transitUncheckedUpdateManyWithoutFromInput = {
    flightNumTo?: StringFieldUpdateOperationsInput | string
    airlineCodeTo?: StringFieldUpdateOperationsInput | string
  }

  export type transitUpdateWithoutToInput = {
    from?: flightUpdateOneRequiredWithoutTransitFromNestedInput
  }

  export type transitUncheckedUpdateWithoutToInput = {
    flightNumFrom?: StringFieldUpdateOperationsInput | string
    airlineCodeFrom?: StringFieldUpdateOperationsInput | string
  }

  export type transitUncheckedUpdateManyWithoutToInput = {
    flightNumFrom?: StringFieldUpdateOperationsInput | string
    airlineCodeFrom?: StringFieldUpdateOperationsInput | string
  }

  export type booking_flightCreateManyFlightInput = {
    bookingId: string
  }

  export type ticketCreateManyFlightInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    bookingId: string
    passportNum: string
    seatNum: string
  }

  export type booking_flightUpdateWithoutFlightInput = {
    booking?: bookingUpdateOneRequiredWithoutBookingFlightsNestedInput
  }

  export type booking_flightUncheckedUpdateWithoutFlightInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
  }

  export type booking_flightUncheckedUpdateManyWithoutFlightInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
  }

  export type ticketUpdateWithoutFlightInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    booking?: bookingUpdateOneRequiredWithoutTicketsNestedInput
    passenger?: passengerUpdateOneRequiredWithoutTicketsNestedInput
    seat?: seatUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type ticketUncheckedUpdateWithoutFlightInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    bookingId?: StringFieldUpdateOperationsInput | string
    passportNum?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
  }

  export type ticketUncheckedUpdateManyWithoutFlightInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    bookingId?: StringFieldUpdateOperationsInput | string
    passportNum?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
  }

  export type passenger_bookingCreateManyPassengerInput = {
    bookingId: string
  }

  export type ticketCreateManyPassengerInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    bookingId: string
    flightId: string
    seatNum: string
  }

  export type passenger_bookingUpdateWithoutPassengerInput = {
    booking?: bookingUpdateOneRequiredWithoutPassengerBookingsNestedInput
  }

  export type passenger_bookingUncheckedUpdateWithoutPassengerInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
  }

  export type passenger_bookingUncheckedUpdateManyWithoutPassengerInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
  }

  export type ticketUpdateWithoutPassengerInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    booking?: bookingUpdateOneRequiredWithoutTicketsNestedInput
    flight?: flightOperateUpdateOneRequiredWithoutTicketsNestedInput
    seat?: seatUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type ticketUncheckedUpdateWithoutPassengerInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    bookingId?: StringFieldUpdateOperationsInput | string
    flightId?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
  }

  export type ticketUncheckedUpdateManyWithoutPassengerInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    bookingId?: StringFieldUpdateOperationsInput | string
    flightId?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
  }

  export type seatCreateManySeatmapInput = {
    seatId: string
    seatNum: string
    row?: number
    class?: $Enums.SeatClass
    price?: number
    features: string
    floor?: number
  }

  export type aircraft_seatmapCreateManySeatmapInput = {
    aircraftId: string
  }

  export type seatUpdateWithoutSeatmapInput = {
    seatId?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
    row?: IntFieldUpdateOperationsInput | number
    class?: EnumSeatClassFieldUpdateOperationsInput | $Enums.SeatClass
    price?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    tickets?: ticketUpdateManyWithoutSeatNestedInput
  }

  export type seatUncheckedUpdateWithoutSeatmapInput = {
    seatId?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
    row?: IntFieldUpdateOperationsInput | number
    class?: EnumSeatClassFieldUpdateOperationsInput | $Enums.SeatClass
    price?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
    tickets?: ticketUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type seatUncheckedUpdateManyWithoutSeatmapInput = {
    seatId?: StringFieldUpdateOperationsInput | string
    seatNum?: StringFieldUpdateOperationsInput | string
    row?: IntFieldUpdateOperationsInput | number
    class?: EnumSeatClassFieldUpdateOperationsInput | $Enums.SeatClass
    price?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    floor?: IntFieldUpdateOperationsInput | number
  }

  export type aircraft_seatmapUpdateWithoutSeatmapInput = {
    aircraft?: aircraftUpdateOneRequiredWithoutAircraftSeatmapNestedInput
  }

  export type aircraft_seatmapUncheckedUpdateWithoutSeatmapInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
  }

  export type aircraft_seatmapUncheckedUpdateManyWithoutSeatmapInput = {
    aircraftId?: StringFieldUpdateOperationsInput | string
  }

  export type ticketCreateManySeatInput = {
    ticketNum: string
    farePackage?: $Enums.FarePackage
    baggageAllowanceWeight?: number
    baggageAllowancePrice?: number
    mealSelection: string
    mealPrice?: number
    ticketPrice?: number
    bookingId: string
    flightId: string
    passportNum: string
  }

  export type ticketUpdateWithoutSeatInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    booking?: bookingUpdateOneRequiredWithoutTicketsNestedInput
    passenger?: passengerUpdateOneRequiredWithoutTicketsNestedInput
    flight?: flightOperateUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type ticketUncheckedUpdateWithoutSeatInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    bookingId?: StringFieldUpdateOperationsInput | string
    flightId?: StringFieldUpdateOperationsInput | string
    passportNum?: StringFieldUpdateOperationsInput | string
  }

  export type ticketUncheckedUpdateManyWithoutSeatInput = {
    ticketNum?: StringFieldUpdateOperationsInput | string
    farePackage?: EnumFarePackageFieldUpdateOperationsInput | $Enums.FarePackage
    baggageAllowanceWeight?: IntFieldUpdateOperationsInput | number
    baggageAllowancePrice?: FloatFieldUpdateOperationsInput | number
    mealSelection?: StringFieldUpdateOperationsInput | string
    mealPrice?: FloatFieldUpdateOperationsInput | number
    ticketPrice?: FloatFieldUpdateOperationsInput | number
    bookingId?: StringFieldUpdateOperationsInput | string
    flightId?: StringFieldUpdateOperationsInput | string
    passportNum?: StringFieldUpdateOperationsInput | string
  }

  export type bookingCreateManyUserInput = {
    bookingId: string
    bookingDate?: Date | string
    status?: $Enums.BookingStatus
  }

  export type passengerCreateManyUserInput = {
    passportNum: string
    passportCountry: string
    passportExpiry: Date | string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    nationality: string
    ageRange: $Enums.AgeRange
  }

  export type bookingUpdateWithoutUserInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingFlights?: booking_flightUpdateManyWithoutBookingNestedInput
    passengerBookings?: passenger_bookingUpdateManyWithoutBookingNestedInput
    tickets?: ticketUpdateManyWithoutBookingNestedInput
    payment?: paymentUpdateOneWithoutBookingNestedInput
  }

  export type bookingUncheckedUpdateWithoutUserInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    bookingFlights?: booking_flightUncheckedUpdateManyWithoutBookingNestedInput
    passengerBookings?: passenger_bookingUncheckedUpdateManyWithoutBookingNestedInput
    tickets?: ticketUncheckedUpdateManyWithoutBookingNestedInput
    payment?: paymentUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type bookingUncheckedUpdateManyWithoutUserInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
  }

  export type passengerUpdateWithoutUserInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
    passportCountry?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    ageRange?: EnumAgeRangeFieldUpdateOperationsInput | $Enums.AgeRange
    passengerBookings?: passenger_bookingUpdateManyWithoutPassengerNestedInput
    tickets?: ticketUpdateManyWithoutPassengerNestedInput
  }

  export type passengerUncheckedUpdateWithoutUserInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
    passportCountry?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    ageRange?: EnumAgeRangeFieldUpdateOperationsInput | $Enums.AgeRange
    passengerBookings?: passenger_bookingUncheckedUpdateManyWithoutPassengerNestedInput
    tickets?: ticketUncheckedUpdateManyWithoutPassengerNestedInput
  }

  export type passengerUncheckedUpdateManyWithoutUserInput = {
    passportNum?: StringFieldUpdateOperationsInput | string
    passportCountry?: StringFieldUpdateOperationsInput | string
    passportExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    nationality?: StringFieldUpdateOperationsInput | string
    ageRange?: EnumAgeRangeFieldUpdateOperationsInput | $Enums.AgeRange
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}